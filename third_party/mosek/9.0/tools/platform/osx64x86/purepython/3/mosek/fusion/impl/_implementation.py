import numpy
import types
import io
import sys
import mosek

def _():
  import types

  class Enum:
    @staticmethod
    def __inst(c,name):
      o = c()
      o.name  = name
      o.value = len(c.__members__)
      c.__members__.append(o)
      setattr(c, name, o)

    @classmethod
    def fromInt(c,value):
      return c.members[value]

    @staticmethod
    def new(name,membernames):
      members = []
      c = type(name, (Enum,),{ '__members__' : members })
      for n in membernames:
        Enum.__inst(c,n)
      return c
    @classmethod
    def members(c):
      return iter(c.__members__)

    def __str__(self):
      return self.__class__.__name__ + "." + self.name
    def __repr__(self):
      return self.__class__.__name__ + "." + self.name
  return Enum

class _monty:
  Enum = _()
  @staticmethod
  def deduceShape(l,dim):
    def _deduceShape(l,dim):
      if dim > 1:
        shplst = [ _deduceShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          shplst[0].append(len(l))
          return shplst[0]
        else:
          raise TypeError("Irregular array shape")
      else:
        return [len(dim)]
    return tuple(reversed(_deduceShape(l,dim)))
  @staticmethod
  def checkShape(l,dim):
    def _checkShape(l,dim):
      if dim > 1:
        shplst = [ _checkShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          pass
        else:
          raise TypeError("Irregular array shape")
        return len(l)
      else:
        try:
          return len(l)
        except TypeError:
          raise TypeError("Wrong or irregular array shape")
    _checkShape(l,dim)
    return dim
  @staticmethod
  def initJaggedArray(data, nd):
    dims = []
    d = data
    for i in range(nd):
      dims.append(len(d))
      d = d[0]

    res = numpy.zeros(dims,dtype=object)
    key = tuple([ slice(d) for d in dims ])
    try:
      res.__setitem__(key, data)
    except ValueError: # weird numpypy bug
      if   len(key) == 1:
        for i in range(0,dims[0]): res[i] = data[i]
      elif len(key) == 2:
        for i in range(0,dims[0]):
          for j in range(0,dims[1]):
            res[i,j] = data[i][j]
      elif len(key) == 3:
        for i in range(0,dims[0]):
          for j in range(0,dims[1]):
            for k in range(0,dims[2]):
              res[i,j,k] = data[i][j][k]
      else:
        assert 0 # Because hopefully we will get a real fix in numpypy before this case is hi
    return res

  @staticmethod
  def makeJaggedArray(src,ndims,dtype):
    if src is None:
      return None
    elif len(ndims) == 1:
      if ndims[0] == 1:
        r = numpy.zeros((len(src),),dtype=dtype)
        r[:] = src
      else:
        d = _monty.deduceDims(src,ndims[0])
        r = numpy.zeros(d,dtype=dtype)
        r.__setitem__(tuple([slice(None)]*ndims[0]),src) # basically: r[:,...,:] = src
      return r
    elif ndims[0] == 1:
      r = numpy.zeros((len(src),),dtype=numpy.dtype(object))
      # Note: This is a bit tricky to do reliably with numpy as it
      # tends to think we are dealing with multidimensional arrays and
      # explode
      for i,s in enumerate(src):
        r[i] = _monty.makeJaggedArray(s,ndims[1:],dtype)

      #r[:] = [ _monty.makeJaggedArray(s,ndims[1:],dtype) for s in src ]
      return r
    else:
      d = _monty.deduceDims(src,ndims[0])
      def _(src,nd):
        if nd == 0:
          return _monty.makeJaggedArray(src)
        else:
          return [ _(s,nd-1) for s in src ]

      r = numpy.zeros(d,dtype=numpy.dtype(object))
      r.__setitem__(tuple([slice(None)]*ndims[0]),_(src,ndims[0])) # basically: r[:,...,:] = convert(src)
      return r

  @staticmethod
  def copyArray(src,dst,dim):
    if dim == 1:
      src[:] = dst[:]
    else:
      for i in range(len(src)):
        _monty.copyArray(src[i],dst[i],dim-1)
  @staticmethod
  def arg_match_sloppy_array(v,elmmatch,dim,l=None):
    if dim == 0:
      elmmatch(v)
    elif dim == 1:
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      for e in v:
        if not elmmatch(e): return False
      return True
    elif isinstance(v,list) or isinstance(v,numpy.ndarray):
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      elif not (isinstance(v[0],list) or isinstance(v[0],numpy.ndarray)): return False
      
      top_len = len(v[0])
      for e in v:
        if not _monty.arg_match_sloppy_array(e,elmmatch,dim-1,top_len): return False
      return True
    else:
      return False
    
del _

mosek_fusion_RelationKey=_monty.Enum.new('RelationKey',['EqualsTo','LessThan','GreaterThan','IsFree','InRange'])
mosek_fusion_PSDKey=_monty.Enum.new('PSDKey',['IsSymPSD','IsTrilPSD'])
mosek_fusion_QConeKey=_monty.Enum.new('QConeKey',['InQCone','InRotatedQCone','InPExpCone','InPPowCone','InDExpCone','InDPowCone'])
mosek_fusion_ObjectiveSense=_monty.Enum.new('ObjectiveSense',['Undefined','Minimize','Maximize'])
mosek_fusion_SolutionStatus=_monty.Enum.new('SolutionStatus',['Undefined','Unknown','Optimal','Feasible','Certificate','IllposedCert'])
mosek_fusion_AccSolutionStatus=_monty.Enum.new('AccSolutionStatus',['Anything','Optimal','Feasible','Certificate'])
mosek_fusion_ProblemStatus=_monty.Enum.new('ProblemStatus',['Unknown','PrimalAndDualFeasible','PrimalFeasible','DualFeasible','PrimalInfeasible','DualInfeasible','PrimalAndDualInfeasible','IllPosed','PrimalInfeasibleOrUnbounded'])
mosek_fusion_SolutionType=_monty.Enum.new('SolutionType',['Default','Basic','Interior','Integer'])
mosek_fusion_StatusKey=_monty.Enum.new('StatusKey',['Unknown','Basic','SuperBasic','OnBound','Infinity'])
#BEFORE CLASS
def __mk_mosek_fusion_Expression():
 class Expression:
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Expression._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Expression._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Expression._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.index(int32)\n\tmosek.fusion.Expression.index(array(int32,ndim=1))')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Expression._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getND()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Expression._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getSize()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Expression._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getShape()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Expression._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.toString()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Expression._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Expression._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Expression._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.slice(int32,int32)\n\tmosek.fusion.Expression.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_Expression._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getDim(int32)')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Expression._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.pick(array(int32,ndim=1))\n\tmosek.fusion.Expression.pick(array(int32,ndim=2))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_Expression._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_Expression._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_Expression._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.eval()\n\tmosek.fusion.Expression.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.Expression: '+self._toString_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_eval_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_eval_(*args):
    if len(args) != 0: return False
    return True
  def _eval_alt_(self,):
    return self._eval_()
  def _eval_(self,):
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
 return Expression
mosek_fusion_Expression=__mk_mosek_fusion_Expression()
del __mk_mosek_fusion_Expression
#BEFORE CLASS
def __mk_mosek_fusion_Variable():
 class Variable(mosek_fusion_Expression):
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_Variable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeContinuous()')
  def numInst(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_numInst_(*args): # 
      return self._numInst_(*args)
    elif mosek_fusion_Variable._match_alt_numInst_(*args): # 
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.numInst()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Variable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Variable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Variable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_Variable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_Variable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_Variable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_Variable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.index(int32)\n\tmosek.fusion.Variable.index(array(int32,ndim=1))\n\tmosek.fusion.Variable.index(int32,int32)\n\tmosek.fusion.Variable.index(int32,int32,int32)')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_Variable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.asExpr()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Variable._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getShape()')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_Variable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.dual()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Variable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.toString()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_set_1values__3DZ(*args): # []double,bool
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_Variable._match_alt_set_1values__3DZ(*args): # []double,bool
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.set_values(array(double,ndim=1),bool)')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Variable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.pick(array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=2))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Variable._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getModel()')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_Variable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.level()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Variable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.transpose()')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_inst_I_3J(*args): # int32,[]int64
      return self._inst_I_3J(*args)
    elif mosek_fusion_Variable._match_alt_inst_I_3J(*args): # int32,[]int64
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_Variable._match_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_Variable._match_alt_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.Variable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.values(int32,array(double,ndim=1),bool)')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_Variable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_Variable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_Variable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.diag()\n\tmosek.fusion.Variable.diag(int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Variable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Variable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.slice(int32,int32)\n\tmosek.fusion.Variable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_Variable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_continuous()')
  def setLevel(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_setLevel__3D(*args): # []double
      return self._setLevel__3D(*args)
    elif mosek_fusion_Variable._match_alt_setLevel__3D(*args): # []double
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.setLevel(array(double,ndim=1))')
  def reshape(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_reshape__3I(*args): # []int32
      return self._reshape__3I(*args)
    elif mosek_fusion_Variable._match_alt_reshape__3I(*args): # []int32
      return self._reshape_alt__3I(*args)
    elif mosek_fusion_Variable._match_reshape_I(*args): # int32
      return self._reshape_I(*args)
    elif mosek_fusion_Variable._match_alt_reshape_I(*args): # int32
      return self._reshape_alt_I(*args)
    elif mosek_fusion_Variable._match_reshape_II(*args): # int32,int32
      return self._reshape_II(*args)
    elif mosek_fusion_Variable._match_alt_reshape_II(*args): # int32,int32
      return self._reshape_alt_II(*args)
    elif mosek_fusion_Variable._match_reshape_III(*args): # int32,int32,int32
      return self._reshape_III(*args)
    elif mosek_fusion_Variable._match_alt_reshape_III(*args): # int32,int32,int32
      return self._reshape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.reshape(array(int32,ndim=1))\n\tmosek.fusion.Variable.reshape(int32)\n\tmosek.fusion.Variable.reshape(int32,int32)\n\tmosek.fusion.Variable.reshape(int32,int32,int32)')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Variable._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getND()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Variable._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getSize()')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_Variable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_integer()')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_Variable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeInteger()')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_Variable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.antidiag()\n\tmosek.fusion.Variable.antidiag(int32)')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.Variable: '+self._toString_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   pass
  @staticmethod
  def _match_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match__3J__(_3))
  @staticmethod
  def _match_alt_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match__3J__(_3))
  def _inst_alt_I_3JI_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3JI_3J(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3JI_3J(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   pass
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1))
  def _inst_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setLevel_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setLevel__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setLevel__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _reshape_alt_III(self,_t__0,_t__1,_t__2):
    return self._reshape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _reshape_III(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _reshape_alt_II(self,_t__0,_t__1):
    return self._reshape_II(numpy.int32(__0),numpy.int32(__1))
  def _reshape_II(self,_0,_1):
   pass
  @staticmethod
  def _match_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _reshape_alt_I(self,_t__0):
    return self._reshape_I(numpy.int32(__0))
  def _reshape_I(self,_0):
   pass
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _reshape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._reshape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _reshape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Z__(_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Z__(_1))
  def _set_1values_alt__3DZ(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = self._set_1values__3DZ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3DZ(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   pass
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   pass
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   pass
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   pass
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   pass
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   pass
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   pass
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _index_alt_III(self,_t__0,_t__1,_t__2):
    return self._index_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _index_III(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _index_alt_II(self,_t__0,_t__1):
    return self._index_II(numpy.int32(__0),numpy.int32(__1))
  def _index_II(self,_0,_1):
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   pass
 return Variable
mosek_fusion_Variable=__mk_mosek_fusion_Variable()
del __mk_mosek_fusion_Variable
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricVariable():
 class SymmetricVariable(mosek_fusion_Variable):
  def __repr__(self): return 'mosek.fusion.SymmetricVariable'
 return SymmetricVariable
mosek_fusion_SymmetricVariable=__mk_mosek_fusion_SymmetricVariable()
del __mk_mosek_fusion_SymmetricVariable
#BEFORE CLASS
def __mk_mosek_fusion_FusionException():
 class FusionException(Exception):
  __slots__ = ['_FusionException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionException.ctor(string)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FusionException._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FusionException._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionException.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.FusionException: '+self._toString_()
  @staticmethod
  def _ctor_S(msg_):
    o = FusionException.__new__(FusionException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionException
mosek_fusion_FusionException=__mk_mosek_fusion_FusionException()
del __mk_mosek_fusion_FusionException
#BEFORE CLASS
def __mk_mosek_fusion_SolutionError():
 class SolutionError(mosek_fusion_FusionException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionError.ctor()\n\tmosek.fusion.SolutionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SolutionError'
  @staticmethod
  def _ctor_():
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionException._ctor_init_S(self,"Solution is invalid or undefined")
  @staticmethod
  def _ctor_S(msg):
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionException._ctor_init_S(self,msg)
 return SolutionError
mosek_fusion_SolutionError=__mk_mosek_fusion_SolutionError()
del __mk_mosek_fusion_SolutionError
#BEFORE CLASS
def __mk_mosek_fusion_UnimplementedError():
 class UnimplementedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnimplementedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnimplementedError'
  @staticmethod
  def _ctor_S(msg):
    o = UnimplementedError.__new__(UnimplementedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnimplementedError
mosek_fusion_UnimplementedError=__mk_mosek_fusion_UnimplementedError()
del __mk_mosek_fusion_UnimplementedError
#BEFORE CLASS
def __mk_mosek_fusion_FatalError():
 class FatalError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FatalError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.FatalError'
  @staticmethod
  def _ctor_S(msg):
    o = FatalError.__new__(FatalError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return FatalError
mosek_fusion_FatalError=__mk_mosek_fusion_FatalError()
del __mk_mosek_fusion_FatalError
#BEFORE CLASS
def __mk_mosek_fusion_UnexpectedError():
 class UnexpectedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4FusionException_2(*args): # mosek.fusion.FusionException
      self._ctor_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):# mosek.fusion.FusionException
      self._ctor_alt_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnexpectedError.ctor(mosek.fusion.FusionException)\n\tmosek.fusion.UnexpectedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnexpectedError'
  @staticmethod
  def _ctor_Lmosek_4fusion_4FusionException_2(e):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_Lmosek_4fusion_4FusionException_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4FusionException_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4FusionException_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4FusionException_2(self,e):
    self._ctor_init_Lmosek_4fusion_4FusionException_2(e)
  def _ctor_init_Lmosek_4fusion_4FusionException_2(self,e):
   Exception.__init__(self,e.toString())
  @staticmethod
  def _ctor_S(msg):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnexpectedError
mosek_fusion_UnexpectedError=__mk_mosek_fusion_UnexpectedError()
del __mk_mosek_fusion_UnexpectedError
#BEFORE CLASS
def __mk_mosek_fusion_FusionRuntimeException():
 class FusionRuntimeException(Exception):
  __slots__ = ['_FusionRuntimeException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionRuntimeException.ctor(string)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FusionRuntimeException._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FusionRuntimeException._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionRuntimeException.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.FusionRuntimeException: '+self._toString_()
  @staticmethod
  def _ctor_S(msg_):
    o = FusionRuntimeException.__new__(FusionRuntimeException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionRuntimeException
mosek_fusion_FusionRuntimeException=__mk_mosek_fusion_FusionRuntimeException()
del __mk_mosek_fusion_FusionRuntimeException
#BEFORE CLASS
def __mk_mosek_fusion_SparseFormatError():
 class SparseFormatError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SparseFormatError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SparseFormatError'
  @staticmethod
  def _ctor_S(msg):
    o = SparseFormatError.__new__(SparseFormatError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SparseFormatError
mosek_fusion_SparseFormatError=__mk_mosek_fusion_SparseFormatError()
del __mk_mosek_fusion_SparseFormatError
#BEFORE CLASS
def __mk_mosek_fusion_SliceError():
 class SliceError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SliceError.ctor()\n\tmosek.fusion.SliceError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SliceError'
  @staticmethod
  def _ctor_():
    o = SliceError.__new__(SliceError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,"Invalid slice range")
  @staticmethod
  def _ctor_S(msg):
    o = SliceError.__new__(SliceError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SliceError
mosek_fusion_SliceError=__mk_mosek_fusion_SliceError()
del __mk_mosek_fusion_SliceError
#BEFORE CLASS
def __mk_mosek_fusion_SetDefinitionError():
 class SetDefinitionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SetDefinitionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SetDefinitionError'
  @staticmethod
  def _ctor_S(msg):
    o = SetDefinitionError.__new__(SetDefinitionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SetDefinitionError
mosek_fusion_SetDefinitionError=__mk_mosek_fusion_SetDefinitionError()
del __mk_mosek_fusion_SetDefinitionError
#BEFORE CLASS
def __mk_mosek_fusion_OptimizeError():
 class OptimizeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.OptimizeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.OptimizeError'
  @staticmethod
  def _ctor_S(msg):
    o = OptimizeError.__new__(OptimizeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return OptimizeError
mosek_fusion_OptimizeError=__mk_mosek_fusion_OptimizeError()
del __mk_mosek_fusion_OptimizeError
#BEFORE CLASS
def __mk_mosek_fusion_NameError():
 class NameError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.NameError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.NameError'
  @staticmethod
  def _ctor_S(msg):
    o = NameError.__new__(NameError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return NameError
mosek_fusion_NameError=__mk_mosek_fusion_NameError()
del __mk_mosek_fusion_NameError
#BEFORE CLASS
def __mk_mosek_fusion_ModelError():
 class ModelError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ModelError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ModelError'
  @staticmethod
  def _ctor_S(msg):
    o = ModelError.__new__(ModelError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ModelError
mosek_fusion_ModelError=__mk_mosek_fusion_ModelError()
del __mk_mosek_fusion_ModelError
#BEFORE CLASS
def __mk_mosek_fusion_MatrixError():
 class MatrixError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.MatrixError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.MatrixError'
  @staticmethod
  def _ctor_S(msg):
    o = MatrixError.__new__(MatrixError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return MatrixError
mosek_fusion_MatrixError=__mk_mosek_fusion_MatrixError()
del __mk_mosek_fusion_MatrixError
#BEFORE CLASS
def __mk_mosek_fusion_DimensionError():
 class DimensionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DimensionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DimensionError'
  @staticmethod
  def _ctor_S(msg):
    o = DimensionError.__new__(DimensionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DimensionError
mosek_fusion_DimensionError=__mk_mosek_fusion_DimensionError()
del __mk_mosek_fusion_DimensionError
#BEFORE CLASS
def __mk_mosek_fusion_LengthError():
 class LengthError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LengthError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.LengthError'
  @staticmethod
  def _ctor_S(msg):
    o = LengthError.__new__(LengthError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return LengthError
mosek_fusion_LengthError=__mk_mosek_fusion_LengthError()
del __mk_mosek_fusion_LengthError
#BEFORE CLASS
def __mk_mosek_fusion_RangeError():
 class RangeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.RangeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.RangeError'
  @staticmethod
  def _ctor_S(msg):
    o = RangeError.__new__(RangeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return RangeError
mosek_fusion_RangeError=__mk_mosek_fusion_RangeError()
del __mk_mosek_fusion_RangeError
#BEFORE CLASS
def __mk_mosek_fusion_IndexError():
 class IndexError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IndexError'
  @staticmethod
  def _ctor_S(msg):
    o = IndexError.__new__(IndexError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IndexError
mosek_fusion_IndexError=__mk_mosek_fusion_IndexError()
del __mk_mosek_fusion_IndexError
#BEFORE CLASS
def __mk_mosek_fusion_DomainError():
 class DomainError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DomainError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DomainError'
  @staticmethod
  def _ctor_S(msg):
    o = DomainError.__new__(DomainError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DomainError
mosek_fusion_DomainError=__mk_mosek_fusion_DomainError()
del __mk_mosek_fusion_DomainError
#BEFORE CLASS
def __mk_mosek_fusion_ValueConversionError():
 class ValueConversionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ValueConversionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ValueConversionError'
  @staticmethod
  def _ctor_S(msg):
    o = ValueConversionError.__new__(ValueConversionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ValueConversionError
mosek_fusion_ValueConversionError=__mk_mosek_fusion_ValueConversionError()
del __mk_mosek_fusion_ValueConversionError
#BEFORE CLASS
def __mk_mosek_fusion_ParameterError():
 class ParameterError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ParameterError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ParameterError'
  @staticmethod
  def _ctor_S(msg):
    o = ParameterError.__new__(ParameterError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ParameterError
mosek_fusion_ParameterError=__mk_mosek_fusion_ParameterError()
del __mk_mosek_fusion_ParameterError
#BEFORE CLASS
def __mk_mosek_fusion_ExpressionError():
 class ExpressionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExpressionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ExpressionError'
  @staticmethod
  def _ctor_S(msg):
    o = ExpressionError.__new__(ExpressionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ExpressionError
mosek_fusion_ExpressionError=__mk_mosek_fusion_ExpressionError()
del __mk_mosek_fusion_ExpressionError
#BEFORE CLASS
def __mk_mosek_fusion_IOError():
 class IOError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IOError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IOError'
  @staticmethod
  def _ctor_S(msg):
    o = IOError.__new__(IOError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IOError
mosek_fusion_IOError=__mk_mosek_fusion_IOError()
del __mk_mosek_fusion_IOError
def __mk_mosek_fusion_BaseModel():
  import threading
  import mosek
  import mosek.fusion
  import numpy
  
  
  class BaseModel(object):
    _lock = threading.Lock()
    _global_env = None
    _global_env_counter = 0
  
    @classmethod
    def _globalEnv(self):
      self._lock.acquire()
      try:
        if BaseModel._global_env is None:
          try:
            env = mosek.Env()
            BaseModel._global_env = env
            BaseModel._global_env_counter += 1
          except mosek.Exception as e:
            raise UnexpectedError(e)
        return BaseModel._global_env
      finally:
        self._lock.release()
  
    @classmethod
    def _env_1putlicensecode__3I(self,code):
      self._globalEnv().putlicensecode(code)
  
    @classmethod
    def _env_1putlicensepath_S(self,path):
      self._globalEnv().putlicensepath(path)
  
    @classmethod
    def _env_1putlicensewait_Z(self,yn):
      if yn:
        self._globalEnv().putlicensewait(1)
      else:
        self._globalEnv().putlicensewait(0)
  
    @classmethod
    def _env_1getversion_(self):
      return ".".join([str(_) for _ in mosek.Env.getversion()])
  
    def __callback(self,callbackkey,dinf,iinf,liinf):
      if self.__user_cb is not None:
        try:
          if self.__user_cb(callbackkey,dinf,iinf,liinf):
            self.__break = True
        except:
          self.__break = True
      if self.__user_pgs is not None:
        try:
          if self.__user_pgs(callbackkey):
            self.__break = True
        except:
          self.__break = True
      return 1 if self.__break else 0
  
    def _ctor_init_SS(self,name,licfile):
      env = self._globalEnv()
      self.__modelname = name
      self.__break = False
      task = mosek.Task(self._global_env, 0, 0);
      self.__user_cb = None
      self.__user_pgs = None
      finished = False
      try:
        task.putintparam(mosek.iparam.log_expand,0);
        self.__task = task
        if name is not None:
          task.puttaskname(name)
  
        self._synched = mosek_fusion_SolutionStatus.Optimal;
  
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None
  
        self.__objname = None
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
  
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def _ctor_init_Lmosek_4fusion_4BaseModel_2(self,m):
      env = self._globalEnv()
      self.__modelname = m.__modelname
      self.__break = False
      self.__user_cb = None
      self.__user_pgs = None
      task = mosek.Task(m.__task)
      finished = False
      try:
        self.__task = task
        self._synched = m._synched
  
        self._sol_itr = m._sol_itr._clone_() if m._sol_itr is not None else None
        self._sol_bas = m._sol_bas._clone_() if m._sol_bas is not None else None
        self._sol_itg = m._sol_itg._clone_() if m._sol_itg is not None else None
  
        self.__objname = m.__objname
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
  
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def __del__(self):
        lock = self._lock
        if hasattr(self,'_BaseModel__task'):
          lock.acquire()
          try:
            task = self.__task
            BaseModel._global_env_counter -= 1
            task.__del__()
  
            for a in self.__class__.__slots__ + ['_sol_itr','_sol_bas','_sol_itg',
                                                 '_BaseModel__user_cb','_BaseModel__user_pgs','_BaseModel__loghandler','_BaseModel__logwriter','_BaseModel__task']:
              try: delattr(self,a)
              except AttributeError: pass
          finally:
            lock.release()
  
    def __enter__(self):
      return self
    def __exit__(self,exc_type,exc_val,exc_tb):
      self.__del__()
    def _dispose_(self):
      self.__del__()
  
    def _task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,handler):
      self.__user_cb = handler
    def _task_1setCallbackHandler_LSystem_4CallbackHandler_2(self,handler):
      self.__user_pgs = handler
  
    def _task_1setLogHandler_LSystem_4StreamWriter_2(self,handler):
      """
      Set the object to handle log output from the solver.
  
      The handler object must have a write method accepting a string.
      """
      self.__logwriter = handler
  
    def _task_1put_1param_SS(self,name,value):
      self.__task.putnastrparam(name,value)
    def _task_1put_1param_SD(self,name,value):
      self.__task.putnadouparam(name,value)
    def _task_1put_1param_SI(self,name,value):
      self.__task.putnaintparam(name,value)
  
    def _task_1get_1dinf_S(self,name):
      key = mosek_fusion_SolverInfo._getdouinf(name)
      if key is None:
        raise NameError("Invalid double info name '%s'" % name)
      else:
        return self.__task.getdouinf(key)
  
    def _task_1get_1iinf_S(self,name):
      key = mosek_fusion_SolverInfo._getintinf(name)
      if key is None:
        raise NameError("Invalid integer info name '%s'" % name)
      else:
        return self.__task.getintinf(key)
  
    def _task_1get_1liinf_S(self,name):
      key = mosek_fusion_SolverInfo._getlintinf(name)
      if key is None:
        raise NameError("Invalid long integer info name '%s'" % name)
      else:
        return self.__task.getlintinf(key)
  
    def _numVariables_ (self):
      return len(self.__vars)
    def _numConstraints_ (self):
      return len(self.__cons)
  
    def _task_1format_1var_1names__3IS_3I_3J(self,subj,fmt,dims,sp):  self.__task.generatevarnames(subj,fmt,dims,sp)
    def _task_1format_1con_1names__3IS_3I_3J(self,subj,fmt,dims,sp):  self.__task.generateconnames(subj,fmt,dims,sp)
    def _task_1format_1cone_1names__3IS_3I_3J(self,subj,fmt,dims,sp): self.__task.generateconenames(subj,fmt,dims,sp)
  
    def _task_1con_1name_IS(self,idx,name):
      self.__task.putconname(idx,name)
    def _task_1var_1name_IS(self,idx, name):
      self.__task.putvarname(idx,name)
  
    def _task_1cone_1name_IS(self,idx,name):
      self.__task.putconename(idx,name)
  
    def _task_1numcon_(self):
      return self.__task.getnumcon()
    def _task_1numvar_(self):
      return self.__task.getnumvar()
    def _task_1numcone_(self):
      return self.__task.getnumcone()
  
    def __task_putvarboundlist(self,idxs,bl,bu,bk):
      num = len(idxs)
      if bl is None: bl = numpy.zeros(num,numpy.float64)
      if bu is None: bu = numpy.zeros(num,numpy.float64)
  
      bka = [bk] * num
      self.__task.putvarboundlist(idxs,bka,bl,bu)
  
    def __task_putconboundlist(self,idxs,bl,bu,bk):
      num = len(idxs)
      if bl is None: bl = numpy.zeros(num,numpy.float64)
      if bu is None: bu = numpy.zeros(num,numpy.float64)
  
      bka = [bk] * num
      self.__task.putconboundlist(idxs,bka,bl,bu)
  
    def _task_1con_1putboundlist_1fx__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.fx);
  
    def _task_1con_1putboundlist_1lo__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.lo);
  
    def _task_1con_1putboundlist_1up__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.up);
  
    def _task_1con_1putboundlist_1ra__3I_3D_3D(self,idxs, lb, ub):
      self.__task_putconboundlist( idxs, lb, ub, mosek.boundkey.ra);
  
    def _task_1con_1putboundlist_1fr__3I(self,idxs):
      self.__task_putconboundlist( idxs, None, None, mosek.boundkey.fr);
  
  
    def _task_1var_1putboundlist_1fx__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.fx);
  
    def _task_1var_1putboundlist_1lo__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.lo);
  
    def _task_1var_1putboundlist_1up__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.up);
  
    def _task_1var_1putboundlist_1ra__3I_3D_3D(self,idxs, lb, ub):
      self.__task_putvarboundlist( idxs, lb, ub, mosek.boundkey.ra);
  
    def _task_1var_1putboundlist_1fr__3I(self,idxs):
      self.__task_putvarboundlist( idxs, None, None, mosek.boundkey.fr);
  
    def _task_1var_1putintlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_int] * len(idxs))
    def _task_1var_1putcontlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_cont] * len(idxs))
  
  
    def _task_1task_1optimize_ (self):
      try:
        self.__task.optimize()
        self.__task.solutionsummary(streamtype.log)
      except mosek.Error as e:
        raise OptimizeError("Error occurred while optimizing")
  
    def __task_appendvars(self,num):
      idx = self.__task.getnumvar()
      self.__task.appendvars(num)
      return idx
  
    def __task_appendcons(self,num):
      idx = self.__task.getnumcon()
      self.__task.appendcons(num)
      return idx
  
    def _task_1append_1var_I(self,num):
      return self.__task_appendvars(num)
  
    def _task_1append_1con_I(self,num):
      return self.__task_appendcons(num)
  
    def _task_1append_1zerocones_I(self, numcone):
      self.__task.appendconesseq([mosek.conetype.zero for i in range(numcone)], numpy.zeros(numcone),numpy.zeros(numcone,int), 0)
    def _task_1clear_1cones__3I(self, idxs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.zero, 0.0, 0,[])
    def _task_1put_1zerocones__3III_3I(self, idxs, conesize, numcone, membs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.zero, 0.0, membs[i*conesize:(i+1)*conesize])
    def _task_1put_1quadcones__3III_3I(self, idxs, conesize, numcone, membs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.quad, 0.0, membs[i*conesize:(i+1)*conesize])
  
    def _task_1put_1rquadcones__3III_3I(self, idxs, conesize, numcone, membs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.rquad, 0.0, membs[i*conesize:(i+1)*conesize])
  
    def _task_1put_1pexpcones__3III_3I(self, idxs, conesize, numcone, membs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.pexp, 0.0, membs[i*conesize:(i+1)*conesize])
  
    def _task_1put_1ppowcones__3III_3I_3D(self, idxs, conesize, numcone, membs, alpha):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.ppow, alpha[i], membs[i*conesize:(i+1)*conesize])
  
    def _task_1put_1dexpcones__3III_3I(self, idxs, conesize, numcone, membs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.dexp, 0.0, membs[i*conesize:(i+1)*conesize])
  
    def _task_1put_1dpowcones__3III_3I_3D(self, idxs, conesize, numcone, membs, alpha):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.dpow, alpha[i], membs[i*conesize:(i+1)*conesize])
        
    def _task_1putarowlist__3I_3J_3I_3D(self,sub, ptrb, subj, cof):
      num   = len(sub)
      self.__task.putarowlist(sub, ptrb[:-1], ptrb[1:], subj, cof);
  
    def _task_1putaijlist__3I_3I_3DJ(self,subi,subj,cof,num):
      self.__task.putaijlist(subi[:num],subj[:num],cof[:num])
  
    def _task_1putobjectivename_S(self,name):
      self.__task.putobjname("" if name is None else name)
  
    def _task_1putobjective_Z_3I_3DD(self,maximize,subj,cof,cfix):
      c = numpy.zeros(self.__task.getnumvar(),numpy.float64)
      idxs = numpy.arange(0,len(c),dtype=numpy.int32)
      for i in range(len(subj)):
        c[subj[i]] += cof[i]
      self.__task.putclist(idxs,c)
      self.__task.putcfix(cfix)
      self.__task.putobjsense(mosek.objsense.maximize if maximize else mosek.objsense.minimize)
  
    def _task_1putclist__3I_3D(self,subj,cof):
      self.__task.putclist(subj,cof)
  
  
    def _task_1appendsymmatlist__3I_3J_3I_3I_3D(self,dim,nz,subi,subj,cof):
      r = numpy.zeros(len(dim),numpy.int64)
      self.__task.appendsparsesymmatlist(dim,nz,subi,subj,cof,r)
      return r
  
    def _task_1putbarc__3I_3I_3I_3D(self,subj,subk,subl,val):
      self.__task.putbarcblocktriplet(len(subj),subj,subk,subl,val)
    
    def _task_1putbaraijlist__3I_3I_3J(self,subi,subj,matidx):
      alpha = numpy.ones(len(subi),numpy.float64)
      ptr = numpy.arange(0,len(subi)+1,dtype=numpy.int64)
      self.__task.putbaraijlist(subi,subj,ptr[:-1],ptr[1:],matidx,alpha)
  
    def _task_1putbararowlist__3I_3J_3I_3J(self,subi,ptr,subj,matidx):
      alpha = numpy.ones(len(subj),numpy.float64)
      nummat = numpy.ones(len(subj),numpy.int64)
      self.__task.putbararowlist(subi,ptr[:-1],ptr[1:],subj,nummat,matidx,alpha)
  
    
    def _task_1barvardim_I(self,index):
      return self.__task.getdimbarvarj(index)
  
    def _task_1numbarvar_(self):
      return self.__task.getnumbarvar()
  
    def _task_1barvar_1name_IS(self, idx, name):
      self.__task.putbarvarname(idx,name)
  
    def _task_1append_1barvar_II(self,size, num):
      res = self.__task.getnumbarvar()
      self.__task.appendbarvars([size] * num)
      return res
  
    def _task_1setnumvar_I(self,num):
      numvar = self.__task.getnumvar()
      if numvar > num:
        self.__task.removevars(range(num,numvar))
  
  
    def _task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(self,whichsol,first,last,xx):
      if   whichsol == mosek_fusion_SolutionType.Interior:
        self.__task.putxxslice(mosek.soltype.itr, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Integer:
        self.__task.putxxslice(mosek.soltype.itg, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Basic:
        self.__task.putxxslice(mosek.soltype.bas, first,last,xx)
  
    def _task_1cleanup_IIII(self,inumvar,inumcon,inumcone,inumbarvar):
      numvar  = self.__task.getnumvar()
      numcon  = self.__task.getnumcon()
      numcone = self.__task.getnumcone()
      numbarvar = self.__task.getnumbarvar()
  
      if inumcone < numcone:
        self.__task.removecones(range(inumcone,numcone))
  
      if inumvar < numvar:
        n = numvar-inumvar
        vals = numpy.zeros((n,), numpy.float64)
        bk   = [ mosek.boundkey.fx for i in range(n) ]
        self.__task.putvarboundslice(inumvar,numvar,bk, vals, vals)
        #idxs = range(inumvar,numvar)
        #self.__task.removevars(idxs)
  
      if (inumcon < numcon):
        idxs = range(inumcon,numcon)
        self.__task.removecons(idxs)
  
      if (inumbarvar < numbarvar):
        self.__task.removebarvars(range(inumbarvar,numbarvar))
  
    @staticmethod
    def __convertSolutionStatus(soltype,sol,status,prosta):
      pd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
      }
  
      dd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.Unknown,
      }
  
      psd = {
          mosek.prosta.unknown  :                   mosek_fusion_ProblemStatus.Unknown,
          mosek.prosta.prim_and_dual_feas :         mosek_fusion_ProblemStatus.PrimalAndDualFeasible,
          mosek.prosta.prim_feas :                  mosek_fusion_ProblemStatus.PrimalFeasible,
          mosek.prosta.dual_feas :                  mosek_fusion_ProblemStatus.DualFeasible,
          mosek.prosta.prim_infeas :                mosek_fusion_ProblemStatus.PrimalInfeasible,
          mosek.prosta.dual_infeas :                mosek_fusion_ProblemStatus.DualInfeasible,
          mosek.prosta.prim_and_dual_infeas :       mosek_fusion_ProblemStatus.PrimalAndDualInfeasible,
          mosek.prosta.ill_posed :                  mosek_fusion_ProblemStatus.IllPosed,
          mosek.prosta.prim_infeas_or_unbounded :   mosek_fusion_ProblemStatus.PrimalInfeasibleOrUnbounded,
        }
  
      try: sol.pstatus = pd[status]
      except KeyError: sol.pstatus = mosek_fusion_SolutionStatus.Unknown
  
      try: sol.dstatus = dd[status]
      except KeyError: sol.dstatus = mosek_fusion_SolutionStatus.Unknown
  
      try: sol.probstatus = psd[prosta]
      except KeyError: sol.probstatus = mosek_fusion_SolutionStatus.Unknown
  
  
    @staticmethod
    def _matchargs_task_1write_S(self,*args):
        return True
    def _task_1write_S(self,filename):
        self.__task.putintparam(mosek.iparam.opf_write_solutions, 1)
        self.__task.putintparam(mosek.iparam.write_ignore_incompatible_items, 1)
        self.__task.writedata(filename)
  
    def _task_1write(self,filename):
      return self._writeProblem_S(filename)
  
    def _task_1get_(self):
      return self.__task
  
    def _task_1break_1solve_(self):
      self.__break = True
  
    @staticmethod
    def _matchargs_task_1solve_(self,*args):
      return True
    def _task_1solve_(self):
      task = self.__task
      ok = False
      try:
        trmcode = mosek.rescode.ok
        try:
          self.__break = False
          trmcode = task.optimize()
          task.solutionsummary(mosek.streamtype.log)
        except mosek.Error as e:
          raise mosek_fusion_OptimizeError(e.msg)
  
        numcon  = task.getnumcon()
        numvar  = task.getnumvar()
        numcone = task.getnumcone()
        numbarvar = task.getnumbarvar()
        barvarveclen = 0
        for j in range(numbarvar):
          barxjdim = task.getdimbarvarj(j)
          barvarveclen += barxjdim * (1+barxjdim)/2
        barvarveclen = numpy.int32(barvarveclen)
  
        sol_bas_def = 0 != task.solutiondef(mosek.soltype.bas)
        sol_itr_def = 0 != task.solutiondef(mosek.soltype.itr)
        sol_itg_def = 0 != task.solutiondef(mosek.soltype.itg)
  
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None
  
        if sol_itr_def:
          self._sol_itr = mosek_fusion_SolutionStruct(numvar,numcon,numcone,barvarveclen)
          sol_itr = self._sol_itr
          prosta,solsta = task.getsolution(
            mosek.soltype.itr,
            #sol_itr.skc,sol_itr.skx,sol_itr.skn,
            None,None,None,
            sol_itr.xc,sol_itr.xx,sol_itr.y,
            sol_itr.slc,sol_itr.suc,
            sol_itr.slx,sol_itr.sux,
            sol_itr.snx)
  
          if (numvar > 0):
            if sol_itr.snx is not None:
              sol_itr.yx[:] = sol_itr.slx - sol_itr.sux + sol_itr.snx
            else:
              sol_itr.yx[:] = sol_itr.slx - sol_itr.sux
  
          if barvarveclen > 0:
            task.getbarxslice(mosek.soltype.itr, 0, numbarvar, barvarveclen, self._sol_itr.barx)
            task.getbarsslice(mosek.soltype.itr, 0, numbarvar, barvarveclen, self._sol_itr.bars)
  
          sol_itr.pobj = task.getprimalobj(mosek.soltype.itr)
          sol_itr.dobj = task.getdualobj  (mosek.soltype.itr)
          self.__convertSolutionStatus(mosek.soltype.itr, sol_itr, solsta,prosta);
          #print "got itr sol, stat = %s/%s" % (sol_itr.pstatus,sol_itr.dstatus)
  
        if sol_bas_def:
          self._sol_bas = mosek_fusion_SolutionStruct(numvar,numcon,numcone,barvarveclen);
          sol_bas = self._sol_bas
          prosta,solsta = task.getsolution(
            mosek.soltype.bas,
            #sol_bas.skc,sol_bas.skx,sol_bas.skn,
            None,None,None,
            sol_bas.xc,sol_bas.xx,sol_bas.y,
            sol_bas.slc,sol_bas.suc,
            sol_bas.slx,sol_bas.sux,
            sol_bas.snx)
  
          if (numvar > 0):
            sol_bas.yx[:] = sol_bas.slx - sol_bas.sux
  
          # NOTE: this probably never happens:
          if numbarvar > 0:
            task.getbarxslice(mosek.soltype.bas, 0, numbarvar, barvarveclen, self._sol_bas.barx)
            task.getbarsslice(mosek.soltype.bas, 0, numbarvar, barvarveclen, self._sol_bas.bars)
  
          sol_bas.pobj = task.getprimalobj(mosek.soltype.bas)
          sol_bas.dobj = task.getdualobj  (mosek.soltype.bas)
          self.__convertSolutionStatus(mosek.soltype.bas, sol_bas, solsta,prosta);
  
          #print "got bas sol, stat = %s/%s" % (sol_bas.pstatus,sol_bas.dstatus)
  
        if sol_itg_def:
          self._sol_itg = mosek_fusion_SolutionStruct(numvar,numcon,numcone,barvarveclen);
          sol_itg = self._sol_itg
          prosta,solsta = task.getsolution(
            mosek.soltype.itg,
            #sol_itg.skc,sol_itg.skx,sol_itg.skn,
            None,None,None,
            sol_itg.xc,sol_itg.xx,sol_itg.y,
            sol_itg.slc,sol_itg.suc,
            sol_itg.slx,sol_itg.sux,
            sol_itg.snx)
  
          # NOTE: this probably wont happen for a long time:
          if barvarveclen > 0:
            task.getbarxslice(mosek.soltype.itg, 0, numbarvar, barvarveclen, self._sol_itg.barx)
            task.getbarsslice(mosek.soltype.itg, 0, numbarvar, barvarveclen, self._sol_itg.bars)
  
          sol_itg.pobj = task.getprimalobj(mosek.soltype.itg)
          self.__convertSolutionStatus(mosek.soltype.itg, sol_itg, solsta,prosta);
        ok = True
  
      finally:
        if not ok: # means exception
          self._sol_itr = None
          self._sol_bas = None
          self._sol_itg = None
  
    @staticmethod
    def _env_1syeig_I_3D_3D(n,a,w): BaseModel._globalEnv().syeig(n,a,w)
    @staticmethod
    def _env_1syevd_I_3D_3D(n,a,w): BaseModel._globalEnv().syevd(n,a,w)
    #@staticmethod
    #def _env_1potrf_I_3D(n,a):      BaseModel._globalEnv().potrf(n,a)
  
  return BaseModel
mosek_fusion_BaseModel=__mk_mosek_fusion_BaseModel()
#BEFORE CLASS
def __mk_mosek_fusion_Model():
 class Model(mosek_fusion_BaseModel):
  __slots__ = ['_Model__xs','_Model__ws','_Model__rs','_Model__con_map','_Model__cons','_Model__natconmap_type','_Model__natconmap_ub','_Model__natconmap_lb','_Model__natconmap_efix','_Model__natconmap_idx','_Model__natconmap_slackidx','_Model__natconmap_blockid','_Model__natconmap','_Model__initsol_xx_flag','_Model__initsol_xx','_Model__var_map','_Model__barvars','_Model__natbarvarmap_ptr','_Model__natbarvarmap_num','_Model__natbarvarmap_nblock','_Model__natbarvar_dim','_Model__natbarvar_ptr','_Model__natbarvar_numbarvarelm','_Model__natbarvar_j','_Model__natbarvar_i','_Model__natbarvar_idx','_Model__natvarmap_type','_Model__natconemap_dim','_Model__natconemap','_Model__vars','_Model__bfixidx','_Model__natvarmap_idx','_Model__natvarmap_blockid','_Model__natvarmap','_Model__solutionptr','_Model__acceptable_sol','_Model__model_name']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Model.ctor()\n\tmosek.fusion.Model.ctor(string)')
  def getTask(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getTask_(*args): # 
      return self._getTask_(*args)
    elif mosek_fusion_Model._match_alt_getTask_(*args): # 
      return self._getTask_alt_(*args)
    else:
      raise ValueError('Invalid argument list getTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getTask()')
  def setDataCallbackHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args): # System.DataCallbackHandler
      return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args): # System.DataCallbackHandler
      return self._setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setDataCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setDataCallbackHandler(System.DataCallbackHandler)')
  @staticmethod
  def putlicensewait(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensewait_Z(*args): # bool
      return mosek_fusion_Model._putlicensewait_Z(*args)
    elif mosek_fusion_Model._match_alt_putlicensewait_Z(*args): # bool
      return mosek_fusion_Model._putlicensewait_alt_Z(*args)
    else:
      raise ValueError('Invalid argument list putlicensewait('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensewait(bool)')
  def getDualSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getDualSolutionStatus_(*args): # 
      return self._getDualSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_(*args): # 
      return self._getDualSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getDualSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getDualSolutionStatus()\n\tmosek.fusion.Model.getDualSolutionStatus(mosek.fusion.SolutionType)')
  def solve(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_solve_(*args): # 
      return self._solve_(*args)
    elif mosek_fusion_Model._match_alt_solve_(*args): # 
      return self._solve_alt_(*args)
    else:
      raise ValueError('Invalid argument list solve('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.solve()')
  def setLogHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setLogHandler_LSystem_4StreamWriter_2(*args): # System.StreamWriter
      return self._setLogHandler_LSystem_4StreamWriter_2(*args)
    elif mosek_fusion_Model._match_alt_setLogHandler_LSystem_4StreamWriter_2(*args): # System.StreamWriter
      return self._setLogHandler_alt_LSystem_4StreamWriter_2(*args)
    else:
      raise ValueError('Invalid argument list setLogHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setLogHandler(System.StreamWriter)')
  def getSolverLIntInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverLIntInfo_S(*args): # string
      return self._getSolverLIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverLIntInfo_S(*args): # string
      return self._getSolverLIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverLIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverLIntInfo(string)')
  def primalObjValue(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_primalObjValue_(*args): # 
      return self._primalObjValue_(*args)
    elif mosek_fusion_Model._match_alt_primalObjValue_(*args): # 
      return self._primalObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list primalObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.primalObjValue()')
  def hasVariable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasVariable_S(*args): # string
      return self._hasVariable_S(*args)
    elif mosek_fusion_Model._match_alt_hasVariable_S(*args): # string
      return self._hasVariable_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasVariable(string)')
  def hasConstraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasConstraint_S(*args): # string
      return self._hasConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_hasConstraint_S(*args): # string
      return self._hasConstraint_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasConstraint(string)')
  def variable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_variable_(*args): # 
      return self._variable_(*args)
    elif mosek_fusion_Model._match_alt_variable_(*args): # 
      return self._variable_alt_(*args)
    elif mosek_fusion_Model._match_variable_S(*args): # string
      return self._variable_S(*args)
    elif mosek_fusion_Model._match_alt_variable_S(*args): # string
      return self._variable_alt_S(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.LinPSDDomain
      return self._variable_Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.LinPSDDomain
      return self._variable_alt_Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return self._variable_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return self._variable_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_I(*args): # int32
      return self._variable_I(*args)
    elif mosek_fusion_Model._match_alt_variable_I(*args): # int32
      return self._variable_alt_I(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return self._variable_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return self._variable_alt_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3I(*args): # []int32
      return self._variable__3I(*args)
    elif mosek_fusion_Model._match_alt_variable__3I(*args): # []int32
      return self._variable_alt__3I(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.PSDDomain
      return self._variable_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.PSDDomain
      return self._variable_alt_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return self._variable_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return self._variable_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4RangeDomain_2(*args): # []int32,mosek.fusion.RangeDomain
      return self._variable__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args): # []int32,mosek.fusion.RangeDomain
      return self._variable_alt__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3I(*args): # string,[]int32
      return self._variable_S_3I(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3I(*args): # string,[]int32
      return self._variable_alt_S_3I(*args)
    elif mosek_fusion_Model._match_variable_SI(*args): # string,int32
      return self._variable_SI(*args)
    elif mosek_fusion_Model._match_alt_variable_SI(*args): # string,int32
      return self._variable_alt_SI(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4LinearDomain_2(*args): # []int32,mosek.fusion.LinearDomain
      return self._variable__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args): # []int32,mosek.fusion.LinearDomain
      return self._variable_alt__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4LinPSDDomain_2(*args): # int32,mosek.fusion.LinPSDDomain
      return self._variable_ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4LinPSDDomain_2(*args): # int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4ConeDomain_2(*args): # []int32,mosek.fusion.ConeDomain
      return self._variable__3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4ConeDomain_2(*args): # []int32,mosek.fusion.ConeDomain
      return self._variable_alt__3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4RangeDomain_2(*args): # int32,mosek.fusion.RangeDomain
      return self._variable_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args): # int32,mosek.fusion.RangeDomain
      return self._variable_alt_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4PSDDomain_2(*args): # int32,mosek.fusion.PSDDomain
      return self._variable_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args): # int32,mosek.fusion.PSDDomain
      return self._variable_alt_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.LinPSDDomain
      return self._variable_SLmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.LinPSDDomain
      return self._variable_alt_SLmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.PSDDomain
      return self._variable_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.PSDDomain
      return self._variable_alt_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.ConeDomain
      return self._variable_SLmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.ConeDomain
      return self._variable_alt_SLmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.RangeDomain
      return self._variable_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.RangeDomain
      return self._variable_alt_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4LinearDomain_2(*args): # int32,mosek.fusion.LinearDomain
      return self._variable_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args): # int32,mosek.fusion.LinearDomain
      return self._variable_alt_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4ConeDomain_2(*args): # int32,mosek.fusion.ConeDomain
      return self._variable_ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4ConeDomain_2(*args): # int32,mosek.fusion.ConeDomain
      return self._variable_alt_ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.LinearDomain
      return self._variable_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.LinearDomain
      return self._variable_alt_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args): # string,[]int32,mosek.fusion.ConeDomain
      return self._variable_S_3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args): # string,[]int32,mosek.fusion.ConeDomain
      return self._variable_alt_S_3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args): # string,[]int32,mosek.fusion.PSDDomain
      return self._variable_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args): # string,[]int32,mosek.fusion.PSDDomain
      return self._variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args): # string,[]int32,mosek.fusion.RangeDomain
      return self._variable_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args): # string,[]int32,mosek.fusion.RangeDomain
      return self._variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4RangeDomain_2(*args): # string,int32,mosek.fusion.RangeDomain
      return self._variable_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args): # string,int32,mosek.fusion.RangeDomain
      return self._variable_alt_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args): # string,[]int32,mosek.fusion.LinearDomain
      return self._variable_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args): # string,[]int32,mosek.fusion.LinearDomain
      return self._variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_IILmosek_4fusion_4PSDDomain_2(*args): # int32,int32,mosek.fusion.PSDDomain
      return self._variable_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args): # int32,int32,mosek.fusion.PSDDomain
      return self._variable_alt_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4PSDDomain_2(*args): # string,int32,mosek.fusion.PSDDomain
      return self._variable_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args): # string,int32,mosek.fusion.PSDDomain
      return self._variable_alt_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4LinearDomain_2(*args): # string,int32,mosek.fusion.LinearDomain
      return self._variable_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args): # string,int32,mosek.fusion.LinearDomain
      return self._variable_alt_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args): # string,[]int32,mosek.fusion.LinPSDDomain
      return self._variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args): # string,[]int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_S_3ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4ConeDomain_2(*args): # string,int32,mosek.fusion.ConeDomain
      return self._variable_SILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4ConeDomain_2(*args): # string,int32,mosek.fusion.ConeDomain
      return self._variable_alt_SILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,mosek.fusion.LinPSDDomain
      return self._variable_SILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_SILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_IILmosek_4fusion_4LinPSDDomain_2(*args): # int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_IILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_IILmosek_4fusion_4LinPSDDomain_2(*args): # int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_IILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_SIILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_SIILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SIILmosek_4fusion_4PSDDomain_2(*args): # string,int32,int32,mosek.fusion.PSDDomain
      return self._variable_SIILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args): # string,int32,int32,mosek.fusion.PSDDomain
      return self._variable_alt_SIILmosek_4fusion_4PSDDomain_2(*args)
    else:
      raise ValueError('Invalid argument list variable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.variable()\n\tmosek.fusion.Model.variable(string)\n\tmosek.fusion.Model.variable(mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32)\n\tmosek.fusion.Model.variable(mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1))\n\tmosek.fusion.Model.variable(mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1))\n\tmosek.fusion.Model.variable(string,int32)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(int32,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,int32,mosek.fusion.PSDDomain)')
  def getVariable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariable_S(*args): # string
      return self._getVariable_S(*args)
    elif mosek_fusion_Model._match_alt_getVariable_S(*args): # string
      return self._getVariable_alt_S(*args)
    elif mosek_fusion_Model._match_getVariable_I(*args): # int32
      return self._getVariable_I(*args)
    elif mosek_fusion_Model._match_alt_getVariable_I(*args): # int32
      return self._getVariable_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariable(string)\n\tmosek.fusion.Model.getVariable(int32)')
  def getConstraintValues(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getConstraintValues_Z_3I_3DI(*args): # bool,[]int32,[]double,int32
      return self._getConstraintValues_Z_3I_3DI(*args)
    elif mosek_fusion_Model._match_alt_getConstraintValues_Z_3I_3DI(*args): # bool,[]int32,[]double,int32
      return self._getConstraintValues_alt_Z_3I_3DI(*args)
    else:
      raise ValueError('Invalid argument list getConstraintValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraintValues(bool,array(int32,ndim=1),array(double,ndim=1),int32)')
  def getConstraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getConstraint_S(*args): # string
      return self._getConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_S(*args): # string
      return self._getConstraint_alt_S(*args)
    elif mosek_fusion_Model._match_getConstraint_I(*args): # int32
      return self._getConstraint_I(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_I(*args): # int32
      return self._getConstraint_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraint(string)\n\tmosek.fusion.Model.getConstraint(int32)')
  def setSolverParam(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setSolverParam_SS(*args): # string,string
      return self._setSolverParam_SS(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SS(*args): # string,string
      return self._setSolverParam_alt_SS(*args)
    elif mosek_fusion_Model._match_setSolverParam_SI(*args): # string,int32
      return self._setSolverParam_SI(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SI(*args): # string,int32
      return self._setSolverParam_alt_SI(*args)
    elif mosek_fusion_Model._match_setSolverParam_SD(*args): # string,double
      return self._setSolverParam_SD(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SD(*args): # string,double
      return self._setSolverParam_alt_SD(*args)
    else:
      raise ValueError('Invalid argument list setSolverParam('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setSolverParam(string,string)\n\tmosek.fusion.Model.setSolverParam(string,int32)\n\tmosek.fusion.Model.setSolverParam(string,double)')
  def dispose(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_dispose_(*args): # 
      return self._dispose_(*args)
    elif mosek_fusion_Model._match_alt_dispose_(*args): # 
      return self._dispose_alt_(*args)
    else:
      raise ValueError('Invalid argument list dispose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dispose()')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_clone_(*args): # 
      return self._clone_(*args)
    elif mosek_fusion_Model._match_alt_clone_(*args): # 
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.clone()')
  def getVariableValues(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariableValues_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableValues_Z_3J_3DI(*args)
    elif mosek_fusion_Model._match_alt_getVariableValues_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableValues_alt_Z_3J_3DI(*args)
    else:
      raise ValueError('Invalid argument list getVariableValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariableValues(bool,array(int64,ndim=1),array(double,ndim=1),int32)')
  def flushSolutions(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushSolutions_(*args): # 
      return self._flushSolutions_(*args)
    elif mosek_fusion_Model._match_alt_flushSolutions_(*args): # 
      return self._flushSolutions_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushSolutions('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushSolutions()')
  @staticmethod
  def putlicensecode(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensecode__3I(*args): # []int32
      return mosek_fusion_Model._putlicensecode__3I(*args)
    elif mosek_fusion_Model._match_alt_putlicensecode__3I(*args): # []int32
      return mosek_fusion_Model._putlicensecode_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list putlicensecode('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensecode(array(int32,ndim=1))')
  def objective(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_objective_D(*args): # double
      return self._objective_D(*args)
    elif mosek_fusion_Model._match_alt_objective_D(*args): # double
      return self._objective_alt_D(*args)
    elif mosek_fusion_Model._match_objective_SD(*args): # string,double
      return self._objective_SD(*args)
    elif mosek_fusion_Model._match_alt_objective_SD(*args): # string,double
      return self._objective_alt_SD(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args): # mosek.fusion.ObjectiveSense,double
      return self._objective_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args): # mosek.fusion.ObjectiveSense,double
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args): # string,mosek.fusion.ObjectiveSense,double
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args): # string,mosek.fusion.ObjectiveSense,double
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list objective('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.objective(double)\n\tmosek.fusion.Model.objective(string,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,double)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)')
  def getPrimalSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_(*args): # 
      return self._getPrimalSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_(*args): # 
      return self._getPrimalSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getPrimalSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getPrimalSolutionStatus()\n\tmosek.fusion.Model.getPrimalSolutionStatus(mosek.fusion.SolutionType)')
  def getVariableDuals(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariableDuals_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableDuals_Z_3J_3DI(*args)
    elif mosek_fusion_Model._match_alt_getVariableDuals_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableDuals_alt_Z_3J_3DI(*args)
    else:
      raise ValueError('Invalid argument list getVariableDuals('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariableDuals(bool,array(int64,ndim=1),array(double,ndim=1),int32)')
  def getProblemStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getProblemStatus_(*args): # 
      return self._getProblemStatus_(*args)
    elif mosek_fusion_Model._match_alt_getProblemStatus_(*args): # 
      return self._getProblemStatus_alt_(*args)
    elif mosek_fusion_Model._match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getProblemStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getProblemStatus()\n\tmosek.fusion.Model.getProblemStatus(mosek.fusion.SolutionType)')
  def getName(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getName_(*args): # 
      return self._getName_(*args)
    elif mosek_fusion_Model._match_alt_getName_(*args): # 
      return self._getName_alt_(*args)
    else:
      raise ValueError('Invalid argument list getName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getName()')
  def dualObjValue(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_dualObjValue_(*args): # 
      return self._dualObjValue_(*args)
    elif mosek_fusion_Model._match_alt_dualObjValue_(*args): # 
      return self._dualObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list dualObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dualObjValue()')
  def updateObjective(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_alt_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._updateObjective_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list updateObjective('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.updateObjective(mosek.fusion.Expression,mosek.fusion.Variable)')
  def setVariableValues(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setVariableValues_Z_3J_3D(*args): # bool,[]int64,[]double
      return self._setVariableValues_Z_3J_3D(*args)
    elif mosek_fusion_Model._match_alt_setVariableValues_Z_3J_3D(*args): # bool,[]int64,[]double
      return self._setVariableValues_alt_Z_3J_3D(*args)
    else:
      raise ValueError('Invalid argument list setVariableValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setVariableValues(bool,array(int64,ndim=1),array(double,ndim=1))')
  def writeTask(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_writeTask_S(*args): # string
      return self._writeTask_S(*args)
    elif mosek_fusion_Model._match_alt_writeTask_S(*args): # string
      return self._writeTask_alt_S(*args)
    else:
      raise ValueError('Invalid argument list writeTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTask(string)')
  def constraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list constraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.RangeDomain)')
  def flushNames(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushNames_(*args): # 
      return self._flushNames_(*args)
    elif mosek_fusion_Model._match_alt_flushNames_(*args): # 
      return self._flushNames_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushNames('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushNames()')
  def getSolverIntInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverIntInfo_S(*args): # string
      return self._getSolverIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverIntInfo_S(*args): # string
      return self._getSolverIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverIntInfo(string)')
  def getSolverDoubleInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverDoubleInfo_S(*args): # string
      return self._getSolverDoubleInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverDoubleInfo_S(*args): # string
      return self._getSolverDoubleInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverDoubleInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverDoubleInfo(string)')
  @staticmethod
  def getVersion(*args):
    if False: pass
    elif mosek_fusion_Model._match_getVersion_(*args): # 
      return mosek_fusion_Model._getVersion_(*args)
    elif mosek_fusion_Model._match_alt_getVersion_(*args): # 
      return mosek_fusion_Model._getVersion_alt_(*args)
    else:
      raise ValueError('Invalid argument list getVersion('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVersion()')
  def acceptedSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_Model._match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list acceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.acceptedSolutionStatus(mosek.fusion.AccSolutionStatus)')
  def setCallbackHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setCallbackHandler_LSystem_4CallbackHandler_2(*args): # System.CallbackHandler
      return self._setCallbackHandler_LSystem_4CallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args): # System.CallbackHandler
      return self._setCallbackHandler_alt_LSystem_4CallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setCallbackHandler(System.CallbackHandler)')
  def selectedSolution(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._selectedSolution_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._selectedSolution_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list selectedSolution('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.selectedSolution(mosek.fusion.SolutionType)')
  def breakSolver(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_breakSolver_(*args): # 
      return self._breakSolver_(*args)
    elif mosek_fusion_Model._match_alt_breakSolver_(*args): # 
      return self._breakSolver_alt_(*args)
    else:
      raise ValueError('Invalid argument list breakSolver('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.breakSolver()')
  @staticmethod
  def putlicensepath(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensepath_S(*args): # string
      return mosek_fusion_Model._putlicensepath_S(*args)
    elif mosek_fusion_Model._match_alt_putlicensepath_S(*args): # string
      return mosek_fusion_Model._putlicensepath_alt_S(*args)
    else:
      raise ValueError('Invalid argument list putlicensepath('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensepath(string)')
  def getAcceptedSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getAcceptedSolutionStatus_(*args): # 
      return self._getAcceptedSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getAcceptedSolutionStatus_(*args): # 
      return self._getAcceptedSolutionStatus_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAcceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getAcceptedSolutionStatus()')
  def __repr__(self): return 'mosek.fusion.Model'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2(m):
    o = Model.__new__(Model)
    o._ctor_init_Lmosek_4fusion_4Model_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Model_2(m)
  def _ctor_init_Lmosek_4fusion_4Model_2(self,m):
   mosek_fusion_BaseModel._ctor_init_Lmosek_4fusion_4BaseModel_2(self,m)
   _0=self
   self.__model_name = (m.__model_name)
   self.__acceptable_sol = (m.__acceptable_sol)
   self.__solutionptr = (m.__solutionptr)
   self.__natvarmap_blockid = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natvarmap_blockid))
   self.__natvarmap_idx = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natvarmap_idx))
   self.__natvarmap_type = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natvarmap_type))
   self.__natvarmap = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__natvarmap))
   self.__vars = numpy.array([((m.__vars)[_1]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__vars)[_1] is not None) ) else None) for _1 in range(0,int(((m.__vars)).shape[0]))], dtype=numpy.dtype(object))
   self.__natconemap = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__natconemap))
   self.__natconemap_dim = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconemap_dim))
   self.__natbarvar_numbarvarelm = (m.__natbarvar_numbarvarelm)
   self.__natbarvar_ptr = mosek.fusion.Utils.Tools._arraycopy__3J((m.__natbarvar_ptr))
   self.__natbarvar_i = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvar_i))
   self.__natbarvar_j = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvar_j))
   self.__natbarvar_idx = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvar_idx))
   self.__natbarvarmap_nblock = (m.__natbarvarmap_nblock)
   self.__natbarvar_dim = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvar_dim))
   self.__natbarvarmap_num = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvarmap_num))
   self.__natbarvarmap_ptr = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvarmap_ptr))
   self.__barvars = numpy.array([((m.__barvars)[_2]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__barvars)[_2] is not None) ) else None) for _2 in range(0,int(((m.__barvars)).shape[0]))], dtype=numpy.dtype(object))
   self.__var_map = (m.__var_map)._clone_()
   self.__natconmap_blockid = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_blockid))
   self.__natconmap_slackidx = mosek.fusion.Utils.Tools._arraycopy__3J((m.__natconmap_slackidx))
   self.__natconmap_idx = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_idx))
   self.__natconmap_type = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_type))
   self.__natconmap_efix = mosek.fusion.Utils.Tools._arraycopy__3D((m.__natconmap_efix))
   self.__natconmap_lb = mosek.fusion.Utils.Tools._arraycopy__3D((m.__natconmap_lb))
   self.__natconmap_ub = mosek.fusion.Utils.Tools._arraycopy__3D((m.__natconmap_ub))
   self.__natconmap = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__natconmap))
   self.__cons = numpy.array([((m.__cons)[_3]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__cons)[_3] is not None) ) else None) for _3 in range(0,int(((m.__cons)).shape[0]))], dtype=numpy.dtype(object))
   self.__con_map = (m.__con_map)._clone_()
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self.__bfixidx = (m.__bfixidx)
   self.__rs = mosek_fusion_WorkStack._ctor_()
   self.__ws = mosek_fusion_WorkStack._ctor_()
   self.__xs = mosek_fusion_WorkStack._ctor_()
  @staticmethod
  def _ctor_S(name):
    o = Model.__new__(Model)
    o._ctor_init_S(name)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_match_S__(name))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_alt_match_S__(name))
  def _ctor_alt_init_S(self,name):
    self._ctor_init_S(name)
  def _ctor_init_S(self,name):
   mosek_fusion_BaseModel._ctor_init_SS(self,name,"")
   self.__model_name = name
   self.__acceptable_sol = mosek.fusion.AccSolutionStatus.Optimal
   self.__solutionptr = mosek.fusion.SolutionType.Default
   self.__natvarmap = mosek_fusion_LinkedBlocks._ctor_()
   self.__natvarmap_blockid = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap_idx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap_type = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__vars = numpy.array([None for _0 in range(0,1024)], dtype=numpy.dtype(object))
   self.__natconemap = mosek_fusion_LinkedBlocks._ctor_()
   self.__natconemap_dim = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__barvars = numpy.zeros((0,), dtype=numpy.dtype(object))
   self.__natbarvar_ptr = numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   self.__natbarvar_numbarvarelm = 0
   self.__natbarvar_i = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvar_j = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvar_idx = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_nblock = 0
   self.__natbarvar_dim = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_num = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_ptr = numpy.array([0], dtype=numpy.dtype(numpy.int32))
   self.__barvars = numpy.zeros((0,), dtype=numpy.dtype(object))
   self.__var_map = mosek.fusion.Utils.StringIntMap()
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self.__natconmap = mosek_fusion_LinkedBlocks._ctor_()
   self.__natconmap_blockid = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap_slackidx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int64))
   self.__natconmap_idx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap_type = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap_efix = numpy.zeros((1024,), dtype=numpy.dtype(numpy.float64))
   self.__natconmap_lb = numpy.zeros((1024,), dtype=numpy.dtype(numpy.float64))
   self.__natconmap_ub = numpy.zeros((1024,), dtype=numpy.dtype(numpy.float64))
   self.__cons = numpy.array([None for _1 in range(0,1024)], dtype=numpy.dtype(object))
   self.__con_map = mosek.fusion.Utils.StringIntMap()
   self.__bfixidx = self.__natvarmap_1alloc_I(1)
   self._task_1var_1putboundlist_1fx__3I_3D(numpy.array([self.__bfixidx], dtype=numpy.dtype(numpy.int32)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)))
   self._task_1var_1name_IS(self.__bfixidx,"1.0")
   self.__rs = mosek_fusion_WorkStack._ctor_()
   self.__ws = mosek_fusion_WorkStack._ctor_()
   self.__xs = mosek_fusion_WorkStack._ctor_()
  @staticmethod
  def _ctor_():
    o = Model.__new__(Model)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_Model._ctor_init_S(self,"")
  def _formstConstr_alt_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._formstConstr_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _formstConstr_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (_0)
  def _connames_alt__3IS_3I_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self._connames__3IS_3I_3J(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _connames__3IS_3I_3J(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   self._task_1format_1con_1names__3IS_3I_3J(_0,_1,_2,_3)
  def _varnames_alt__3IS_3I_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self._varnames__3IS_3I_3J(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _varnames__3IS_3I_3J(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   self._task_1format_1var_1names__3IS_3I_3J(_0,_1,_2,_3)
  def _varname_alt_IS(self,_t__0,_t__1):
    return self._varname_IS(numpy.int32(__0),_1)
  def _varname_IS(self,_0,_1):
   self._task_1var_1name_IS(_0,_1)
  def __natbarvarmap_1get_alt_I_3I(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self.__natbarvarmap_1get_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __natbarvarmap_1get_I_3I(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=self.__natbarvarmap_ptr[_0]
   _3=self.__natbarvarmap_num[_0]
   for _4 in range(0,_3):
    _1[_4] = (_2 + _4)
  def __natbarvar_1get_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self.__natbarvar_1get_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __natbarvar_1get_I_3J(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=self.__natbarvarmap_ptr[_0]
   _3=self.__natbarvarmap_num[_0]
   _4=self.__natbarvar_dim[self.__natbarvarmap_ptr[_0]]
   _5=(((_3 * _4) * (_4 + 1)) // 2)
   _6=self.__natbarvar_ptr[_2]
   for _7 in range(0,_5):
    _1[_7] = (_6 + _7)
  def __natbarvarmap_1alloc_alt_II(self,_t__0,_t__1):
    return self.__natbarvarmap_1alloc_II(numpy.int32(__0),numpy.int32(__1))
  def __natbarvarmap_1alloc_II(self,_0,_1):
   _2=int((self.__natbarvar_idx).shape[0])
   _3=self._task_1numbarvar_()
   _4=((_1 * (_1 + 1)) // 2)
   _5=(_0 * _4)
   if ((self.__natbarvar_numbarvarelm + _5) >= _2): # src/fusion/Model.mbi:3304:12-56
    if (_5 < _2): # src/fusion/Model.mbi:3305:14-32
     _5 = _2
    self.__natbarvar_idx = mosek.fusion.CommonTools._resize__3II(self.__natbarvar_idx,(_2 + _5))
    self.__natbarvar_i = mosek.fusion.CommonTools._resize__3II(self.__natbarvar_i,(_2 + _5))
    self.__natbarvar_j = mosek.fusion.CommonTools._resize__3II(self.__natbarvar_j,(_2 + _5))
   if ((self.__natbarvarmap_nblock + 1) >= int((self.__natbarvarmap_num).shape[0])): # src/fusion/Model.mbi:3312:12-60
    _6=((int((self.__natbarvarmap_num).shape[0]) * 2) if ((int((self.__natbarvarmap_num).shape[0]) > 0) ) else 32)
    self.__natbarvarmap_num = mosek.fusion.CommonTools._resize__3II(self.__natbarvarmap_num,_6)
    self.__natbarvarmap_ptr = mosek.fusion.CommonTools._resize__3II(self.__natbarvarmap_ptr,(_6 + 1))
    _7=numpy.ndarray((_6,), dtype=numpy.dtype(object))
    for _8 in range(0,int((self.__barvars).shape[0])):
     _7[_8] = self.__barvars[_8]
    self.__barvars = _7
   if ((_3 + _0) > int((self.__natbarvar_dim).shape[0])): # src/fusion/Model.mbi:3321:12-44
    _9=((int((self.__natbarvar_dim).shape[0]) * 2) if (((_3 + _0) < (int((self.__natbarvar_dim).shape[0]) * 2)) ) else (_3 + _0))
    self.__natbarvar_dim = mosek.fusion.CommonTools._resize__3II(self.__natbarvar_dim,_9)
   if ((_3 + _0) >= int((self.__natbarvar_ptr).shape[0])): # src/fusion/Model.mbi:3325:12-45
    _10=(_0 if ((_0 > int((self.__natbarvar_ptr).shape[0])) ) else int((self.__natbarvar_ptr).shape[0]))
    self.__natbarvar_ptr = mosek.fusion.CommonTools._resize__3JI(self.__natbarvar_ptr,((int((self.__natbarvar_ptr).shape[0]) + _10) + 1))
   for _11 in range(0,_0):
    self.__natbarvar_dim[(_3 + _11)] = _1
   self.__natbarvarmap_num[self.__natbarvarmap_nblock] = _0
   self.__natbarvarmap_ptr[(self.__natbarvarmap_nblock + 1)] = (self.__natbarvarmap_ptr[self.__natbarvarmap_nblock] + _0)
   _12=self._task_1append_1barvar_II(_1,_0)
   _13=self.__natbarvarmap_ptr[self.__natbarvarmap_nblock]
   _14=self.__natbarvar_ptr[_3]
   for _15 in range(0,_1):
    for _16 in range(_15,_1):
     for _17 in range(0,_0):
      self.__natbarvar_idx[(_14 + (_17 * _4))] = (_13 + _17)
      self.__natbarvar_i[(_14 + (_17 * _4))] = _16
      self.__natbarvar_j[(_14 + (_17 * _4))] = _15
     _14 += 1
   for _18 in range(0,_0):
    self.__natbarvar_ptr[((_13 + _18) + 1)] = (self.__natbarvar_ptr[(_13 + _18)] + _4)
   self.__natbarvarmap_nblock += 1
   self.__natbarvar_numbarvarelm += (_0 * _4)
   return numpy.int32((self.__natbarvarmap_nblock - 1))
  def __natvarmap_1alloc_alt_I(self,_t__0):
    return self.__natvarmap_1alloc_I(numpy.int32(__0))
  def __natvarmap_1alloc_I(self,_0):
   _1=self.__natvarmap.alloc(_0)
   _2=(self.__natvarmap.maxidx(_1) + 1)
   _3=self.__natvarmap.capacity()
   _4=self.__natvarmap.numblocks()
   if (int((self.__natvarmap_idx).shape[0]) < _3): # src/fusion/Model.mbi:3254:12-39
    _5=int((self.__natvarmap_idx).shape[0])
    self.__natvarmap_idx = mosek.fusion.CommonTools._resize__3II(self.__natvarmap_idx,_3)
    for _6 in range(_5,_3):
     self.__natvarmap_idx[_6] = (- 1)
    self.__natvarmap_blockid = mosek.fusion.CommonTools._resize__3II(self.__natvarmap_blockid,_3)
   if (int((self.__vars).shape[0]) < _4): # src/fusion/Model.mbi:3259:12-35
    self.__natvarmap_type = mosek.fusion.CommonTools._resize__3II(self.__natvarmap_type,_4)
    _7=numpy.ndarray((_4,), dtype=numpy.dtype(object))
    for _8 in range(0,int((self.__vars).shape[0])):
     _7[_8] = self.__vars[_8]
    for _9 in range(int((self.__vars).shape[0]),int((_7).shape[0])):
     _7[_9] = None
    self.__vars = _7
   if (self._task_1numvar_() < _2): # src/fusion/Model.mbi:3270:12-37
    self._task_1append_1var_I((_2 - self._task_1numvar_()))
   return numpy.int32(_1)
  def __natconmap_1alloc_alt_I(self,_t__0):
    return self.__natconmap_1alloc_I(numpy.int32(__0))
  def __natconmap_1alloc_I(self,_0):
   _1=self.__natconmap.alloc(_0)
   _2=(self.__natconmap.maxidx(_1) + 1)
   _3=self.__natconmap.capacity()
   _4=self.__natconmap.numblocks()
   if (int((self.__natconmap_idx).shape[0]) < _3): # src/fusion/Model.mbi:3212:12-39
    _5=int((self.__natconmap_idx).shape[0])
    self.__natconmap_idx = mosek.fusion.CommonTools._resize__3II(self.__natconmap_idx,_3)
    for _6 in range(_5,_3):
     self.__natconmap_idx[_6] = (- 1)
    self.__natconmap_efix = mosek.fusion.CommonTools._resize__3DI(self.__natconmap_efix,_3)
    self.__natconmap_lb = mosek.fusion.CommonTools._resize__3DI(self.__natconmap_lb,_3)
    self.__natconmap_ub = mosek.fusion.CommonTools._resize__3DI(self.__natconmap_ub,_3)
    self.__natconmap_blockid = mosek.fusion.CommonTools._resize__3II(self.__natconmap_blockid,_3)
    self.__natconmap_slackidx = mosek.fusion.CommonTools._resize__3JI(self.__natconmap_slackidx,_3)
   if (int((self.__cons).shape[0]) < _4): # src/fusion/Model.mbi:3222:12-35
    self.__natconmap_type = mosek.fusion.CommonTools._resize__3II(self.__natconmap_type,_4)
    _7=numpy.ndarray((_4,), dtype=numpy.dtype(object))
    for _8 in range(0,int((self.__cons).shape[0])):
     _7[_8] = self.__cons[_8]
    for _9 in range(int((self.__cons).shape[0]),_4):
     _7[_9] = None
    self.__cons = _7
   if (_2 > self._task_1numcon_()): # src/fusion/Model.mbi:3234:12-37
    self._task_1append_1con_I((_2 - self._task_1numcon_()))
   return numpy.int32(_1)
  def __natconemap_1alloc_alt_I(self,_t__0):
    return self.__natconemap_1alloc_I(numpy.int32(__0))
  def __natconemap_1alloc_I(self,_0):
   _1=self.__natconemap.alloc(_0)
   _2=(self.__natconemap.maxidx(_1) + 1)
   if (_2 > self._task_1numcone_()): # src/fusion/Model.mbi:3194:12-39
    self._task_1append_1zerocones_I((_2 - self._task_1numcone_()))
   self.__natconemap_dim = mosek.fusion.CommonTools._resize__3II(self.__natconemap_dim,self.__natconemap.numblocks())
   return numpy.int32(_1)
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=0
   for _2 in range(0,int((_0).shape[0])):
    if (_0[_2] > 0): # src/fusion/Model.mbi:3173:54-65
     _1 += 1
   _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _4=0
   for _5 in range(0,int((_0).shape[0])):
    if (_0[_5] > 0): # src/fusion/Model.mbi:3178:14-25
     _3[_4] = numpy.int32((_0[_5] - 1))
     _4 += 1
   self._task_1var_1putcontlist__3I(_3)
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=0
   for _2 in range(0,int((_0).shape[0])):
    if (_0[_2] > 0): # src/fusion/Model.mbi:3161:54-65
     _1 += 1
   _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _4=0
   for _5 in range(0,int((_0).shape[0])):
    if (_0[_5] > 0): # src/fusion/Model.mbi:3165:14-25
     _3[_4] = numpy.int32((_0[_5] - 1))
     _4 += 1
   self._task_1var_1putintlist__3I(_3)
  @staticmethod
  def _match_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Z__(_0))
  @staticmethod
  def _match_alt_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Z__(_0))
  @staticmethod
  def _putlicensewait_alt_Z(_t__0):
    return mosek_fusion_Model._putlicensewait_Z(_0)
  @staticmethod
  def _putlicensewait_Z(_0):
   mosek.fusion.BaseModel._env_1putlicensewait_Z(_0)
  @staticmethod
  def _match_putlicensepath_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_putlicensepath_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  @staticmethod
  def _putlicensepath_alt_S(_t__0):
    return mosek_fusion_Model._putlicensepath_S(_0)
  @staticmethod
  def _putlicensepath_S(_0):
   mosek.fusion.BaseModel._env_1putlicensepath_S(_0)
  @staticmethod
  def _match_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _putlicensecode_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Model._putlicensecode__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _putlicensecode__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   mosek.fusion.BaseModel._env_1putlicensecode__3I(_0)
  @staticmethod
  def _match_dispose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dispose_(*args):
    if len(args) != 0: return False
    return True
  def _dispose_alt_(self,):
    return self._dispose_()
  def _dispose_(self,):
   for _0 in range(0,int((self.__vars).shape[0])):
    self.__vars[_0] = None
   for _1 in range(0,int((self.__cons).shape[0])):
    self.__cons[_1] = None
   mosek_fusion_BaseModel._dispose_(self)
  def _nativeVarToStr_alt_ILmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2(numpy.int32(__0),_1)
  def _nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or ((_0 >= int((self.__natvarmap_idx).shape[0])) or (self.__natvarmap_idx[_0] < 0))): # src/fusion/Model.mbi:3128:12-77
    raise mosek_fusion_IndexError._ctor_S("Native variable index is invalid")
   self.__vars[self.__natvarmap_blockid[_0]].elementName(self.__natvarmap_idx[_0],_1)
  @staticmethod
  def _match_getTask_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getTask_(*args):
    if len(args) != 0: return False
    return True
  def _getTask_alt_(self,):
    return self._getTask_()
  def _getTask_(self,):
   return (self._task_1get_())
  @staticmethod
  def _match_getConstraintValues_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getConstraintValues_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getConstraintValues_alt_Z_3I_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getConstraintValues_Z_3I_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getConstraintValues_Z_3I_3DI(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=int((_1).shape[0])
   _5=(self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_0 ) else self._getSolution_1yx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _6=(self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_0 ) else self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _7=(self._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_0 ) else self._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   for _8 in range(0,_4):
    _9=self.__natconmap_slackidx[_1[_8]]
    if (_9 < 0): # src/fusion/Model.mbi:3092:14-26
     _10=(- (_9 + 1))
     _2[(_3 + _8)] = _6[_10]
    elif (_9 > 0): # src/fusion/Model.mbi:3096:18-30
     _2[(_3 + _8)] = _5[(_9 - 1)]
    else:
     _2[(_3 + _8)] = _7[_1[_8]]
  @staticmethod
  def _match_getVariableDuals_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getVariableDuals_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getVariableDuals_alt_Z_3J_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getVariableDuals_Z_3J_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getVariableDuals_Z_3J_3DI(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=int((_1).shape[0])
   if _0: # src/fusion/Model.mbi:3050:12-17
    _5=self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    for _6 in range(0,_4):
     if (_1[_6] > 0): # src/fusion/Model.mbi:3054:16-33
      _2[(_3 + _6)] = _5[(_1[_6] - 1)]
     else:
      _2[(_3 + _6)] = 0
   else:
    _7=self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    for _8 in range(0,_4):
     if (_1[_8] > 0): # src/fusion/Model.mbi:3066:16-33
      _2[(_3 + _8)] = (- _7[(_1[_8] - 1)])
     else:
      _2[(_3 + _8)] = 0
  @staticmethod
  def _match_getVariableValues_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getVariableValues_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getVariableValues_alt_Z_3J_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getVariableValues_Z_3J_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getVariableValues_Z_3J_3DI(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=int((_1).shape[0])
   _5=(self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_0 ) else self._getSolution_1yx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _6=((self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_0 ) else self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)) if ((self.__natbarvar_numbarvarelm > 0) ) else None)
   for _7 in range(0,_4):
    if (_1[_7] > 0): # src/fusion/Model.mbi:3032:14-31
     _2[(_3 + _7)] = _5[(_1[_7] - 1)]
    elif (_1[_7] < 0): # src/fusion/Model.mbi:3035:18-35
     _8=(- (_1[_7] + 1))
     _2[(_3 + _7)] = _6[_8]
    else:
     _2[(_3 + _7)] = 0
  @staticmethod
  def _match_setVariableValues_Z_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Z__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_setVariableValues_Z_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2))
  def _setVariableValues_alt_Z_3J_3D(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._setVariableValues_Z_3J_3D(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setVariableValues_Z_3J_3D(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if _0: # src/fusion/Model.mbi:3000:12-18
    _3=0
    for _4 in range(0,int((_1).shape[0])):
     if (_1[_4] >= 0): # src/fusion/Model.mbi:3003:16-34
      _3 += 1
    _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _6=(_2 if ((_3==int((_1).shape[0])) ) else _2)
    _7=0
    for _8 in range(0,int((_1).shape[0])):
     if (_1[_8] > 0): # src/fusion/Model.mbi:3009:16-33
      _5[_7] = numpy.int32((_1[_8] - 1))
      _7 += 1
    self._setSolution_1xx__3I_3D(_5,_6)
   else:
    pass
  @staticmethod
  def _match_flushNames_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushNames_(*args):
    if len(args) != 0: return False
    return True
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   for _0 in range(0,int((self.__vars).shape[0])):
    if (self.__vars[_0] is not None): # src/fusion/Model.mbi:2983:14-29
     self.__vars[_0]._flushNames_()
   for _1 in range(0,int((self.__barvars).shape[0])):
    if (self.__barvars[_1] is not None): # src/fusion/Model.mbi:2986:14-32
     self.__barvars[_1]._flushNames_()
   for _2 in range(0,int((self.__cons).shape[0])):
    if (self.__cons[_2] is not None): # src/fusion/Model.mbi:2989:14-29
     self.__cons[_2]._flushNames_()
  @staticmethod
  def _match_writeTask_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_writeTask_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _writeTask_alt_S(self,_t__0):
    return self._writeTask_S(_0)
  def _writeTask_S(self,_0):
   self.flushNames()
   self._task_1write_S(_0)
  @staticmethod
  def _match_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverLIntInfo_alt_S(self,_t__0):
    return self._getSolverLIntInfo_S(_0)
  def _getSolverLIntInfo_S(self,_0):
   return numpy.int64(self._task_1get_1liinf_S(_0))
  @staticmethod
  def _match_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverIntInfo_alt_S(self,_t__0):
    return self._getSolverIntInfo_S(_0)
  def _getSolverIntInfo_S(self,_0):
   return numpy.int32(self._task_1get_1iinf_S(_0))
  @staticmethod
  def _match_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverDoubleInfo_alt_S(self,_t__0):
    return self._getSolverDoubleInfo_S(_0)
  def _getSolverDoubleInfo_S(self,_0):
   return numpy.float64(self._task_1get_1dinf_S(_0))
  @staticmethod
  def _match_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4CallbackHandler_2__(_0))
  @staticmethod
  def _match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4CallbackHandler_2__(_0))
  def _setCallbackHandler_alt_LSystem_4CallbackHandler_2(self,_t__0):
    return self._setCallbackHandler_LSystem_4CallbackHandler_2(_0)
  def _setCallbackHandler_LSystem_4CallbackHandler_2(self,_0):
   self._task_1setCallbackHandler_LSystem_4CallbackHandler_2(_0)
  @staticmethod
  def _match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4DataCallbackHandler_2__(_0))
  @staticmethod
  def _match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4DataCallbackHandler_2__(_0))
  def _setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(self,_t__0):
    return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_0)
  def _setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,_0):
   self._task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_0)
  @staticmethod
  def _match_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4StreamWriter_2__(_0))
  @staticmethod
  def _match_alt_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4StreamWriter_2__(_0))
  def _setLogHandler_alt_LSystem_4StreamWriter_2(self,_t__0):
    return self._setLogHandler_LSystem_4StreamWriter_2(_0)
  def _setLogHandler_LSystem_4StreamWriter_2(self,_0):
   self._task_1setLogHandler_LSystem_4StreamWriter_2(_0)
  @staticmethod
  def _match_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_D__(_1))
  def _setSolverParam_alt_SD(self,_t__0,_t__1):
    return self._setSolverParam_SD(_0,numpy.float64(__1))
  def _setSolverParam_SD(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SD(self,_0,_1)
  @staticmethod
  def _match_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _setSolverParam_alt_SI(self,_t__0,_t__1):
    return self._setSolverParam_SI(_0,numpy.int32(__1))
  def _setSolverParam_SI(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SI(self,_0,_1)
  @staticmethod
  def _match_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_S__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_S__(_1))
  def _setSolverParam_alt_SS(self,_t__0,_t__1):
    return self._setSolverParam_SS(_0,_1)
  def _setSolverParam_SS(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SS(self,_0,_1)
  @staticmethod
  def _match_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  def _breakSolver_alt_(self,):
    return self._breakSolver_()
  def _breakSolver_(self,):
   self._task_1break_1solve_()
  @staticmethod
  def _match_solve_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_solve_(*args):
    if len(args) != 0: return False
    return True
  def _solve_alt_(self,):
    return self._solve_()
  def _solve_(self,):
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Interior)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Integer)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Basic)
   self._task_1solve_()
  @staticmethod
  def _match_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  def _flushSolutions_alt_(self,):
    return self._flushSolutions_()
  def _flushSolutions_(self,):
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Interior)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Integer)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Basic)
  def __flush_1initsol_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(__0)
  def __flush_1initsol_Emosek_4fusion_4SolutionType_2(self,_0):
   if (self.__initsol_xx is not None): # src/fusion/Model.mbi:2732:12-30
    _1=self._task_1numvar_()
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    try:
     _3=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True)
     if ((_3.xx) is not None): # src/fusion/Model.mbi:2737:16-30
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_3.xx),0,_2,0,(int(((_3.xx)).shape[0]) if ((int(((_3.xx)).shape[0]) <= _1) ) else _1))
    except mosek_fusion_SolutionError as _4:
     pass
    _5=(int((self.__initsol_xx).shape[0]) if ((int((self.__initsol_xx).shape[0]) <= _1) ) else _1)
    for _6 in range(0,_5):
     if self.__initsol_xx_flag[_6]: # src/fusion/Model.mbi:2744:16-34
      _2[_6] = self.__initsol_xx[_6]
    self._task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(_0,0,_1,_2)
  @staticmethod
  def _match_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getDualSolutionStatus_alt_(self,):
    return self._getDualSolutionStatus_()
  def _getDualSolutionStatus_(self,):
   return (self.getDualSolutionStatus(self.__solutionptr))
  @staticmethod
  def _match_getProblemStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getProblemStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getProblemStatus_alt_(self,):
    return self._getProblemStatus_()
  def _getProblemStatus_(self,):
   return (self.getProblemStatus(self.__solutionptr))
  @staticmethod
  def _match_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getPrimalSolutionStatus_alt_(self,):
    return self._getPrimalSolutionStatus_()
  def _getPrimalSolutionStatus_(self,):
   return (self.getPrimalSolutionStatus(self.__solutionptr))
  @staticmethod
  def _match_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _dualObjValue_alt_(self,):
    return self._dualObjValue_()
  def _dualObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,False).dobj))
  @staticmethod
  def _match_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _primalObjValue_alt_(self,):
    return self._primalObjValue_()
  def _primalObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,True).pobj))
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2ZZ(self,_t__0,_t__1,_t__2):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(__0,_1,_2)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(self,_0,_1,_2):
   _3=None
   _4=_0
   if (_4==mosek.fusion.SolutionType.Default): # src/fusion/Model.mbi:2634:12-41
    _4 = self.__solutionptr
   if (_4==mosek.fusion.SolutionType.Default): # src/fusion/Model.mbi:2637:12-41
    if (self._sol_itg is not None): # src/fusion/Model.mbi:2639:18-33
     _3 = self._sol_itg
    elif (self._sol_bas is not None): # src/fusion/Model.mbi:2640:18-33
     _3 = self._sol_bas
    else:
     _3 = self._sol_itr
   elif (_4==mosek.fusion.SolutionType.Interior): # src/fusion/Model.mbi:2643:16-46
    _3 = self._sol_itr
   elif (_4==mosek.fusion.SolutionType.Basic): # src/fusion/Model.mbi:2644:16-43
    _3 = self._sol_bas
   elif (_4==mosek.fusion.SolutionType.Integer): # src/fusion/Model.mbi:2645:16-45
    _3 = self._sol_itg
   if (_3 is None): # src/fusion/Model.mbi:2647:12-23
    raise mosek_fusion_SolutionError._ctor_S("Solution not available")
   else:
    if (_2 or ((_1 and _3.isPrimalAcceptable(self.__acceptable_sol)) or ((not _1) and _3.isDualAcceptable(self.__acceptable_sol)))): # src/fusion/Model.mbi:2653:14-2655:69
     return (_3)
    else:
     _5=mosek.fusion.Utils.StringBuffer()
     _6=(_3.pstatus)
     _7=(_3.probstatus)
     if (not _1): # src/fusion/Model.mbi:2664:16-26
      _6 = (_3.dstatus)
     _5._a_S("Solution status is ")
     if (_6==mosek.fusion.SolutionStatus.Undefined): # src/fusion/Model.mbi:2666:20-54
      _5._a_S("Undefined")
     elif (_6==mosek.fusion.SolutionStatus.Unknown): # src/fusion/Model.mbi:2667:20-52
      _5._a_S("Unknown")
     elif (_6==mosek.fusion.SolutionStatus.Optimal): # src/fusion/Model.mbi:2668:20-52
      _5._a_S("Optimal")
     elif (_6==mosek.fusion.SolutionStatus.Feasible): # src/fusion/Model.mbi:2669:20-53
      _5._a_S("Feasible")
     elif (_6==mosek.fusion.SolutionStatus.Certificate): # src/fusion/Model.mbi:2670:20-56
      _5._a_S("Certificate")
     elif (_6==mosek.fusion.SolutionStatus.IllposedCert): # src/fusion/Model.mbi:2671:20-57
      _5._a_S("IllposedCert")
     _5._a_S(" but at least ")
     if (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Anything): # src/fusion/Model.mbi:2673:20-64
      _5._a_S("Anything")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Optimal): # src/fusion/Model.mbi:2674:20-63
      _5._a_S("Optimal")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Feasible): # src/fusion/Model.mbi:2675:20-64
      _5._a_S("Feasible")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Certificate): # src/fusion/Model.mbi:2676:20-67
      _5._a_S("Certificate")
     _5._a_S(" is expected. Reason: Accessing ")
     if (_3 is self._sol_itr): # src/fusion/Model.mbi:2678:20-34
      _5._a_S("interior-point solution")
     elif (_3 is self._sol_bas): # src/fusion/Model.mbi:2679:20-34
      _5._a_S("basic solution")
     elif (_3 is self._sol_itg): # src/fusion/Model.mbi:2680:20-34
      _5._a_S("integer solution")
     _5._a_S(" whose problem status is ")
     if (_7==mosek.fusion.ProblemStatus.Unknown): # src/fusion/Model.mbi:2682:20-52
      _5._a_S("Unknown")
     elif (_7==mosek.fusion.ProblemStatus.PrimalAndDualFeasible): # src/fusion/Model.mbi:2683:20-66
      _5._a_S("PrimalAndDualFeasible")
     elif (_7==mosek.fusion.ProblemStatus.PrimalFeasible): # src/fusion/Model.mbi:2684:20-59
      _5._a_S("PrimalFeasible")
     elif (_7==mosek.fusion.ProblemStatus.DualFeasible): # src/fusion/Model.mbi:2685:20-57
      _5._a_S("DualFeasible")
     elif (_7==mosek.fusion.ProblemStatus.PrimalInfeasible): # src/fusion/Model.mbi:2686:20-61
      _5._a_S("PrimalInfeasible")
     elif (_7==mosek.fusion.ProblemStatus.DualInfeasible): # src/fusion/Model.mbi:2687:20-59
      _5._a_S("DualInfeasible")
     elif (_7==mosek.fusion.ProblemStatus.PrimalAndDualInfeasible): # src/fusion/Model.mbi:2688:20-68
      _5._a_S("PrimalAndDualInfeasible")
     elif (_7==mosek.fusion.ProblemStatus.IllPosed): # src/fusion/Model.mbi:2689:20-53
      _5._a_S("IllPosed")
     elif (_7==mosek.fusion.ProblemStatus.PrimalInfeasibleOrUnbounded): # src/fusion/Model.mbi:2690:20-72
      _5._a_S("PrimalInfeasibleOrUnbounded")
     _5._a_S(".")
     raise mosek_fusion_SolutionError._ctor_S(_5._toString_())
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__0,_t__1):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(__0,_1)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(self,_0,_1):
   return (self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,_1,False))
  def _setSolution_1xx_alt__3I_3D(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._setSolution_1xx__3I_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setSolution_1xx__3I_3D(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._ensure_1initsol_1xx_()
   for _2 in range(0,int((_0).shape[0])):
    self.__initsol_xx[_0[_2]] = _1[_2]
    self.__initsol_xx_flag[_0[_2]] = True
  def _ensure_1initsol_1xx_alt_(self,):
    return self._ensure_1initsol_1xx_()
  def _ensure_1initsol_1xx_(self,):
   _0=int((self.__natvarmap_idx).shape[0])
   if (self.__initsol_xx is None): # src/fusion/Model.mbi:2588:12-30
    self.__initsol_xx = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.array([False for _1 in range(0,_0)], dtype=numpy.dtype(numpy.bool))
   elif (int((self.__initsol_xx).shape[0]) < _0): # src/fusion/Model.mbi:2593:16-47
    _2=self.__initsol_xx
    _3=self.__initsol_xx_flag
    self.__initsol_xx = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.zeros((_0,), dtype=numpy.dtype(numpy.bool))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_2,0,self.__initsol_xx,0,_0)
    for _4 in range(0,_0):
     self.__initsol_xx_flag[_4] = _3[_4]
  def _getSolution_1bars_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1bars_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).bars))
  def _getSolution_1barx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1barx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).barx))
  def _getSolution_1y_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1y_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1y_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).y))
  def _getSolution_1xc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1xc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1xc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).xc))
  def _getSolution_1snx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1snx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1snx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).snx))
  def _getSolution_1suc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1suc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1suc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).suc))
  def _getSolution_1slc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1slc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1slc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).slc))
  def _getSolution_1sux_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1sux_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).sux))
  def _getSolution_1slx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1slx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).slx))
  def _getSolution_1yx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1yx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1yx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).yx))
  def _getSolution_1xx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1xx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).xx))
  @staticmethod
  def _match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _selectedSolution_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._selectedSolution_Emosek_4fusion_4SolutionType_2(__0)
  def _selectedSolution_Emosek_4fusion_4SolutionType_2(self,_0):
   self.__solutionptr = _0
  @staticmethod
  def _match_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getAcceptedSolutionStatus_alt_(self,):
    return self._getAcceptedSolutionStatus_()
  def _getAcceptedSolutionStatus_(self,):
   return (self.__acceptable_sol)
  @staticmethod
  def _match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   self.__acceptable_sol = _0
  @staticmethod
  def _match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getProblemStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   _1=None
   if (_0==mosek.fusion.SolutionType.Default): # src/fusion/Model.mbi:2474:12-41
    if (self._sol_itg is not None): # src/fusion/Model.mbi:2476:18-33
     _1 = self._sol_itg
    elif (self._sol_bas is not None): # src/fusion/Model.mbi:2477:18-33
     _1 = self._sol_bas
    else:
     _1 = self._sol_itr
   elif (_0==mosek.fusion.SolutionType.Interior): # src/fusion/Model.mbi:2480:16-46
    _1 = self._sol_itr
   elif (_0==mosek.fusion.SolutionType.Basic): # src/fusion/Model.mbi:2481:16-43
    _1 = self._sol_bas
   elif (_0==mosek.fusion.SolutionType.Integer): # src/fusion/Model.mbi:2482:16-45
    _1 = self._sol_itg
   if (_1 is None): # src/fusion/Model.mbi:2484:12-23
    return (mosek.fusion.ProblemStatus.Unknown)
   else:
    return ((_1.probstatus))
  @staticmethod
  def _match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_0,False))
  @staticmethod
  def _match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_0,True))
  def _getSolutionStatus_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__0,_t__1):
    return self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(__0,_1)
  def _getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(self,_0,_1):
   try:
    _2=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,_1,True)
    if _1: # src/fusion/Model.mbi:2439:14-20
     return ((_2.pstatus))
    else:
     return ((_2.dstatus))
   except mosek_fusion_SolutionError as _3:
    return (mosek.fusion.SolutionStatus.Undefined)
  def _update_alt__3ILmosek_4fusion_4Expression_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._update__3ILmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _update__3ILmosek_4fusion_4Expression_2(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)).eval(self.__ws,self.__rs,self.__xs)
   _2=self.__ws.popi32()
   _3=self.__ws.popi32(_2)
   _4=self.__ws.popi32()
   _5=self.__ws.popi32()
   _6=(0!=self.__ws.popi32())
   _7=self.__ws.popi32((_4 + 1))
   _8=(self.__ws.popi64(_4) if (_6 ) else 0)
   _9=self.__ws.popi64(_5)
   _10=self.__ws.popf64(_4)
   _11=self.__ws.popf64(_5)
   _12=(self.__ws.i32)
   _13=(self.__ws.i64)
   _14=(self.__ws.f64)
   _15=numpy.zeros(((_4 + 1),), dtype=numpy.dtype(numpy.int64))
   for _16 in range(0,_4):
    for _17 in range(_12[(_7 + _16)],_12[((_7 + _16) + 1)]):
     if (_13[(_9 + _17)] > 0): # src/fusion/Model.mbi:2393:16-38
      _15[(_16 + 1)] += 1
   for _18 in range(0,_4):
    _15[(_18 + 1)] += _15[_18]
   _19=_15[_4]
   _20=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _21=numpy.zeros((_19,), dtype=numpy.dtype(numpy.float64))
   _22=0
   for _23 in range(0,_4):
    for _24 in range(_12[(_7 + _23)],_12[((_7 + _23) + 1)]):
     if (_13[(_9 + _24)] > 0): # src/fusion/Model.mbi:2404:16-38
      _20[_22] = numpy.int32((_13[(_9 + _24)] - 1))
      _21[_22] = _14[(_11 + _24)]
      _22 += 1
   self._task_1putarowlist__3I_3J_3I_3D(_0,_15,_20,_21)
   self._task_1putaijlist__3I_3I_3DJ(_0,numpy.array([self.__bfixidx for _25 in range(0,_4)], dtype=numpy.dtype(numpy.int32)),numpy.array([_14[(_10 + _26)] for _26 in range(0,_4)], dtype=numpy.dtype(numpy.float64)),_4)
   _27=0
   for _28 in range(0,_4):
    if (self.__natconmap_slackidx[_0[_28]] > 0): # src/fusion/Model.mbi:2413:53-87
     _27 += 1
   if (_27 > 0): # src/fusion/Model.mbi:2414:12-24
    _29=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
    _30=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
    _31=numpy.zeros((_27,), dtype=numpy.dtype(numpy.float64))
    _32=0
    for _33 in range(0,_4):
     if (self.__natconmap_slackidx[_0[_33]] > 0): # src/fusion/Model.mbi:2419:16-50
      _29[_32] = _0[_33]
      _30[_32] = numpy.int32((self.__natconmap_slackidx[_0[_33]] - 1))
      _31[_32] = (- 1.0)
      _32 += 1
    self._task_1putaijlist__3I_3I_3DJ(_29,_30,_31,_27)
  def _update_alt__3ILmosek_4fusion_4Expression_2_3IZ(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=_t__3
   _1 = self._update__3ILmosek_4fusion_4Expression_2_3IZ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _update__3ILmosek_4fusion_4Expression_2_3IZ(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=(int((_0).shape[0]) * int((_2).shape[0]))
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.array([_0[_7] for _7 in range(0,int((_0).shape[0])) for _8 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _9=numpy.array([_2[_11] for _10 in range(0,int((_0).shape[0])) for _11 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)).eval(self.__ws,self.__rs,self.__xs)
   _12=self.__ws.popi32()
   _13=self.__ws.popi32(_12)
   _14=self.__ws.popi32()
   _15=self.__ws.popi32()
   _16=(0!=self.__ws.popi32())
   _17=self.__ws.popi32((_14 + 1))
   _18=(self.__ws.popi64(_14) if (_16 ) else 0)
   _19=self.__ws.popi64(_15)
   _20=self.__ws.popf64(_14)
   _21=self.__ws.popf64(_15)
   _22=(self.__ws.i32)
   _23=(self.__ws.i64)
   _24=(self.__ws.f64)
   _25=0
   for _26 in range(0,_14):
    _27=_22[(_17 + _26)]
    _28=_22[((_17 + _26) + 1)]
    _29=_27
    _30=0
    while ((_30 < int((_2).shape[0])) and (_29 < _28)):
     if (_2[_30] < (_23[(_19 + _29)] - 1)): # src/fusion/Model.mbi:2353:20-53
      _30 += 1
     elif (_2[_30] > (_23[(_19 + _29)] - 1)): # src/fusion/Model.mbi:2355:20-53
      _29 += 1
     else:
      _5[(_25 + _30)] = _24[(_21 + _29)]
      _30 += 1
      _29 += 1
    _25 += int((_2).shape[0])
   self._task_1putaijlist__3I_3I_3DJ(_6,_9,_5,_4)
   if _3: # src/fusion/Model.mbi:2365:12-16
    self._task_1putaijlist__3I_3I_3DJ(_0,numpy.array([self.__bfixidx for _31 in range(0,_14)], dtype=numpy.dtype(numpy.int32)),numpy.array([_24[(_20 + _32)] for _32 in range(0,_14)], dtype=numpy.dtype(numpy.float64)),_14)
  @staticmethod
  def _match_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  def _updateObjective_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_t__0,_t__1):
    return self._updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  def _updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_0,_1):
   if (_0.getSize()!=1): # src/fusion/Model.mbi:2252:12-31
    raise mosek_fusion_DimensionError._ctor_S("Invalid expression size for objective")
   _2=_1.numInst()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   if (_2 < _1.getSize()): # src/fusion/Model.mbi:2257:12-28
    _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _1.inst(0,_4,0,_3)
   else:
    _1.inst(0,_3)
   for _5 in range(0,_2):
    if (_3[_5] < 0): # src/fusion/Model.mbi:2265:14-29
     raise mosek_fusion_UnimplementedError._ctor_S("Updating semidefinite terms is currently not possible")
   _6=True
   for _7 in range(0,(_2 - 1)):
    _6 = (_6 and (_3[_7] < _3[(_7 - 1)]))
   _8=None
   if _6: # src/fusion/Model.mbi:2272:12-28
    _8 = numpy.array([numpy.int32((_3[_9] - 1)) for _9 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   else:
    _10=numpy.array([_11 for _11 in range((- 1),_2)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_10,_3,None,0,_2)
    _8 = numpy.array([numpy.int32((_3[_10[_12]] - 1)) for _12 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   _13=int((_8).shape[0])
   _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
   _15=_8
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_0)).eval(self.__ws,self.__rs,self.__xs)
   _16=self.__ws.popi32()
   _17=self.__ws.popi32(_16)
   _18=self.__ws.popi32()
   _19=self.__ws.popi32()
   _20=(0!=self.__ws.popi32())
   _21=self.__ws.popi32((_18 + 1))
   _22=(self.__ws.popi64(_18) if (_20 ) else 0)
   _23=self.__ws.popi64(_19)
   _24=self.__ws.popf64(_18)
   _25=self.__ws.popf64(_19)
   _26=(self.__ws.i32)
   _27=(self.__ws.i64)
   _28=(self.__ws.f64)
   _29=0
   for _30 in range(0,_18):
    _31=_26[(_21 + _30)]
    _32=_26[((_21 + _30) + 1)]
    _33=_31
    _34=0
    while ((_34 < int((_8).shape[0])) and (_33 < _32)):
     if (_8[_34] < (_27[(_23 + _33)] - 1)): # src/fusion/Model.mbi:2308:20-53
      _34 += 1
     elif (_8[_34] > (_27[(_23 + _33)] - 1)): # src/fusion/Model.mbi:2310:20-53
      _33 += 1
     else:
      _14[(_29 + _34)] = _28[(_25 + _33)]
      _34 += 1
      _33 += 1
    _29 += int((_8).shape[0])
   self._task_1putclist__3I_3D(_15,_14)
  def __objective_1_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1,_t__2):
    return self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,__1,_2)
  def __objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1,_2):
   self._task_1putobjectivename_S(_0)
   _3=mosek_fusion_WorkStack._ctor_()
   _4=mosek_fusion_WorkStack._ctor_()
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_2)).eval(_3,_4,self.__xs)
   _5=(_3.i32)
   _6=(_3.i64)
   _7=(_3.f64)
   _8=_3.popi32()
   _9=1
   for _10 in range(0,_8):
    _8 *= _3.popi32()
   if (_9!=1): # src/fusion/Model.mbi:2187:12-26
    raise mosek_fusion_LengthError._ctor_S("Invalid expression size for objective")
   _11=_3.popi32()
   if (_11!=1): # src/fusion/Model.mbi:2191:12-22
    raise mosek_fusion_LengthError._ctor_S("Invalid expression for objective")
   _12=_3.popi32()
   _13=(_3.popi32()!=0)
   _14=_3.popi32((_11 + 1))
   _15=_3.popi64(_12)
   _16=_3.popf64(_11)
   _17=_3.popf64(_12)
   _18=0
   _19=0
   for _20 in range(0,_12):
    if (_6[(_15 + _20)] < 0): # src/fusion/Model.mbi:2206:18-40
     _19 += 1
    elif (_6[(_15 + _20)] > 0): # src/fusion/Model.mbi:2207:18-40
     _18 += 1
   _21=numpy.zeros((_18,), dtype=numpy.dtype(numpy.int32))
   _22=numpy.zeros((_18,), dtype=numpy.dtype(numpy.float64))
   _23=0
   for _24 in range(0,_12):
    if (_6[(_15 + _24)] > 0): # src/fusion/Model.mbi:2216:17-39
     _21[_23] = numpy.int32((_6[(_15 + _24)] - 1))
     _22[_23] = _7[(_17 + _24)]
     _23 += 1
   self._task_1putobjective_Z_3I_3DD((_1==mosek.fusion.ObjectiveSense.Maximize),_21,_22,_7[_16])
   if (_19 > 0): # src/fusion/Model.mbi:2226:12-21
    _25=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
    _26=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
    _27=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
    _28=numpy.zeros((_19,), dtype=numpy.dtype(numpy.float64))
    for _29 in range(0,_19):
     _30=(- (_6[(_15 + _29)] + 1))
     _25[_29] = self.__natbarvar_idx[_30]
     _26[_29] = self.__natbarvar_i[_30]
     _27[_29] = self.__natbarvar_j[_30]
     _28[_29] = (_7[(_17 + _29)] if ((_26[_29]==_27[_29]) ) else (0.5 * _7[(_17 + _29)]))
    self._task_1putbarc__3I_3I_3I_3D(_25,_26,_27,_28)
  @staticmethod
  def _match_objective_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_objective_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _objective_alt_D(self,_t__0):
    return self._objective_D(numpy.float64(__0))
  def _objective_D(self,_0):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_0))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_D__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2D(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2D(__0,numpy.float64(__1))
  def _objective_Emosek_4fusion_4ObjectiveSense_2D(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,mosek.fusion.Expr._constTerm_D(_1))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(__0,_1)
  def _objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,_1)
  @staticmethod
  def _match_objective_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_objective_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_D__(_1))
  def _objective_alt_SD(self,_t__0,_t__1):
    return self._objective_SD(_0,numpy.float64(__1))
  def _objective_SD(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_1))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_D__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(_0,__1,numpy.float64(__2))
  def _objective_SEmosek_4fusion_4ObjectiveSense_2D(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,mosek.fusion.Expr._constTerm_D(_2))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,__1,_2)
  def _objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4LinPSDDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4LinPSDDomain_2(_0)
  def _variable_Lmosek_4fusion_4LinPSDDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2("",(_0._shape),_0))
  @staticmethod
  def _match_variable_IILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_IILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_IILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_IILmosek_4fusion_4LinPSDDomain_2(numpy.int32(__0),numpy.int32(__1),_2)
  def _variable_IILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2("",numpy.array([_0,_0,_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4LinPSDDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2("",numpy.array([_0,_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4LinPSDDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_3))
  @staticmethod
  def _match_alt_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_3))
  def _variable_alt_SIILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._variable_SIILmosek_4fusion_4LinPSDDomain_2(_0,numpy.int32(__1),numpy.int32(__2),_3)
  def _variable_SIILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2,_3):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,numpy.array([_1,_1,_2], dtype=numpy.dtype(numpy.int32)),_3))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4LinPSDDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,numpy.array([_1,_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4PSDDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4PSDDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4PSDDomain_2(_0)
  def _variable_Lmosek_4fusion_4PSDDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",(_0._shape),_0))
  @staticmethod
  def _match_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_IILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_IILmosek_4fusion_4PSDDomain_2(numpy.int32(__0),numpy.int32(__1),_2)
  def _variable_IILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",numpy.array([_0,_0,_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4PSDDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",numpy.array([_0,_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4PSDDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_3))
  @staticmethod
  def _match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_3))
  def _variable_alt_SIILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._variable_SIILmosek_4fusion_4PSDDomain_2(_0,numpy.int32(__1),numpy.int32(__2),_3)
  def _variable_SIILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2,_3):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,numpy.array([_1,_1,_2], dtype=numpy.dtype(numpy.int32)),_3))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4PSDDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,numpy.array([_1,_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4ConeDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4ConeDomain_2(_0)
  def _variable_Lmosek_4fusion_4ConeDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",None,_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4RangeDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4RangeDomain_2(_0)
  def _variable_Lmosek_4fusion_4RangeDomain_2(self,_0):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",None,_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4LinearDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4LinearDomain_2(_0)
  def _variable_Lmosek_4fusion_4LinearDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",None,_0))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4ConeDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4ConeDomain_2(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",_0,_1))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4RangeDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4RangeDomain_2(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",_0,_1))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4LinearDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4LinearDomain_2(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",_0,_1))
  @staticmethod
  def _match_variable__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_variable__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _variable_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._variable__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",_0,mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4ConeDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4ConeDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4RangeDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4LinearDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_variable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _variable_alt_I(self,_t__0):
    return self._variable_I(numpy.int32(__0))
  def _variable_I(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_variable_(*args):
    if len(args) != 0: return False
    return True
  def _variable_alt_(self,):
    return self._variable_()
  def _variable_(self,):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4ConeDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4ConeDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4RangeDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4LinearDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4ConeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_variable_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1))
  def _variable_alt_S_3I(self,_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._variable_S_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3I(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4ConeDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4RangeDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4LinearDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_variable_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _variable_alt_SI(self,_t__0,_t__1):
    return self._variable_SI(_0,numpy.int32(__1))
  def _variable_SI(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_variable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _variable_alt_S(self,_t__0):
    return self._variable_S(_0)
  def _variable_S(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  def __ranged_1variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:1963:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=(_1 if ((_1 is not None) ) else (_2._shape))
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I((_2._shape),_3))): # src/fusion/Model.mbi:1968:12-64
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   if (_3 is None): # src/fusion/Model.mbi:1970:12-25
    _3 = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   _4=int((_3).shape[0])
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   if (_4 > 0): # src/fusion/Model.mbi:1974:40-46
    _5[(_4 - 1)] = 1
    for _6 in range(1,_4):
     _5[((_4 - _6) - 1)] = (_5[(_4 - _6)] * _3[(_4 - _6)])
   _7=1
   for _8 in range(0,int((_3).shape[0])):
    _7 *= _3[_8]
   _9=None
   if (_9 is not None): # src/fusion/Model.mbi:1978:12-28
    if (int(((_2._sparsity)).shape[1])!=_4): # src/fusion/Model.mbi:1979:14-39
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
    _9 = numpy.zeros((int(((_2._sparsity)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    for _10 in range(0,int(((_2._sparsity)).shape[0])):
     for _11 in range(0,int(((_2._sparsity)).shape[1])):
      if (((_2._sparsity)[_10,_11] < 0) or ((_2._sparsity)[_10,_11] >= _3[_11])): # src/fusion/Model.mbi:1986:18-72
       raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
     _12=0
     for _13 in range(0,int(((_2._sparsity)).shape[1])):
      _12 += (_5[_13] * (_2._sparsity)[_10,_13])
     _9[_10] = _12
   _14=(int((_9).shape[0]) if ((_9 is not None) ) else _7)
   if (_2._scalable): # src/fusion/Model.mbi:1997:12-24
    _15 = numpy.array([(_2._lb)[0] for _17 in range(0,_14)], dtype=numpy.dtype(numpy.float64))
    _16 = numpy.array([(_2._ub)[0] for _18 in range(0,_14)], dtype=numpy.dtype(numpy.float64))
   else:
    _15 = (_2._lb)
    _16 = (_2._ub)
   _19=self.__natvarmap_1alloc_I(_14)
   _20=numpy.zeros((self.__natvarmap.blocksize(_19),), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap.get(_19,_20,0)
   for _21 in range(0,_14):
    self.__natvarmap_idx[_20[_21]] = _19
   self._task_1var_1putboundlist_1ra__3I_3D_3D(_20,_15,_16)
   _22=mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,_0,_19,_3,_9,_20)
   if (_2._cardinal_flag): # src/fusion/Model.mbi:2016:12-29
    self._task_1var_1putintlist__3I(_20)
   self.__vars[_19] = _22
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2020:12-25
    self.__var_map._setItem_SI(_0,_19)
   return (_22)
  def __variable_1_alt_S_3ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=(_1 if ((_1 is not None) ) else (_2._shape))
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:1872:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   if (_3 is None): # src/fusion/Model.mbi:1875:17-30
    raise mosek_fusion_DimensionError._ctor_S("Missing shape")
   elif (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I(_3,(_2._shape)))): # src/fusion/Model.mbi:1877:17-69
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   elif (_2.getAxis() >= int((_3).shape[0])): # src/fusion/Model.mbi:1879:17-44
    raise mosek_fusion_DimensionError._ctor_S("Invalid cone dimension")
   _4=(_2.getAxis() if (((_2._shape) is not None) ) else (int((_3).shape[0]) - 1))
   _5=_3[_4]
   _6=int((_3).shape[0])
   _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _7[(_6 - 1)] = 1
   for _8 in range(1,_6):
    _7[((_6 - _8) - 1)] = (_7[(_6 - _8)] * _3[(_6 - _8)])
   _9=_3[0]
   for _10 in range(1,int((_3).shape[0])):
    _9 *= _3[_10]
   _11=1
   for _12 in range(0,_4):
    _11 *= _3[_12]
   _13=1
   for _14 in range((_4 + 1),_6):
    _13 *= _3[_14]
   _15=(_11 * _13)
   if ((((_2._key)==mosek.fusion.QConeKey.InQCone) and (_5 < 2)) or ((((_2._key)==mosek.fusion.QConeKey.InRotatedQCone) and (_5 < 3)) or ((((_2._key)==mosek.fusion.QConeKey.InPExpCone) and (_5!=3)) or ((((_2._key)==mosek.fusion.QConeKey.InPPowCone) and (_5 < 2)) or ((((_2._key)==mosek.fusion.QConeKey.InDExpCone) and (_5!=3)) or (((_2._key)==mosek.fusion.QConeKey.InDPowCone) and (_5 < 2))))))): # src/fusion/Model.mbi:1893:13-1898:66
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for cone")
   _16=self.__natvarmap_1alloc_I(_9)
   _17=self.__natconemap_1alloc_I(_15)
   self.__natvarmap_type[_16] = (_17 + 6)
   _18=numpy.zeros((self.__natvarmap.blocksize(_16),), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap.get(_16,_18,0)
   for _19 in range(0,_9):
    self.__natvarmap_idx[_18[_19]] = _16
   self._task_1var_1putboundlist_1fr__3I(_18)
   if (_2._int_flag): # src/fusion/Model.mbi:1911:12-24
    self._task_1var_1putintlist__3I(_18)
   _20=_18
   if (_4 < (int((_3).shape[0]) - 1)): # src/fusion/Model.mbi:1916:12-35
    _20 = numpy.zeros((int((_18).shape[0]),), dtype=numpy.dtype(numpy.int32))
    _21=0
    for _22 in range(0,_11):
     for _23 in range(0,_13):
      for _24 in range(0,_5):
       _20[_21] = _18[((((_22 * _5) + _24) * _13) + _23)]
       _21 += 1
   _25=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int32))
   self.__natconemap.get(_17,_25,0)
   self.__natconemap_dim[_17] = _5
   if ((_2._key)==mosek.fusion.QConeKey.InQCone): # src/fusion/Model.mbi:1933:12-39
    self._task_1put_1quadcones__3III_3I(_25,_5,_15,_20)
   else:
    if ((_2._key)==mosek.fusion.QConeKey.InRotatedQCone): # src/fusion/Model.mbi:1934:17-51
     self._task_1put_1rquadcones__3III_3I(_25,_5,_15,_20)
    else:
     if ((_2._key)==mosek.fusion.QConeKey.InPExpCone): # src/fusion/Model.mbi:1935:17-47
      self._task_1put_1pexpcones__3III_3I(_25,_5,_15,_20)
     else:
      if ((_2._key)==mosek.fusion.QConeKey.InPPowCone): # src/fusion/Model.mbi:1936:17-47
       self._task_1put_1ppowcones__3III_3I_3D(_25,_5,_15,_20,numpy.array([(_2._alpha) for _26 in range(0,_15)], dtype=numpy.dtype(numpy.float64)))
      else:
       if ((_2._key)==mosek.fusion.QConeKey.InDExpCone): # src/fusion/Model.mbi:1937:17-47
        self._task_1put_1dexpcones__3III_3I(_25,_5,_15,_20)
       else:
        if ((_2._key)==mosek.fusion.QConeKey.InDPowCone): # src/fusion/Model.mbi:1938:17-47
         self._task_1put_1dpowcones__3III_3I_3D(_25,_5,_15,_20,numpy.array([(_2._alpha) for _27 in range(0,_15)], dtype=numpy.dtype(numpy.float64)))
   for _28 in range(0,int((_25).shape[0])):
    self._task_1cone_1name_IS(_25[_28],mosek.fusion.Utils.StringBuffer()._a_I(_25[_28])._toString_())
   _29=mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4Model_2SI_3I_3I(self,_0,_16,_3,_18)
   self.__vars[_16] = _29
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1948:12-25
    self.__var_map._setItem_SI(_0,_16)
   return (_29)
  def __variable_1_alt_S_3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:1666:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=(_1 if ((_1 is not None) ) else (_2._shape))
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I((_2._shape),_3))): # src/fusion/Model.mbi:1671:12-64
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   if (_3 is None): # src/fusion/Model.mbi:1673:12-25
    _3 = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   _4=int((_3).shape[0])
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   if (_4 > 0): # src/fusion/Model.mbi:1677:40-46
    _5[(_4 - 1)] = 1
    for _6 in range(1,_4):
     _5[((_4 - _6) - 1)] = (_5[(_4 - _6)] * _3[(_4 - _6)])
   _7=1
   for _8 in range(0,int((_3).shape[0])):
    _7 *= _3[_8]
   _9=None
   _10=None
   if (_2._empty): # src/fusion/Model.mbi:1682:12-21
    _9 = numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   elif ((_2._sparsity) is not None): # src/fusion/Model.mbi:1685:16-36
    if (int(((_2._sparsity)).shape[1])!=_4): # src/fusion/Model.mbi:1686:14-39
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
    _11=int(((_2._sparsity)).shape[0])
    _9 = numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
    _12=False
    _13=(_2._sparsity)
    for _14 in range(0,_11):
     for _15 in range(0,int((_13).shape[1])):
      _12 = (_12 or ((_13[_14,_15] < 0) or (_13[_14,_15] >= _3[_15])))
     if (not _12): # src/fusion/Model.mbi:1698:18-25
      _16=0
      for _17 in range(0,int((_13).shape[1])):
       _16 += (_5[_17] * _13[_14,_17])
      _9[_14] = _16
    if _12: # src/fusion/Model.mbi:1704:16-19
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is out of bounds")
    _18=(_2._sparsity)
    _19=0
    for _20 in range(0,_4):
     if (_19 < _3[_20]): # src/fusion/Model.mbi:1710:50-67
      _19 = _3[_20]
    _21=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
    for _22 in range(0,_11):
     _21[_22] = _22
    _23=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
    _24=numpy.zeros(((_19 + 1),), dtype=numpy.dtype(numpy.int32))
    for _25 in range(0,_4):
     _26=((_4 - _25) - 1)
     for _27 in range(0,(_3[_26] + 1)):
      _24[_27] = 0
     for _28 in range(0,_11):
      _24[(_18[_28,_26] + 1)] += 1
     for _29 in range(0,_3[_26]):
      _24[(_29 + 1)] += _24[_29]
     for _30 in range(0,_11):
      _31=_21[_30]
      _23[_24[_18[_31,_26]]] = _31
      _24[_18[_31,_26]] += 1
     _32=_21
     _21 = _23
     _23 = _32
    for _33 in range(0,_11):
     _34=_21[_33]
     _35=0
     for _36 in range(0,_4):
      _35 += (_5[_36] * _18[_34,_36])
     _9[_33] = _35
   _37=(int((_9).shape[0]) if ((_9 is not None) ) else _7)
   _38=numpy.zeros((_37,), dtype=numpy.dtype(numpy.float64))
   if ((_2._bnd) is not None): # src/fusion/Model.mbi:1741:12-27
    if (int(((_2._bnd)).shape[0])==1): # src/fusion/Model.mbi:1742:14-31
     for _39 in range(0,_37):
      _38[_39] = (_2._bnd)[0]
    elif (int(((_2._bnd)).shape[0])==_37): # src/fusion/Model.mbi:1744:18-43
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_2._bnd),0,_38,0,_37)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Invalid right hand side shape in domain")
   _40=self.__natvarmap_1alloc_I(_37)
   _41=numpy.zeros((self.__natvarmap.blocksize(_40),), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap.get(_40,_41,0)
   for _42 in range(0,_37):
    self.__natvarmap_idx[_41[_42]] = _40
   if ((_2._key)==mosek.fusion.RelationKey.IsFree): # src/fusion/Model.mbi:1757:17-46
    self._task_1var_1putboundlist_1fr__3I(_41)
    self.__natvarmap_type[_40] = 1
   if ((_2._key)==mosek.fusion.RelationKey.LessThan): # src/fusion/Model.mbi:1761:17-48
    self._task_1var_1putboundlist_1up__3I_3D(_41,_38)
    self.__natvarmap_type[_40] = 3
   elif ((_2._key)==mosek.fusion.RelationKey.GreaterThan): # src/fusion/Model.mbi:1765:17-51
    self._task_1var_1putboundlist_1lo__3I_3D(_41,_38)
    self.__natvarmap_type[_40] = 2
   elif ((_2._key)==mosek.fusion.RelationKey.EqualsTo): # src/fusion/Model.mbi:1769:17-48
    self._task_1var_1putboundlist_1fx__3I_3D(_41,_38)
    self.__natvarmap_type[_40] = 5
   _43=mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,_0,_40,_3,_9,_41)
   if (_2._cardinal_flag): # src/fusion/Model.mbi:1776:12-29
    self._task_1var_1putintlist__3I(_41)
   self.__vars[_40] = _43
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1780:12-25
    self.__var_map._setItem_SI(_0,_40)
   return (_43)
  def __variable_1_alt_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:1606:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=(_1 if ((_1 is not None) ) else (_2._shape))
   if (_3 is None): # src/fusion/Model.mbi:1611:12-25
    raise mosek_fusion_DimensionError._ctor_S("Missing shape for variable")
   elif (not mosek.fusion.Set._match__3I_3I((_2._shape),_3)): # src/fusion/Model.mbi:1613:17-47
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _4=int((_3).shape[0])
   _5=(_2._conedim)
   if ((_5 < 0) or (_5 >= _4)): # src/fusion/Model.mbi:1619:12-40
    raise mosek_fusion_DimensionError._ctor_S("Invalid cone direction dimension")
   _6=_3[_5]
   _7=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _6))) - 1) / 2))
   if (((_7 * (_7 + 1)) // 2)!=_6): # src/fusion/Model.mbi:1626:12-32
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for semidefinite variable")
   _8=1
   _9=_3[_5]
   _10=1
   for _11 in range(0,_5):
    _10 *= _3[_11]
   for _12 in range((_5 + 1),_4):
    _8 *= _3[_12]
   _13=(_10 * _8)
   _14=(_13 * _6)
   _15=self.__natbarvarmap_1alloc_II(_13,_7)
   _16=numpy.zeros((_14,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_1get_I_3I(_15,_16)
   _17=numpy.zeros(((_13 * _9),), dtype=numpy.dtype(numpy.int64))
   _18=0
   for _19 in range(0,_10):
    for _20 in range(0,_9):
     for _21 in range(0,(_20 + 1)):
      for _22 in range(0,_8):
       _17[_18] = (self.__natbarvar_ptr[((_19 * _8) + _22)] + (((_20 * (((2 * _7) - _20) - 1)) // 2) + _21))
       _18 += 1
   _23=mosek_fusion_LinearPSDVariable._ctor_Lmosek_4fusion_4Model_2SI_3II_3J(self,_0,_15,_3,_5,_17)
   self.__barvars[_15] = _23
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1654:12-25
    self.__var_map._setItem_SI(_0,(- (_15 + 1)))
   return (_23)
  def __variable_1_alt_S_3ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:1536:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=_1
   if (_3 is None): # src/fusion/Model.mbi:1540:12-25
    _3 = (_2._shape)
   if (_3 is None): # src/fusion/Model.mbi:1543:12-25
    raise mosek_fusion_DimensionError._ctor_S("Missing shape for variable")
   _4=(_2._conedim1)
   _5=(_2._conedim2)
   _6=int((_3).shape[0])
   _7=_3[_4]
   if (_4 > _5): # src/fusion/Model.mbi:1551:12-31
    _8=_4
    _4 = _5
    _5 = _8
   if ((_4==_5) or ((_4 < 0) or (_5 >= _6))): # src/fusion/Model.mbi:1553:12-66
    raise mosek_fusion_DimensionError._ctor_S("Invalid cone order dimensions for semidefinite variables")
   if (_3[_4]!=_3[_5]): # src/fusion/Model.mbi:1555:12-46
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape in cone order dimensions")
   _9=1
   for _10 in range(0,_4):
    _9 *= _3[_10]
   for _11 in range((_4 + 1),_5):
    _9 *= _3[_11]
   for _12 in range((_5 + 1),_6):
    _9 *= _3[_12]
   _13=(((_9 * _7) * (_7 + 1)) // 2)
   _14=self.__natbarvarmap_1alloc_II(_9,_7)
   _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
   self.__natbarvar_1get_I_3J(_14,_15)
   _16=mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4Model_2SI_3III_3J(self,_0,_14,_3,(_2._conedim1),(_2._conedim2),_15)
   self.__barvars[_14] = _16
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1595:12-25
    self.__var_map._setItem_SI(_0,(- (_14 + 1)))
   return (_16)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:1424:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if (_2._cardinal_flag): # src/fusion/Model.mbi:1427:12-29
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1))
   _3.eval(self.__rs,self.__ws,self.__xs)
   self.__rs.pop_expr()
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=(self.__rs.nd)
   _8=(self.__rs.shape_base)
   _9=(self.__rs.nelem)
   _10=(self.__rs.nnz)
   _11=(self.__rs.hassp)
   _12=(self.__rs.ptr_base)
   _13=(self.__rs.nidxs_base)
   _14=(self.__rs.bfix_base)
   _15=(self.__rs.cof_base)
   if ((_2._shape) is not None): # src/fusion/Model.mbi:1450:13-30
    if (int(((_2._shape)).shape[0])!=_7): # src/fusion/Model.mbi:1451:14-34
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
    else:
     for _16 in range(0,_7):
      if ((_2._shape)[_16]!=_4[(_8 + _16)]): # src/fusion/Model.mbi:1455:18-52
       raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _17=1
   for _18 in range(0,_7):
    _17 *= _4[(_8 + _18)]
   _19=self.__natconmap_1alloc_I(_17)
   _20=numpy.zeros((_17,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap.get(_19,_20,0)
   for _21 in range(0,_17):
    self.__natconmap_idx[_20[_21]] = _19
    self.__natconmap_slackidx[_20[_21]] = 0
   self.__natconmap_type[_19] = 4
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIIII_3I(_20,self.__rs,_9,_10,_12,_13,_15,_14,None)
   self.__xs.clear()
   _22=numpy.zeros((_17,), dtype=numpy.dtype(numpy.float64))
   _23=numpy.zeros((_17,), dtype=numpy.dtype(numpy.float64))
   _24=self.__natconmap_efix
   _25=(_2._lb)
   _26=(_2._ub)
   _27=(_2._empty)
   _28=(_2._scalable)
   _29=(_2._sparsity)
   for _30 in range(0,_9):
    _24[_20[_30]] = _6[(_14 + _30)]
   if _28: # src/fusion/Model.mbi:1491:14-19
    for _31 in range(0,_17):
     _22[_31] = _25[0]
     _23[_31] = _26[0]
   elif _27: # src/fusion/Model.mbi:1497:18-26
    pass
   elif (_29 is not None): # src/fusion/Model.mbi:1499:18-30
    _32=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
    _32[(_7 - 1)] = 1
    for _33 in range(1,_7):
     _32[((_7 - _33) - 1)] = (_32[(_7 - _33)] * _4[((_8 + _7) - _33)])
    for _34 in range(0,int((_25).shape[0])):
     _35=0
     for _36 in range(0,_7):
      _35 += (_32[_36] * _29[_34,_36])
     _22[_35] = _25[_34]
     _23[_35] = _26[_34]
   else:
    for _37 in range(0,_17):
     _22[_37] = _25[_37]
     _23[_37] = _26[_37]
   self._task_1con_1putboundlist_1ra__3I_3D_3D(_20,_22,_23)
   _38=mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4Model_2S_3I_3I(self,_0,numpy.array([_4[(_8 + _39)] for _39 in range(0,_7)], dtype=numpy.dtype(numpy.int32)),_20)
   self.__cons[_19] = _38
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1520:12-25
    self.__con_map._setItem_SI(_0,_19)
   return (_38)
  def _update_1bfix_alt__3I_3D(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._update_1bfix__3I_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _update_1bfix__3I_3D(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._task_1putaijlist__3I_3I_3DJ(_0,numpy.array([0 for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),_1,int((_0).shape[0]))
  def __putarows_alt__3ILmosek_4fusion_4WorkStack_2IIIIII_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.int32(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.int32))
   _1 = self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIIII_3I(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __putarows__3ILmosek_4fusion_4WorkStack_2IIIIII_3I(self,_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _8 is None or isinstance(_8,numpy.ndarray)
   _9=(_1.i32)
   _10=(_1.i64)
   _11=(_1.f64)
   _12=0
   _13=0
   _14=0
   for _15 in range(0,_2):
    _16=_9[(_4 + _15)]
    _17=_9[((_4 + _15) + 1)]
    _18=_16
    while ((_18 < _17) and (_10[(_5 + _18)] < 0)):
     _19=self.__natbarvar_idx[(- (_10[(_5 + _18)] + 1))]
     _20=_18
     _18 += 1
     while ((_18 < _17) and ((_10[(_5 + _18)] < 0) and (_19==self.__natbarvar_idx[(- (_10[(_5 + _18)] + 1))]))):
      _18 += 1
     _13 += 1
    _14 += (_18 - _16)
    _12 += (_17 - _18)
   _12 += _2
   if (_8 is not None): # src/fusion/Model.mbi:1181:12-25
    _12 += _2
   _21=int((_0).shape[0])
   _22=numpy.zeros(((_21 + 1),), dtype=numpy.dtype(numpy.int64))
   _23=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
   _24=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
   if (_8 is not None): # src/fusion/Model.mbi:1194:12-25
    _25=0
    for _26 in range(0,_2):
     _27=0
     _23[(_25 + _27)] = self.__bfixidx
     _24[(_25 + _27)] = _11[(_7 + _26)]
     _27 += 1
     for _28 in range(_9[(_4 + _26)],_9[((_4 + _26) + 1)]):
      if (_10[(_5 + _28)] > 0): # src/fusion/Model.mbi:1202:19-41
       _23[(_25 + _27)] = numpy.int32((_10[(_5 + _28)] - 1))
       _24[(_25 + _27)] = _11[(_6 + _28)]
       _27 += 1
     _23[(_25 + _27)] = _8[_26]
     _24[(_25 + _27)] = (- 1.0)
     _27 += 1
     _22[(_26 + 1)] = (_22[_26] + _27)
     _25 += _27
   else:
    _29=0
    for _30 in range(0,_2):
     _31=0
     _23[(_29 + _31)] = self.__bfixidx
     _24[(_29 + _31)] = _11[(_7 + _30)]
     _31 += 1
     for _32 in range(_9[(_4 + _30)],_9[((_4 + _30) + 1)]):
      if (_10[(_5 + _32)] > 0): # src/fusion/Model.mbi:1225:19-41
       _23[(_29 + _31)] = numpy.int32((_10[(_5 + _32)] - 1))
       _24[(_29 + _31)] = _11[(_6 + _32)]
       _31 += 1
     _22[(_30 + 1)] = (_22[_30] + _31)
     _29 += _31
   self._task_1putarowlist__3I_3J_3I_3D(_0,_22,_23,_24)
   if (_13 > 0): # src/fusion/Model.mbi:1241:12-22
    _33=_0
    _34=numpy.zeros(((_21 + 1),), dtype=numpy.dtype(numpy.int64))
    _35=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _36=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _37=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
    _38=numpy.zeros((_14,), dtype=numpy.dtype(numpy.int32))
    _39=numpy.zeros((_14,), dtype=numpy.dtype(numpy.int32))
    _40=numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
    _41=0
    _42=0
    for _43 in range(0,_21):
     _44=_9[(_4 + _43)]
     _45=_9[((_4 + _43) + 1)]
     while ((_44 < _45) and (_10[(_5 + _44)] < 0)):
      _46=_44
      _47=self.__natbarvar_idx[(- (_10[(_5 + _44)] + 1))]
      while ((_44 < _45) and ((_10[(_5 + _44)] < 0) and (self.__natbarvar_idx[(- (_10[(_5 + _44)] + 1))]==_47))):
       _38[_42] = self.__natbarvar_i[(- (_10[(_5 + _44)] + 1))]
       _39[_42] = self.__natbarvar_j[(- (_10[(_5 + _44)] + 1))]
       if (_38[_42]==_39[_42]): # src/fusion/Model.mbi:1265:20-60
        _40[_42] = _11[(_6 + _44)]
       else:
        _40[_42] = (0.5 * _11[(_6 + _44)])
       _42 += 1
       _44 += 1
      _35[_41] = _47
      _36[_41] = self.__natbarvar_dim[_47]
      _37[_41] = (_44 - _46)
      _41 += 1
     _44 = _45
     _34[(_43 + 1)] = _41
    _48=self._task_1appendsymmatlist__3I_3J_3I_3I_3D(_36,_37,_38,_39,_40)
    self._task_1putbararowlist__3I_3J_3I_3J(_33,_34,_35,_48)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   _3=_1.getShape()
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I(_3,(_2._shape)))): # src/fusion/Model.mbi:977:13-65
    raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   if (_2._axisIsSet): # src/fusion/Model.mbi:982:12-25
    _4 = ((_2._conedim1) < (_2._conedim2))
    _6 = ((_2._conedim1) if (_4 ) else (_2._conedim2))
    _5 = ((_2._conedim2) if (_4 ) else (_2._conedim1))
   else:
    _4 = True
    _6 = (int((_3).shape[0]) - 2)
    _5 = (int((_3).shape[0]) - 1)
   if ((_5 >= int((_3).shape[0])) or (_3[_6]!=_3[_5])): # src/fusion/Model.mbi:994:13-995:47
    raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _7=mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprDenseTril._ctor_IILmosek_4fusion_4Expression_2(_6,_5,(mosek_fusion_ExprSymmetrize._ctor_IILmosek_4fusion_4Expression_2(_6,_5,_1) if (((_2._key)==mosek.fusion.PSDKey.IsSymPSD) ) else _1)))
   _7.eval(self.__rs,self.__ws,self.__xs)
   _8=(self.__rs.i32)
   _9=(self.__rs.i64)
   _10=(self.__rs.f64)
   _11=self.__rs.popi32()
   _12=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   self.__rs.popi32(_11,_12,0)
   _13=self.__rs.popi32()
   _14=self.__rs.popi32()
   _15=(self.__rs.popi32()!=0)
   _16=self.__rs.popi32((_13 + 1))
   _17=(self.__rs.popi64(_13) if (_15 ) else (- 99999))
   _18=self.__rs.popi64(_14)
   _19=self.__rs.popf64(_13)
   _20=self.__rs.popf64(_14)
   _21=_12[_5]
   _22=((_21 * (_21 + 1)) // 2)
   for _23 in range(0,_11):
    if ((_23!=_6) and (_23!=_5)): # src/fusion/Model.mbi:1022:14-45
     _22 *= _12[_23]
   _24=self.__natconmap_1alloc_I(_22)
   _25=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap.get(_24,_25,0)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIIII_3I(_25,self.__rs,_13,_14,_16,_18,_20,_19,None)
   self.__xs.clear()
   _26=numpy.array([1,1,1,1,1], dtype=numpy.dtype(numpy.int32))
   for _27 in range(0,_6):
    _26[0] *= _12[_27]
   _26[1] = _12[_6]
   for _28 in range((_6 + 1),_5):
    _26[2] *= _12[_28]
   _26[3] = _12[_5]
   for _29 in range((_5 + 1),_11):
    _26[4] *= _12[_29]
   _30=numpy.zeros((5,), dtype=numpy.dtype(numpy.int32))
   _30[4] = 1
   for _31 in range(1,5):
    _30[((5 - _31) - 1)] = (_30[(5 - _31)] * _26[(5 - _31)])
   _32=numpy.zeros((_22,), dtype=numpy.dtype(numpy.float64))
   if (_17 < 0): # src/fusion/Model.mbi:1048:12-23
    raise mosek_fusion_UnexpectedError._ctor_S("Unexpected case!")
   else:
    for _33 in range(0,_13):
     self.__natconmap_efix[_25[_33]] = _10[(_19 + _33)]
     self.__natconmap_lb[_25[_33]] = 0
     self.__natconmap_ub[_25[_33]] = 0
     _32[_33] = 0.0
   self._task_1con_1putboundlist_1fx__3I_3D(_25,_32)
   _34=((_26[0] * _26[2]) * _26[4])
   _35=_26[1]
   _36=self.__natbarvarmap_1alloc_II(_34,_35)
   _37=numpy.zeros((_34,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_1get_I_3I(_36,_37)
   _38=numpy.array([_35 for _39 in range(0,((_35 * (_35 + 1)) // 2))], dtype=numpy.dtype(numpy.int32))
   _40=numpy.array([1 for _41 in range(0,((_35 * (_35 + 1)) // 2))], dtype=numpy.dtype(numpy.int64))
   _42=numpy.zeros((((_35 * (_35 + 1)) // 2),), dtype=numpy.dtype(numpy.int32))
   _43=numpy.zeros((((_35 * (_35 + 1)) // 2),), dtype=numpy.dtype(numpy.int32))
   _44=numpy.array([(- 0.5) for _45 in range(0,((_35 * (_35 + 1)) // 2))], dtype=numpy.dtype(numpy.float64))
   for _46 in range(1,(_35 + 1)):
    _44[(((_46 * (_46 + 1)) // 2) - 1)] = (- 1.0)
   _47=0
   for _48 in range(0,_35):
    for _49 in range(0,(_48 + 1)):
     _42[_47] = _48
     _43[_47] = _49
     _47 += 1
   _50=self._task_1appendsymmatlist__3I_3J_3I_3I_3D(_38,_40,_42,_43,_44)
   _51=_25
   _52=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
   _53=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int64))
   _54=0
   if _4: # src/fusion/Model.mbi:1097:14-18
    for _55 in range(0,_26[0]):
     for _56 in range(0,_26[1]):
      for _57 in range(0,_26[2]):
       for _58 in range(0,(_56 + 1)):
        for _59 in range(0,_26[4]):
         _53[_54] = _50[(((_56 * (_56 + 1)) // 2) + _58)]
         _52[_54] = _37[((((_55 * _26[2]) + _57) * _26[4]) + _59)]
         self.__natconmap_slackidx[_25[_54]] = ((- ((self.__natbarvar_ptr[_52[_54]] + ((_56 * (_56 + 1)) // 2)) + _58)) - 1)
         _54 += 1
   else:
    for _60 in range(0,_26[0]):
     for _61 in range(0,_26[1]):
      for _62 in range(0,_26[2]):
       for _63 in range(_61,_26[1]):
        for _64 in range(0,_26[4]):
         _53[_54] = _50[(((_63 * (_63 + 1)) // 2) + _61)]
         _52[_54] = _37[((((_60 * _26[2]) + _62) * _26[4]) + _64)]
         self.__natconmap_slackidx[_25[_54]] = ((- ((self.__natbarvar_ptr[_52[_54]] + ((_63 * (_63 + 1)) // 2)) + _61)) - 1)
         _54 += 1
   self._task_1putbaraijlist__3I_3I_3J(_51,_52,_53)
   self.__natconmap_type[_24] = (- (_36 + 1))
   _65=mosek_fusion_PSDConstraint._ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(self,_0,_24,_12,_6,_5,numpy.array([self.__natconmap_slackidx[_25[_66]] for _66 in range(0,_22)], dtype=numpy.dtype(numpy.int64)),_25)
   self.__cons[_24] = _65
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1132:12-25
    self.__con_map._setItem_SI(_0,_24)
   return (_65)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:861:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:867:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1))
   _3.eval(self.__rs,self.__ws,self.__xs)
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=self.__rs.popi32()
   _8=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   self.__rs.popi32(_7,_8,0)
   _9=self.__rs.popi32()
   _10=self.__rs.popi32()
   _11=(self.__rs.popi32()!=0)
   _12=self.__rs.popi32((_9 + 1))
   _13=self.__rs.popi64(_10)
   _14=self.__rs.popf64(_9)
   _15=self.__rs.popf64(_10)
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I(_8,(_2._shape)))): # src/fusion/Model.mbi:888:13-65
    raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _16=1
   for _17 in range(0,_7):
    _16 *= _8[_17]
   _18=(_2._conedim)
   _19=_8[_18]
   _20=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _19))) - 1) / 2))
   if (((_20 * (_20 + 1)) // 2)!=_19): # src/fusion/Model.mbi:896:12-32
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for semidefinite variable")
   _21=1
   for _22 in range(0,_18):
    _21 *= _8[_22]
   _23=1
   for _24 in range((_18 + 1),_7):
    _23 *= _8[_24]
   _25=(_21 * _23)
   _26=self.__natconmap_1alloc_I(_16)
   _27=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap.get(_26,_27,0)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIIII_3I(_27,self.__rs,_9,_10,_12,_13,_15,_14,None)
   _28=self.__natbarvarmap_1alloc_II(_25,_20)
   _29=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_1get_I_3I(_28,_29)
   self.__barvars[_28] = None
   _30=((_19 * _21) * _23)
   _31=numpy.array([_32 for _32 in range(0,_19)], dtype=numpy.dtype(numpy.int32))
   _33=numpy.array([1 for _34 in range(0,_19)], dtype=numpy.dtype(numpy.int64))
   _35=numpy.array([(- 0.5) for _36 in range(0,_19)], dtype=numpy.dtype(numpy.float64))
   for _37 in range(1,(_19 + 1)):
    _35[(((_37 * (_37 + 1)) // 2) - 1)] = (- 1.0)
   _38=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _39=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _40=numpy.zeros((_30,), dtype=numpy.dtype(numpy.int32))
   _41=0
   for _42 in range(0,_21):
    for _43 in range(0,_20):
     for _44 in range(0,(_43 + 1)):
      for _45 in range(0,_23):
       _40[_41] = ((_42 * _23) + _45)
       _38[_41] = _43
       _39[_41] = _44
       _41 += 1
   self.__natconmap_type[_26] = (- (_28 + 1))
   for _46 in range(0,_16):
    self.__natconmap_blockid[_27[_46]] = _26
    self.__natconmap_idx[_27[_46]] = _46
    self.__natconmap_efix[_27[_46]] = _6[(_14 + _46)]
    self.__natconmap_lb[_27[_46]] = 0
    self.__natconmap_ub[_27[_46]] = 0
   _47=self._task_1appendsymmatlist__3I_3J_3I_3I_3D(_31,_33,_38,_39,_35)
   self._task_1putbaraijlist__3I_3I_3J(_27,_40,_47)
   _48=numpy.array([0.0 for _49 in range(0,_16)], dtype=numpy.dtype(numpy.float64))
   self._task_1con_1putboundlist_1fx__3I_3D(_27,_48)
   _50=mosek_fusion_LinearPSDConstraint._ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(self,_0,_26,_8,_18,_27,numpy.array([self.__natconmap_slackidx[_27[_51]] for _51 in range(0,_16)], dtype=numpy.dtype(numpy.int64)))
   self.__cons[_26] = _50
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:964:12-25
    self.__con_map._setItem_SI(_0,_26)
   return (_50)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:721:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:724:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if (_2._int_flag): # src/fusion/Model.mbi:727:12-24
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1))
   _3.eval(self.__rs,self.__ws,self.__xs)
   self.__rs.pop_expr()
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=(self.__rs.nd)
   _8=(self.__rs.shape_base)
   _9=(self.__rs.nelem)
   _10=(self.__rs.nnz)
   _11=(self.__rs.hassp)
   _12=(self.__rs.ptr_base)
   _13=(self.__rs.nidxs_base)
   _14=(self.__rs.bfix_base)
   _15=(self.__rs.cof_base)
   _16=numpy.array([_4[(_8 + _17)] for _17 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I(_16,(_2._shape)))): # src/fusion/Model.mbi:752:13-65
    raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _18=(_2.getAxis() if (_2.axisIsSet() ) else (_7 - 1))
   _19=_16[_18]
   _20=1
   _21=1
   _22=1
   for _23 in range(0,_7):
    _22 *= _16[_23]
   for _24 in range(0,_18):
    _21 *= _16[_24]
   for _25 in range((_18 + 1),_7):
    _20 *= _16[_25]
   _26=(_21 * _20)
   if (((_2._key)==mosek.fusion.QConeKey.InQCone) and (_19 < 2)): # src/fusion/Model.mbi:770:12-63
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_19)._a_S(") for quadratic cone")._toString_())
   elif (((_2._key)==mosek.fusion.QConeKey.InRotatedQCone) and (_19 < 3)): # src/fusion/Model.mbi:772:16-67
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_19)._a_S(") for rotated quadratic cone")._toString_())
   elif (((_2._key)==mosek.fusion.QConeKey.InPExpCone) and (_19!=3)): # src/fusion/Model.mbi:774:16-68
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_19)._a_S(") for exponential cone")._toString_())
   elif (((_2._key)==mosek.fusion.QConeKey.InPPowCone) and (_19 < 2)): # src/fusion/Model.mbi:776:16-67
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_19)._a_S(") for power cone")._toString_())
   elif (((_2._key)==mosek.fusion.QConeKey.InDExpCone) and (_19!=3)): # src/fusion/Model.mbi:778:16-68
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_19)._a_S(") for dual exponential cone")._toString_())
   elif (((_2._key)==mosek.fusion.QConeKey.InDPowCone) and (_19 < 2)): # src/fusion/Model.mbi:780:16-67
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_19)._a_S(") for dual power cone")._toString_())
   _27=self.__natvarmap_1alloc_I(_22)
   _28=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap.get(_27,_28,0)
   _29=self.__natconemap_1alloc_I(_26)
   for _30 in range(0,_22):
    self.__natvarmap_idx[_28[_30]] = _27
   self._task_1var_1putboundlist_1fr__3I(_28)
   _31=(numpy.zeros((int((_28).shape[0]),), dtype=numpy.dtype(numpy.int32)) if ((_18 < (int((_16).shape[0]) - 1)) ) else _28)
   if (_18 < (int((_16).shape[0]) - 1)): # src/fusion/Model.mbi:794:12-35
    _32=0
    for _33 in range(0,_21):
     for _34 in range(0,_20):
      for _35 in range(0,_19):
       _31[_32] = _28[((((_33 * _19) + _35) * _20) + _34)]
       _32 += 1
   _36=numpy.zeros((_26,), dtype=numpy.dtype(numpy.int32))
   self.__natconemap.get(_29,_36,0)
   self.__natconemap_dim[_29] = _19
   if ((_2._key)==mosek.fusion.QConeKey.InQCone): # src/fusion/Model.mbi:809:16-43
    self._task_1put_1quadcones__3III_3I(_36,_19,_26,_31)
   elif ((_2._key)==mosek.fusion.QConeKey.InRotatedQCone): # src/fusion/Model.mbi:810:16-50
    self._task_1put_1rquadcones__3III_3I(_36,_19,_26,_31)
   elif ((_2._key)==mosek.fusion.QConeKey.InPExpCone): # src/fusion/Model.mbi:811:16-46
    self._task_1put_1pexpcones__3III_3I(_36,_19,_26,_31)
   elif ((_2._key)==mosek.fusion.QConeKey.InPPowCone): # src/fusion/Model.mbi:812:16-46
    self._task_1put_1ppowcones__3III_3I_3D(_36,_19,_26,_31,numpy.array([(_2._alpha) for _37 in range(0,_26)], dtype=numpy.dtype(numpy.float64)))
   elif ((_2._key)==mosek.fusion.QConeKey.InDExpCone): # src/fusion/Model.mbi:813:16-46
    self._task_1put_1dexpcones__3III_3I(_36,_19,_26,_31)
   elif ((_2._key)==mosek.fusion.QConeKey.InDPowCone): # src/fusion/Model.mbi:814:16-46
    self._task_1put_1dpowcones__3III_3I_3D(_36,_19,_26,_31,numpy.array([(_2._alpha) for _38 in range(0,_26)], dtype=numpy.dtype(numpy.float64)))
   else:
    raise mosek_fusion_UnexpectedError._ctor_S("Internal error: Invalid cone type")
   self.__vars[_27] = None
   _39=numpy.zeros((_22,), dtype=numpy.dtype(numpy.float64))
   _40=self.__natconmap_1alloc_I(_22)
   _41=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap.get(_40,_41,0)
   self.__natconmap_type[_40] = (_27 + 6)
   for _42 in range(0,_22):
    self.__natconmap_efix[_41[_42]] = _6[(_14 + _42)]
   for _43 in range(0,_22):
    self.__natconmap_lb[_41[_43]] = 0
   for _44 in range(0,_22):
    self.__natconmap_ub[_41[_44]] = 0
   for _45 in range(0,_22):
    self.__natconmap_slackidx[_41[_45]] = (_28[_45] + 1)
   for _46 in range(0,_22):
    self.__natconmap_blockid[_41[_46]] = _40
   for _47 in range(0,_22):
    self.__natconmap_idx[_41[_47]] = _47
   self._task_1con_1putboundlist_1fx__3I_3D(_41,_39)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIIII_3I(_41,self.__rs,_9,_10,_12,_13,_15,_14,_28)
   _48=mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(self,_0,_2,_16,_40,_41,_28)
   self.__cons[_40] = _48
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:850:12-25
    self.__con_map._setItem_SI(_0,_40)
   return (_48)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:591:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if (_2._cardinal_flag): # src/fusion/Model.mbi:594:12-29
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1))
   _3.eval(self.__rs,self.__ws,self.__xs)
   self.__rs.pop_expr()
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=(self.__rs.nd)
   _8=(self.__rs.shape_base)
   _9=(self.__rs.nelem)
   _10=(self.__rs.nnz)
   _11=(self.__rs.hassp)
   _12=(self.__rs.ptr_base)
   _13=(self.__rs.nidxs_base)
   _14=(self.__rs.bfix_base)
   _15=(self.__rs.cof_base)
   _16=numpy.array([_4[(_8 + _17)] for _17 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I(_16,(_2._shape)))): # src/fusion/Model.mbi:618:13-65
    raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _18=1
   for _19 in range(0,_7):
    _18 *= _16[_19]
   _21=self.__natconmap_1alloc_I(_18)
   _22=numpy.zeros((_18,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap.get(_21,_22,0)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIIII_3I(_22,self.__rs,_9,_10,_12,_13,_15,_14,None)
   _23=(_2._sparsity)
   _24=(_2._empty)
   _25=(_2._bnd)
   _26=(_2._scalable)
   _27=self.__natconmap_efix
   _28=self.__natconmap_lb
   _29=self.__natconmap_ub
   for _30 in range(0,_9):
    _27[_22[_30]] = _6[(_14 + _30)]
   if (_25 is None): # src/fusion/Model.mbi:644:16-30
    for _31 in range(0,_9):
     _28[_22[_31]] = 0
     _29[_22[_31]] = 0
   elif _26: # src/fusion/Model.mbi:649:20-31
    for _32 in range(0,_9):
     _28[_22[_32]] = _25[0]
     _29[_22[_32]] = _25[0]
   elif (_23 is not None): # src/fusion/Model.mbi:654:20-33
    _33=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
    _33[(_7 - 1)] = 1
    for _34 in range(1,_7):
     _33[((_7 - _34) - 1)] = (_33[(_7 - _34)] * _16[(_7 - _34)])
    for _35 in range(0,int((_23).shape[0])):
     _36=0
     for _37 in range(0,_7):
      _36 += (_33[_37] * _23[_35,_37])
     _28[_22[_36]] = _25[_35]
     _29[_22[_36]] = _25[_35]
   elif _24: # src/fusion/Model.mbi:663:20-28
    _38=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
    _38[(_7 - 1)] = 1
    for _39 in range(1,_7):
     _38[((_7 - _39) - 1)] = (_38[(_7 - _39)] * _16[(_7 - _39)])
    for _40 in range(0,int((_23).shape[0])):
     _41=0
     for _42 in range(0,_7):
      _41 += (_38[_42] * _23[_40,_42])
     _28[_22[_41]] = 0
     _29[_22[_41]] = 0
   else:
    for _43 in range(0,_9):
     _28[_22[_43]] = _25[_43]
     _29[_22[_43]] = _25[_43]
   _20 = numpy.array([_28[_22[_44]] for _44 in range(0,int((_22).shape[0]))], dtype=numpy.dtype(numpy.float64))
   for _45 in range(0,_18):
    self.__natconmap_idx[_22[_45]] = _21
    self.__natconmap_slackidx[_22[_45]] = 0
   if ((_2._key)==mosek.fusion.RelationKey.IsFree): # src/fusion/Model.mbi:687:17-46
    self.__natconmap_type[_21] = 1
    self._task_1con_1putboundlist_1fr__3I(_22)
   if ((_2._key)==mosek.fusion.RelationKey.LessThan): # src/fusion/Model.mbi:691:17-48
    self.__natconmap_type[_21] = 3
    self._task_1con_1putboundlist_1up__3I_3D(_22,_20)
   elif ((_2._key)==mosek.fusion.RelationKey.GreaterThan): # src/fusion/Model.mbi:695:17-51
    self.__natconmap_type[_21] = 2
    self._task_1con_1putboundlist_1lo__3I_3D(_22,_20)
   elif ((_2._key)==mosek.fusion.RelationKey.EqualsTo): # src/fusion/Model.mbi:699:17-48
    self.__natconmap_type[_21] = 5
    self._task_1con_1putboundlist_1fx__3I_3D(_22,_20)
   _46=mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4Model_2SI_3I_3I(self,_0,_21,_16,_22)
   self.__cons[_21] = _46
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:709:12-25
    self.__con_map._setItem_SI(_0,_21)
   return (_46)
  @staticmethod
  def _match_getVersion_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getVersion_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _getVersion_alt_():
    return mosek_fusion_Model._getVersion_()
  @staticmethod
  def _getVersion_():
   return (mosek.fusion.BaseModel._env_1getversion_())
  @staticmethod
  def _match_hasConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasConstraint_alt_S(self,_t__0):
    return self._hasConstraint_S(_0)
  def _hasConstraint_S(self,_0):
   return (self.__con_map._hasItem_S(_0))
  @staticmethod
  def _match_hasVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasVariable_alt_S(self,_t__0):
    return self._hasVariable_S(_0)
  def _hasVariable_S(self,_0):
   return (self.__var_map._hasItem_S(_0))
  @staticmethod
  def _match_getConstraint_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getConstraint_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getConstraint_alt_I(self,_t__0):
    return self._getConstraint_I(numpy.int32(__0))
  def _getConstraint_I(self,_0):
   return (self.__cons[_0])
  @staticmethod
  def _match_getConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getConstraint_alt_S(self,_t__0):
    return self._getConstraint_S(_0)
  def _getConstraint_S(self,_0):
   return ((self.__cons[self.__con_map._getItem_S(_0)] if (self.__con_map._hasItem_S(_0) ) else None))
  @staticmethod
  def _match_getVariable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getVariable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getVariable_alt_I(self,_t__0):
    return self._getVariable_I(numpy.int32(__0))
  def _getVariable_I(self,_0):
   return (self.__vars[_0])
  @staticmethod
  def _match_getVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getVariable_alt_S(self,_t__0):
    return self._getVariable_S(_0)
  def _getVariable_S(self,_0):
   if self.__var_map._hasItem_S(_0): # src/fusion/Model.mbi:557:12-33
    _1=self.__var_map._getItem_S(_0)
    if (_1 < 0): # src/fusion/Model.mbi:559:14-23
     return (self.__barvars[(- (_1 + 1))])
    else:
     return (self.__vars[_1])
   else:
    return (None)
  @staticmethod
  def _match_getName_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getName_(*args):
    if len(args) != 0: return False
    return True
  def _getName_alt_(self,):
    return self._getName_()
  def _getName_(self,):
   return (self.__model_name)
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_Model._ctor_Lmosek_4fusion_4Model_2(self))
 return Model
mosek_fusion_Model=__mk_mosek_fusion_Model()
del __mk_mosek_fusion_Model
def __mk_mosek_fusion_Debug():
  class Debug:
    @staticmethod 
    def _o_(): return Debug()
    def p(self,v): 
      sys.stdout.write(str(v))
      return self
    _p_S = p
    _p_I = p
    _p_J = p
    _p_D = p
    _p_Z = p
  
    def p_array (self,v):
      if v is None:
          sys.stdout.write('None')
      else:
          sys.stdout.write('[ %s ]' % ','.join([str(i) for i in v]))
      return self
  
    _p__3I = p_array
    _p__3J = p_array
    _p__3D = p_array
  
    def _lf_(self): 
      sys.stdout.write("\n")
      return self
  
  return Debug
mosek_fusion_Debug=__mk_mosek_fusion_Debug()
#BEFORE CLASS
def __mk_mosek_fusion_Sort():
 class Sort(object):
  @staticmethod
  def getminmax(*args):
    if False: pass
    elif mosek_fusion_Sort._match_getminmax__3J_3I_3IJJ_3I(*args): # []int64,[]int32,[]int32,int64,int64,[]int32
      return mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3I_3IJJ_3I(*args): # []int64,[]int32,[]int32,int64,int64,[]int32
      return mosek_fusion_Sort._getminmax_alt__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_getminmax__3J_3J_3JJJ_3J(*args): # []int64,[]int64,[]int64,int64,int64,[]int64
      return mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3J_3JJJ_3J(*args): # []int64,[]int64,[]int64,int64,int64,[]int64
      return mosek_fusion_Sort._getminmax_alt__3J_3J_3JJJ_3J(*args)
    else:
      raise ValueError('Invalid argument list getminmax('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,array(int32,ndim=1))\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,array(int64,ndim=1))')
  @staticmethod
  def argsort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argsort__3J_3J(*args): # []int64,[]int64
      return mosek_fusion_Sort._argsort__3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J(*args): # []int64,[]int64
      return mosek_fusion_Sort._argsort_alt__3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I(*args): # []int64,[]int32
      return mosek_fusion_Sort._argsort__3J_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I(*args): # []int64,[]int32
      return mosek_fusion_Sort._argsort_alt__3J_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3I(*args): # []int64,[]int32,[]int32
      return mosek_fusion_Sort._argsort__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3I(*args): # []int64,[]int32,[]int32
      return mosek_fusion_Sort._argsort_alt__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3J(*args): # []int64,[]int64,[]int64
      return mosek_fusion_Sort._argsort__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3J(*args): # []int64,[]int64,[]int64
      return mosek_fusion_Sort._argsort_alt__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJ(*args): # []int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJ(*args): # []int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJ(*args): # []int64,[]int32,int64,int64
      return mosek_fusion_Sort._argsort__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJ(*args): # []int64,[]int32,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_Sort._argsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list argsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  @staticmethod
  def argbucketsort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argbucketsort__3J_3IJJII(*args): # []int64,[]int32,int64,int64,int32,int32
      return mosek_fusion_Sort._argbucketsort__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3IJJII(*args): # []int64,[]int32,int64,int64,int32,int32
      return mosek_fusion_Sort._argbucketsort_alt__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_argbucketsort__3J_3JJJJJ(*args): # []int64,[]int64,int64,int64,int64,int64
      return mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3JJJJJ(*args): # []int64,[]int64,int64,int64,int64,int64
      return mosek_fusion_Sort._argbucketsort_alt__3J_3JJJJJ(*args)
    else:
      raise ValueError('Invalid argument list argbucketsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,int32,int32)\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,int64,int64)')
  @staticmethod
  def issorted(*args):
    if False: pass
    elif mosek_fusion_Sort._match_issorted__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list issorted('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  @staticmethod
  def argTransposeSort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argTransposeSort__3J_3JIII_3J(*args): # []int64,[]int64,int32,int32,int32,[]int64
      return mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(*args)
    elif mosek_fusion_Sort._match_alt_argTransposeSort__3J_3JIII_3J(*args): # []int64,[]int64,int32,int32,int32,[]int64
      return mosek_fusion_Sort._argTransposeSort_alt__3J_3JIII_3J(*args)
    else:
      raise ValueError('Invalid argument list argTransposeSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argTransposeSort(array(int64,ndim=1),array(int64,ndim=1),int32,int32,int32,array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Sort'
  @staticmethod
  def _match_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match__3J__(_5))
  @staticmethod
  def _match_alt_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match__3J__(_5))
  @staticmethod
  def _argTransposeSort_alt__3J_3JIII_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argTransposeSort__3J_3JIII_3J(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   for _6 in range(0,((_2 * _4) + 1)):
    _1[_6] = 0
   for _7 in range(0,int((_5).shape[0])):
    _1[((((_5[_0[_7]] // (_3 * _4)) * _4) + (_5[_0[_7]] % _4)) + 1)] += 1
   for _8 in range(0,(_2 * _4)):
    _1[(_8 + 1)] = (_1[(_8 + 1)] + _1[_8])
   _9=numpy.array([_0[_10] for _10 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   for _11 in range(0,int((_5).shape[0])):
    _12=(((_5[_9[_11]] // (_3 * _4)) * _4) + (_5[_9[_11]] % _4))
    _0[_1[_12]] = _9[_11]
    _1[_12] += 1
  @staticmethod
  def _match_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1))
  @staticmethod
  def _argsort_alt__3J_3J(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argsort__3J_3J(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3JJJZ(_0,_1,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _argsort_alt__3J_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._argsort__3J_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3IJJZ(_0,_1,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2))
  @staticmethod
  def _match_alt_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2))
  @staticmethod
  def _argsort_alt__3J_3J_3J(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argsort__3J_3J_3J(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3J(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _argsort_alt__3J_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._argsort__3J_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3))
  @staticmethod
  def _match_alt_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3))
  @staticmethod
  def _argsort_alt__3J_3JJJ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _1 = mosek_fusion_Sort._argsort__3J_3JJJ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3JJJ(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3JJJZ(_0,_1,_2,_3,False)
  @staticmethod
  def _match_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3))
  @staticmethod
  def _match_alt_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3))
  @staticmethod
  def _argsort_alt__3J_3IJJ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _1 = mosek_fusion_Sort._argsort__3J_3IJJ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3IJJ(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3IJJZ(_0,_1,_2,_3,False)
  @staticmethod
  def _match_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_Sort._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,False)
  @staticmethod
  def _match_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_Sort._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,False)
  @staticmethod
  def _match_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _argsort_alt__3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._argsort__3J_3JJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3JJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((not _4) or ((_3 - _2) < 16)): # src/fusion/Sort.mbi:158:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_2,_3)
   elif (not mosek.fusion.Sort._issorted__3J_3JJJZ(_0,_1,_2,_3,_4)): # src/fusion/Sort.mbi:160:16-56
    _5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _6=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,None,_2,_3,_5)
    if ((_5[1] - _5[0]) < (_6 * (_3 - _2))): # src/fusion/Sort.mbi:166:14-54
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_5[0],_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_2,_3)
  @staticmethod
  def _match_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _argsort_alt__3J_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._argsort__3J_3IJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3IJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((not _4) or ((_3 - _2) < 16)): # src/fusion/Sort.mbi:139:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_2,_3)
   elif (not mosek.fusion.Sort._issorted__3J_3IJJZ(_0,_1,_2,_3,_4)): # src/fusion/Sort.mbi:141:16-56
    _5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _6=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,None,_2,_3,_5)
    if ((_5[1] - _5[0]) < (_6 * (_3 - _2))): # src/fusion/Sort.mbi:147:14-54
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_1,_2,_3,_5[0],_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_2,_3)
  @staticmethod
  def _match_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((not _5) or ((_4 - _3) < 16)): # src/fusion/Sort.mbi:118:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   elif (not mosek.fusion.Sort._issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)): # src/fusion/Sort.mbi:120:16-62
    _6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _7=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_6)
    if (((_6[1] - _6[0]) < (_7 * (_4 - _3))) and ((_6[3] - _6[2]) < (_7 * (_4 - _3)))): # src/fusion/Sort.mbi:126:14-127:54
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_2,_3,_4,_6[2],_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_1,_3,_4,_6[0],_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((not _5) or ((_4 - _3) < 16)): # src/fusion/Sort.mbi:97:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   elif (not mosek.fusion.Sort._issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)): # src/fusion/Sort.mbi:99:16-62
    _6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _7=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_6)
    if (((_6[1] - _6[0]) < (_7 * (_4 - _3))) and ((_6[3] - _6[2]) < (_7 * (_4 - _3)))): # src/fusion/Sort.mbi:105:14-106:54
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_2,_3,_4,_6[2],_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_1,_3,_4,_6[0],_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_J__(_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_J__(_5))
  @staticmethod
  def _argbucketsort_alt__3J_3JJJJJ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.int64(_t__5)
   _1 = mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3JJJ(_0,_2,_3,_1,_4,_5)
  @staticmethod
  def _match_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5))
  @staticmethod
  def _argbucketsort_alt__3J_3IJJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_Sort._argbucketsort__3J_3IJJII(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argbucketsort__3J_3IJJII(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3III(_0,_2,_3,_1,_4,_5)
  @staticmethod
  def _match_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3J__(_5))
  @staticmethod
  def _match_alt_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3J__(_5))
  @staticmethod
  def _getminmax_alt__3J_3J_3JJJ_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _5[0] = _1[_0[_3]]
   _5[1] = _1[_0[_3]]
   for _6 in range((_3 + 1),_4):
    if (_5[0] > _1[_0[_6]]): # src/fusion/Sort.mbi:67:14-36
     _5[0] = _1[_0[_6]]
    if (_5[1] < _1[_0[_6]]): # src/fusion/Sort.mbi:68:14-36
     _5[1] = _1[_0[_6]]
   if (_2 is not None): # src/fusion/Sort.mbi:70:12-25
    _5[2] = _2[_0[_3]]
    _5[3] = _2[_0[_3]]
    for _7 in range((_3 + 1),_4):
     if (_5[2] > _2[_0[_7]]): # src/fusion/Sort.mbi:76:16-38
      _5[2] = _2[_0[_7]]
     if (_5[3] < _2[_0[_7]]): # src/fusion/Sort.mbi:77:16-38
      _5[3] = _2[_0[_7]]
  @staticmethod
  def _match_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5))
  @staticmethod
  def _match_alt_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5))
  @staticmethod
  def _getminmax_alt__3J_3I_3IJJ_3I(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _5[0] = _1[_0[_3]]
   _5[1] = _1[_0[_3]]
   for _6 in range((_3 + 1),_4):
    if (_5[0] > _1[_0[_6]]): # src/fusion/Sort.mbi:46:14-36
     _5[0] = _1[_0[_6]]
    if (_5[1] < _1[_0[_6]]): # src/fusion/Sort.mbi:47:14-36
     _5[1] = _1[_0[_6]]
   if (_2 is not None): # src/fusion/Sort.mbi:49:12-25
    _5[2] = _2[_0[_3]]
    _5[3] = _2[_0[_3]]
    for _7 in range((_3 + 1),_4):
     if (_5[2] > _2[_0[_7]]): # src/fusion/Sort.mbi:55:16-38
      _5[2] = _2[_0[_7]]
     if (_5[3] < _2[_0[_7]]): # src/fusion/Sort.mbi:56:16-38
      _5[3] = _2[_0[_7]]
  @staticmethod
  def _match_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _issorted_alt__3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._issorted__3J_3JJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3JJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   for _5 in range(_2,(_3 - 1)):
    if (_1[_0[_5]] > _1[_0[(_5 + 1)]]): # src/fusion/Sort.mbi:35:14-45
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _issorted_alt__3J_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._issorted__3J_3IJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3IJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   for _5 in range(_2,(_3 - 1)):
    if (_1[_0[_5]] > _1[_0[(_5 + 1)]]): # src/fusion/Sort.mbi:27:14-45
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _issorted_alt__3J_3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   for _6 in range(_3,(_4 - 1)):
    if ((_1[_0[_6]] > _1[_0[(_6 + 1)]]) or ((_1[_0[(_6 + 1)]]==_1[_0[_6]]) and (_2[_0[_6]] > _2[_0[(_6 + 1)]]))): # src/fusion/Sort.mbi:19:14-119
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _issorted_alt__3J_3I_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   for _6 in range(_3,(_4 - 1)):
    if ((_1[_0[_6]] > _1[_0[(_6 + 1)]]) or ((_1[_0[_6]]==_1[_0[(_6 + 1)]]) and (_2[_0[_6]] > _2[_0[(_6 + 1)]]))): # src/fusion/Sort.mbi:11:14-119
     return (False)
   return (True)
 return Sort
mosek_fusion_Sort=__mk_mosek_fusion_Sort()
del __mk_mosek_fusion_Sort
#BEFORE CLASS
def __mk_mosek_fusion_IndexCounter():
 class IndexCounter(object):
  __slots__ = ['_IndexCounter__start','_IndexCounter__dims','_IndexCounter__strides','_IndexCounter__st','_IndexCounter__ii','_IndexCounter__n']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I(*args): # []int32
      self._ctor_init__3I(*args)
    elif self.__match_alt_ctor__3I(*args):# []int32
      self._ctor_alt_init__3I(*args)
    elif self.__match_ctor_J_3I_3I(*args): # int64,[]int32,[]int32
      self._ctor_init_J_3I_3I(*args)
    elif self.__match_alt_ctor_J_3I_3I(*args):# int64,[]int32,[]int32
      self._ctor_alt_init_J_3I_3I(*args)
    elif self.__match_ctor_J_3I_3J(*args): # int64,[]int32,[]int64
      self._ctor_init_J_3I_3J(*args)
    elif self.__match_alt_ctor_J_3I_3J(*args):# int64,[]int32,[]int64
      self._ctor_alt_init_J_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexCounter.ctor(array(int32,ndim=1))\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),array(int64,ndim=1))')
  def atEnd(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_atEnd_(*args): # 
      return self._atEnd_(*args)
    elif mosek_fusion_IndexCounter._match_alt_atEnd_(*args): # 
      return self._atEnd_alt_(*args)
    else:
      raise ValueError('Invalid argument list atEnd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.atEnd()')
  def reset(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_reset_(*args): # 
      return self._reset_(*args)
    elif mosek_fusion_IndexCounter._match_alt_reset_(*args): # 
      return self._reset_alt_(*args)
    else:
      raise ValueError('Invalid argument list reset('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.reset()')
  def next(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_next_(*args): # 
      return self._next_(*args)
    elif mosek_fusion_IndexCounter._match_alt_next_(*args): # 
      return self._next_alt_(*args)
    else:
      raise ValueError('Invalid argument list next('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.next()')
  def inc(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_inc_(*args): # 
      return self._inc_(*args)
    elif mosek_fusion_IndexCounter._match_alt_inc_(*args): # 
      return self._inc_alt_(*args)
    else:
      raise ValueError('Invalid argument list inc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.inc()')
  def getIndex(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_getIndex_(*args): # 
      return self._getIndex_(*args)
    elif mosek_fusion_IndexCounter._match_alt_getIndex_(*args): # 
      return self._getIndex_alt_(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.getIndex()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_get_(*args): # 
      return self._get_(*args)
    elif mosek_fusion_IndexCounter._match_alt_get_(*args): # 
      return self._get_alt_(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.get()')
  def __repr__(self): return 'mosek.fusion.IndexCounter'
  @staticmethod
  def _ctor__3I(shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   assert shape is None or isinstance(shape,numpy.ndarray)
   self.__n = int((shape).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   self.__start = 0
   self.__strides = mosek.fusion.Set._strides__3I(shape)
   self.__dims = numpy.array([shape[_0] for _0 in range(0,int((shape).shape[0]))], dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_J_3I_3I(start_,dims_,shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3I_3I(start_,dims_,shape)
    return o
  @staticmethod
  def __match_ctor_J_3I_3I(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor_J_3I_3I(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match__3I__(shape))
  def _ctor_alt_init_J_3I_3I(self,start_,dims_,shape):
    self._ctor_init_J_3I_3I(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_J_3I_3I(self,start_,dims_,shape):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert shape is None or isinstance(shape,numpy.ndarray)
   _0=int((shape).shape[0])
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   for _1 in range(0,self.__n):
    self.__st[_1] = start_
   self.__strides = mosek.fusion.Set._strides__3I(shape)
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _ctor_J_3I_3J(start_,dims_,strides_):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3I_3J(start_,dims_,strides_)
    return o
  @staticmethod
  def __match_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match__3J__(strides_))
  @staticmethod
  def __match_alt_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(strides_))
  def _ctor_alt_init_J_3I_3J(self,start_,dims_,strides_):
    self._ctor_init_J_3I_3J(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_J_3I_3J(self,start_,dims_,strides_):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert strides_ is None or isinstance(strides_,numpy.ndarray)
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   for _0 in range(0,self.__n):
    self.__st[_0] = start_
   self.__strides = strides_
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _match_atEnd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_atEnd_(*args):
    if len(args) != 0: return False
    return True
  def _atEnd_alt_(self,):
    return self._atEnd_()
  def _atEnd_(self,):
   return ((self.__ii[(self.__n - 1)] >= self.__dims[(self.__n - 1)]))
  @staticmethod
  def _match_getIndex_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getIndex_(*args):
    if len(args) != 0: return False
    return True
  def _getIndex_alt_(self,):
    return self._getIndex_()
  def _getIndex_(self,):
   return (self.__ii)
  @staticmethod
  def _match_next_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_next_(*args):
    if len(args) != 0: return False
    return True
  def _next_alt_(self,):
    return self._next_()
  def _next_(self,):
   _0=self.get()
   self.inc()
   return numpy.int64(_0)
  @staticmethod
  def _match_get_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_(*args):
    if len(args) != 0: return False
    return True
  def _get_alt_(self,):
    return self._get_()
  def _get_(self,):
   return numpy.int64(self.__st[0])
  @staticmethod
  def _match_inc_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inc_(*args):
    if len(args) != 0: return False
    return True
  def _inc_alt_(self,):
    return self._inc_()
  def _inc_(self,):
   self.__ii[0] += 1
   self.__st[0] = (self.__st[0] + self.__strides[(self.__n - 1)])
   _0 = 0
   while ((_0 < (self.__n - 1)) and (self.__ii[_0]==self.__dims[((self.__n - _0) - 1)])):
    self.__ii[_0] = 0
    self.__ii[(_0 + 1)] += 1
    self.__st[(_0 + 1)] = (self.__st[(_0 + 1)] + self.__strides[((self.__n - _0) - 2)])
    _0 += 1
   for _1 in range(0,_0):
    self.__st[_1] = self.__st[_0]
  @staticmethod
  def _match_reset_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_reset_(*args):
    if len(args) != 0: return False
    return True
  def _reset_alt_(self,):
    return self._reset_()
  def _reset_(self,):
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   for _0 in range(0,self.__n):
    self.__st[_0] = self.__start
 return IndexCounter
mosek_fusion_IndexCounter=__mk_mosek_fusion_IndexCounter()
del __mk_mosek_fusion_IndexCounter
#BEFORE CLASS
def __mk_mosek_fusion_CommonTools():
 class CommonTools(object):
  @staticmethod
  def argQsort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_argQsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_CommonTools._argQsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_argQsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_CommonTools._argQsort_alt__3J_3J_3JJJ(*args)
    else:
      raise ValueError('Invalid argument list argQsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)')
  @staticmethod
  def binarySearchL(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearchL__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchL__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearchL__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchL_alt__3JJ(*args)
    else:
      raise ValueError('Invalid argument list binarySearchL('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearchL(array(int64,ndim=1),int64)')
  @staticmethod
  def binarySearchR(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearchR__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchR__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearchR__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchR_alt__3JJ(*args)
    else:
      raise ValueError('Invalid argument list binarySearchR('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearchR(array(int64,ndim=1),int64)')
  @staticmethod
  def ndIncr(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_ndIncr__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return mosek_fusion_CommonTools._ndIncr__3I_3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_ndIncr__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return mosek_fusion_CommonTools._ndIncr_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list ndIncr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.ndIncr(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def argMSort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_argMSort__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_CommonTools._argMSort__3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_argMSort__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_CommonTools._argMSort_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list argMSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argMSort(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def binarySearch(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearch__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearch__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearch__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearch_alt__3JJ(*args)
    elif mosek_fusion_CommonTools._match_binarySearch__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._binarySearch__3II(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearch__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._binarySearch_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list binarySearch('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearch(array(int64,ndim=1),int64)\n\tmosek.fusion.CommonTools.binarySearch(array(int32,ndim=1),int32)')
  @staticmethod
  def transposeTriplets(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args): # []int32,[]int32,[]double,[][]int64,[][]int64,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args): # []int32,[]int32,[]double,[][]int64,[][]int64,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list transposeTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int64,ndim=1),ndim=1),array(array(int64,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  @staticmethod
  def resize(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_resize__3DI(*args): # []double,int32
      return mosek_fusion_CommonTools._resize__3DI(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3DI(*args): # []double,int32
      return mosek_fusion_CommonTools._resize_alt__3DI(*args)
    elif mosek_fusion_CommonTools._match_resize__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._resize__3II(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._resize_alt__3II(*args)
    elif mosek_fusion_CommonTools._match_resize__3JI(*args): # []int64,int32
      return mosek_fusion_CommonTools._resize__3JI(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3JI(*args): # []int64,int32
      return mosek_fusion_CommonTools._resize_alt__3JI(*args)
    else:
      raise ValueError('Invalid argument list resize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.resize(array(double,ndim=1),int32)\n\tmosek.fusion.CommonTools.resize(array(int32,ndim=1),int32)\n\tmosek.fusion.CommonTools.resize(array(int64,ndim=1),int32)')
  @staticmethod
  def tripletSort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list tripletSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.tripletSort(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  def __repr__(self): return 'mosek.fusion.CommonTools'
  @staticmethod
  def _match_resize__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_resize__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _resize_alt__3JI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._resize__3JI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _resize__3JI(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_1==int((_0).shape[0])): # src/fusion/CommonUtil.mbi:434:12-34
    return (_0)
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
    if (_1 > int((_0).shape[0])): # src/fusion/CommonUtil.mbi:438:14-35
     mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_0,0,_2,0,int((_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_0,0,_2,0,_1)
    return (_2)
  @staticmethod
  def _match_resize__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_resize__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _resize_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._resize__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _resize__3II(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_1==int((_0).shape[0])): # src/fusion/CommonUtil.mbi:422:12-34
    return (_0)
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    if (_1 > int((_0).shape[0])): # src/fusion/CommonUtil.mbi:426:14-35
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,0,_2,0,int((_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,0,_2,0,_1)
    return (_2)
  @staticmethod
  def _match_resize__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_resize__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _resize_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._resize__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _resize__3DI(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_1==int((_0).shape[0])): # src/fusion/CommonUtil.mbi:410:12-34
    return (_0)
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    if (_1 > int((_0).shape[0])): # src/fusion/CommonUtil.mbi:414:14-35
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_0,0,_2,0,int((_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_0,0,_2,0,_1)
    return (_2)
  @staticmethod
  def _match_binarySearch__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_binarySearch__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _binarySearch_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearch__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearch__3II(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=0
   _3=int((_0).shape[0])
   if (_0[_2]==_1): # src/fusion/CommonUtil.mbi:395:12-32
    return numpy.int32(_2)
   elif (_0[(_3 - 1)]==_1): # src/fusion/CommonUtil.mbi:396:16-38
    return numpy.int32((_3 - 1))
   while (_2 < (_3 - 1)):
    _4=((_3 - _2) // 2)
    if (_1 < _0[_4]): # src/fusion/CommonUtil.mbi:399:14-32
     _2 = (_4 + 1)
    elif (_1 > _0[_4]): # src/fusion/CommonUtil.mbi:401:18-36
     _3 = _4
    else:
     return numpy.int32(_4)
   return numpy.int32((- 1))
  @staticmethod
  def _match_binarySearch__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_binarySearch__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _binarySearch_alt__3JJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearch__3JJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearch__3JJ(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=mosek.fusion.CommonTools._binarySearchL__3JJ(_0,_1)
   if ((_2 < int((_0).shape[0])) and (_0[_2]==_1)): # src/fusion/CommonUtil.mbi:385:12-51
    return numpy.int32(_2)
   else:
    return numpy.int32((- 1))
  @staticmethod
  def _match_binarySearchR__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_binarySearchR__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _binarySearchR_alt__3JJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearchR__3JJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearchR__3JJ(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=0
   _3=int((_0).shape[0])
   if (_0[_2] > _1): # src/fusion/CommonUtil.mbi:371:12-31
    return numpy.int32(_2)
   while (_2 < (_3 - 1)):
    _4=((_3 + _2) // 2)
    if (_1 >= _0[_4]): # src/fusion/CommonUtil.mbi:375:14-33
     _2 = _4
    else:
     _3 = _4
   return numpy.int32(_3)
  @staticmethod
  def _match_binarySearchL__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_binarySearchL__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _binarySearchL_alt__3JJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearchL__3JJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearchL__3JJ(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=0
   _3=int((_0).shape[0])
   if (_1 <= _0[_2]): # src/fusion/CommonUtil.mbi:354:12-32
    return numpy.int32(_2)
   while (_2 < (_3 - 1)):
    _4=((_3 + _2) // 2)
    if (_0[_4] < _1): # src/fusion/CommonUtil.mbi:358:14-32
     _2 = _4
    else:
     _3 = _4
   return numpy.int32(_3)
  @staticmethod
  def _match_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _ndIncr_alt__3I_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_CommonTools._ndIncr__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ndIncr__3I_3I_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=(int((_0).shape[0]) - 1)
   _0[_3] += 1
   while ((_3 > 0) and (_0[_3] >= _2[_3])):
    _0[_3] = _1[_3]
    _0[(_3 - 1)] += 1
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3J__(_3) and __arg_match__3_3J__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3J__(_3) and __arg_alt_match__3_3J__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int64))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int64))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _9=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   _11=0
   while (_11 < _6):
    _10[(_1[_11] + 2)] = (_10[(_1[_11] + 2)] + 1)
    _9[(_0[_11] + 2)] = (_9[(_0[_11] + 2)] + 1)
    _11 += 1
   _12=1
   while (_12 < _7):
    _9[(_12 + 1)] = (_9[(_12 + 1)] + _9[_12])
    _12 += 1
   _13=1
   while (_13 < _8):
    _10[(_13 + 1)] = (_10[(_13 + 1)] + _10[_13])
    _13 += 1
   _14=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _15=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _16=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   for _17 in range(0,_7):
    _18=_9[_17]
    while (_18 < _9[(_17 + 1)]):
     _19=_1[_18]
     _20=_10[_19]
     _14[_20] = _17
     _15[_20] = _19
     _16[_20] = _2[_18]
     _10[_19] = (_20 + 1)
     _18 += 1
   _3[0] = _15
   _4[0] = _14
   _5[0] = _16
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3I__(_3) and __arg_match__3_3I__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3I__(_3) and __arg_alt_match__3_3I__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int32))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int32))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _9=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   _11=0
   while (_11 < _6):
    _10[(_1[_11] + 2)] = (_10[(_1[_11] + 2)] + 1)
    _9[(_0[_11] + 2)] = (_9[(_0[_11] + 2)] + 1)
    _11 += 1
   _12=1
   while (_12 < _7):
    _9[(_12 + 1)] = (_9[(_12 + 1)] + _9[_12])
    _12 += 1
   _13=1
   while (_13 < _8):
    _10[(_13 + 1)] = (_10[(_13 + 1)] + _10[_13])
    _13 += 1
   _14=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _15=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _16=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   _17=0
   while (_17 < _7):
    for _18 in range(_9[_17],_9[(_17 + 1)]):
     _19=_1[_18]
     _20=_10[_19]
     _14[_20] = _17
     _15[_20] = _19
     _16[_20] = _2[_18]
     _10[_19] = (_20 + 1)
    _17 += 1
   _3[0] = _15
   _4[0] = _14
   _5[0] = _16
  @staticmethod
  def _match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3I__(_3) and __arg_match__3_3I__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3I__(_3) and __arg_alt_match__3_3I__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int32))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int32))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _9=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   for _11 in range(0,_6):
    _10[(_1[_11] + 2)] = (_10[(_1[_11] + 2)] + 1)
   for _12 in range(1,_8):
    _10[(_12 + 1)] = (_10[(_12 + 1)] + _10[_12])
   for _13 in range(0,numpy.int32(_6)):
    _14=_1[_13]
    _9[_10[(_14 + 1)]] = _13
    _10[(_14 + 1)] = (_10[(_14 + 1)] + 1)
   _15=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _16=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _17=0
   while (_17 < _6):
    _15[(_0[_17] + 2)] = (_15[(_0[_17] + 2)] + 1)
    _17 += 1
   _18=1
   while (_18 < _7):
    _15[(_18 + 1)] = (_15[(_18 + 1)] + _15[_18])
    _18 += 1
   _19=0
   while (_19 < _8):
    _20=_10[_19]
    while (_20 < _10[(_19 + 1)]):
     _21=_0[_9[_20]]
     _16[_15[(_21 + 1)]] = _9[_20]
     _15[(_21 + 1)] = (_15[(_21 + 1)] + 1)
     _20 += 1
    _19 += 1
   _22=1
   _23=_0[_16[0]]
   _24=_1[_16[0]]
   _25=1
   while (_25 < _6):
    _26=_16[_25]
    if ((_23!=_0[_26]) or (_24!=_1[_26])): # src/fusion/CommonUtil.mbi:169:16-170:31
     _23 = _0[_26]
     _24 = _1[_26]
     _22 += 1
    _25 += 1
   _27=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
   _28=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
   _29=numpy.zeros((_22,), dtype=numpy.dtype(numpy.float64))
   _30=_16[0]
   _27[0] = _0[_30]
   _28[0] = _1[_30]
   _29[0] = _2[_30]
   _31=1
   for _32 in range(1,_6):
    _33=_16[_32]
    if ((_27[(_31 - 1)]==_0[_33]) and (_28[(_31 - 1)]==_1[_33])): # src/fusion/CommonUtil.mbi:197:14-198:38
     _29[(_31 - 1)] = (_29[(_31 - 1)] + _2[_33])
    else:
     _27[_31] = _0[_33]
     _28[_31] = _1[_33]
     _29[_31] = _2[_33]
     _31 += 1
   _3[0] = _27
   _4[0] = _28
   _5[0] = _29
  @staticmethod
  def _match_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _argMSort_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_CommonTools._argMSort__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argMSort__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _3=False
   _4=1
   while (_4 < int((_0).shape[0])):
    _3 = (not _3)
    for _5 in range(0,int((_0).shape[0]),(_4 * 2)):
     if _3: # src/fusion/CommonUtil.mbi:79:16-19
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_0,_2,_1,_5,(_5 + _4),(_5 + (2 * _4)))
     else:
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_2,_0,_1,_5,(_5 + _4),(_5 + (2 * _4)))
    _4 *= 2
   if _3: # src/fusion/CommonUtil.mbi:85:12-15
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_2,0,_0,0,int((_0).shape[0]))
  @staticmethod
  def __mergeInto_alt__3I_3I_3IIII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_CommonTools.__mergeInto__3I_3I_3IIII(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mergeInto__3I_3I_3IIII(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _6=(int((_0).shape[0]) if ((_5 > int((_0).shape[0])) ) else _5)
   _7=(_6 if ((_4 > _6) ) else _4)
   if (_7==_6): # src/fusion/CommonUtil.mbi:39:12-22
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,_3,_1,_3,(_7 - _3))
   else:
    _8=_3
    _9=_7
    _10 = _3
    while ((_8 < _7) and (_9 < _6)):
     if (_2[_0[_8]] < _2[_0[_9]]): # src/fusion/CommonUtil.mbi:48:20-49
      _1[_10] = _0[_8]
      _8 += 1
     else:
      _1[_10] = _0[_9]
      _9 += 1
     _10 += 1
    while (_8 < _7):
     _1[_10] = _0[_8]
     _8 += 1
     _10 += 1
    while (_9 < _6):
     _1[_10] = _0[_9]
     _9 += 1
     _10 += 1
  @staticmethod
  def _match_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argQsort_alt__3J_3J_3JJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argQsort__3J_3J_3JJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_2 is None): # src/fusion/CommonUtil.mbi:18:12-25
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_3,_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argQsort_alt__3J_3I_3IJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argQsort__3J_3I_3IJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_2 is None): # src/fusion/CommonUtil.mbi:10:12-25
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_3,_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
 return CommonTools
mosek_fusion_CommonTools=__mk_mosek_fusion_CommonTools()
del __mk_mosek_fusion_CommonTools
#BEFORE CLASS
def __mk_mosek_fusion_SolutionStruct():
 class SolutionStruct(object):
  __slots__ = ['yx','snx','sux','slx','bars','barx','y','suc','slc','xx','xc','dobj','pobj','probstatus','dstatus','pstatus','sol_numbarvar','sol_numcone','sol_numvar','sol_numcon']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args): # mosek.fusion.SolutionStruct
      self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):# mosek.fusion.SolutionStruct
      self._ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_ctor_IIII(*args): # int32,int32,int32,int32
      self._ctor_init_IIII(*args)
    elif self.__match_alt_ctor_IIII(*args):# int32,int32,int32,int32
      self._ctor_alt_init_IIII(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionStruct.ctor(mosek.fusion.SolutionStruct)\n\tmosek.fusion.SolutionStruct.ctor(int32,int32,int32,int32)')
  def isDualAcceptable(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isDualAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isDualAcceptable(mosek.fusion.AccSolutionStatus)')
  def resize(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_resize_IIII(*args): # int32,int32,int32,int32
      return self._resize_IIII(*args)
    elif mosek_fusion_SolutionStruct._match_alt_resize_IIII(*args): # int32,int32,int32,int32
      return self._resize_alt_IIII(*args)
    else:
      raise ValueError('Invalid argument list resize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.resize(int32,int32,int32,int32)')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_clone_(*args): # 
      return self._clone_(*args)
    elif mosek_fusion_SolutionStruct._match_alt_clone_(*args): # 
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.clone()')
  def isPrimalAcceptable(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isPrimalAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isPrimalAcceptable(mosek.fusion.AccSolutionStatus)')
  def __repr__(self): return 'mosek.fusion.SolutionStruct'
  @staticmethod
  def _ctor_IIII(numvar,numcon,numcone,numbarvar):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_IIII(numvar,numcon,numcone,numbarvar)
    return o
  @staticmethod
  def __match_ctor_IIII(*args):
    if len(args) != 4: return False
    numvar,numcon,numcone,numbarvar, = args
    return (__arg_match_I__(numvar) and __arg_match_I__(numcon) and __arg_match_I__(numcone) and __arg_match_I__(numbarvar))
  @staticmethod
  def __match_alt_ctor_IIII(*args):
    if len(args) != 4: return False
    numvar,numcon,numcone,numbarvar, = args
    return (__arg_alt_match_I__(numvar) and __arg_alt_match_I__(numcon) and __arg_alt_match_I__(numcone) and __arg_alt_match_I__(numbarvar))
  def _ctor_alt_init_IIII(self,numvar,numcon,numcone,numbarvar):
    self._ctor_init_IIII(numpy.int32(numvar),numpy.int32(numcon),numpy.int32(numcone),numpy.int32(numbarvar))
  def _ctor_init_IIII(self,numvar,numcon,numcone,numbarvar):
   self.pobj = 0.0
   self.dobj = 0.0
   self.pstatus = mosek.fusion.SolutionStatus.Unknown
   self.dstatus = mosek.fusion.SolutionStatus.Unknown
   self.probstatus = mosek.fusion.ProblemStatus.Unknown
   self.sol_numvar = numvar
   self.sol_numcon = numcon
   self.sol_numcone = numcone
   self.sol_numbarvar = numbarvar
   self.slx = None
   self.sux = None
   self.xx = None
   self.yx = None
   self.slc = None
   self.suc = None
   self.y = None
   self.xc = None
   self.snx = None
   self.barx = None
   self.bars = None
   if (numvar > 0): # src/fusion/Model.mbi:3729:12-22
    self.slx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.sux = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.xx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.yx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
   if (numbarvar > 0): # src/fusion/Model.mbi:3738:12-25
    self.barx = numpy.zeros((numbarvar,), dtype=numpy.dtype(numpy.float64))
    self.bars = numpy.zeros((numbarvar,), dtype=numpy.dtype(numpy.float64))
   if (numcon > 0): # src/fusion/Model.mbi:3744:12-22
    self.slc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.suc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.y = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.xc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
   if (numcone > 0): # src/fusion/Model.mbi:3753:12-23
    self.snx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
  @staticmethod
  def _ctor_Lmosek_4fusion_4SolutionStruct_2(that):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  def _ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
    self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
  def _ctor_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
   self.sol_numcon = (that.sol_numcon)
   self.sol_numvar = (that.sol_numvar)
   self.sol_numcone = (that.sol_numcone)
   self.sol_numbarvar = (that.sol_numbarvar)
   self.pstatus = (that.pstatus)
   self.dstatus = (that.dstatus)
   self.probstatus = (that.probstatus)
   self.pobj = (that.pobj)
   self.dobj = (that.dobj)
   self.xc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xc)) if (((that.xc) is not None) ) else None)
   self.xx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xx)) if (((that.xx) is not None) ) else None)
   self.yx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.yx)) if (((that.yx) is not None) ) else None)
   self.slc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slx)) if (((that.slc) is not None) ) else None)
   self.suc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.sux)) if (((that.suc) is not None) ) else None)
   self.y = (mosek.fusion.Utils.Tools._arraycopy__3D((that.y)) if (((that.y) is not None) ) else None)
   self.barx = mosek.fusion.Utils.Tools._arraycopy__3D((that.barx))
   self.bars = mosek.fusion.Utils.Tools._arraycopy__3D((that.bars))
   self.slx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slx)) if (((that.slx) is not None) ) else None)
   self.sux = (mosek.fusion.Utils.Tools._arraycopy__3D((that.sux)) if (((that.sux) is not None) ) else None)
   self.snx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.snx)) if (((that.snx) is not None) ) else None)
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_SolutionStruct._ctor_Lmosek_4fusion_4SolutionStruct_2(self))
  @staticmethod
  def _match_resize_IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_resize_IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3))
  def _resize_alt_IIII(self,_t__0,_t__1,_t__2,_t__3):
    return self._resize_IIII(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2),numpy.int32(__3))
  def _resize_IIII(self,_0,_1,_2,_3):
   if (_3 < 0): # src/fusion/Model.mbi:3499:14-27
    pass
   elif (_3 <= self.sol_numbarvar): # src/fusion/Model.mbi:3501:18-44
    self.sol_numbarvar = _3
   elif (_3 <= int((self.barx).shape[0])): # src/fusion/Model.mbi:3504:18-40
    pass
   else:
    if ((self.sol_numbarvar * 2) > (_3 + 100)): # src/fusion/Model.mbi:3509:18-53
     _4 = (self.sol_numbarvar * 2)
    else:
     _4 = (_3 + 100)
    self.barx = mosek.fusion.CommonTools._resize__3DI(self.barx,_4)
    self.bars = mosek.fusion.CommonTools._resize__3DI(self.bars,_4)
    self.sol_numbarvar = _4
   if (_0 < 0): # src/fusion/Model.mbi:3518:14-24
    pass
   elif (_0 <= self.sol_numvar): # src/fusion/Model.mbi:3522:18-38
    self.sol_numvar = _0
   elif (_0 <= int((self.xx).shape[0])): # src/fusion/Model.mbi:3527:18-35
    for _5 in range(self.sol_numvar,_0):
     self.slx[_5] = 0.0
     self.sux[_5] = 0.0
     self.xx[_5] = 0.0
     self.yx[_5] = 0.0
    self.sol_numvar = _0
   else:
    if ((self.sol_numvar * 2) > (_0 + 100)): # src/fusion/Model.mbi:3543:18-47
     _6 = (self.sol_numvar * 2)
    else:
     _6 = (_0 + 100)
    _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slx,0,_7,0,int((self.slx).shape[0]))
    self.slx = _7
    _8=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.sux,0,_8,0,int((self.sux).shape[0]))
    self.sux = _8
    _9=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xx,0,_9,0,int((self.xx).shape[0]))
    self.xx = _9
    _10=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.yx,0,_10,0,int((self.yx).shape[0]))
    self.yx = _10
    _11=self.sol_numvar
    while (_11 < _0):
     self.slx[_11] = 0.0
     self.sux[_11] = 0.0
     self.xx[_11] = 0.0
     _11 += 1
    self.sol_numvar = _0
   if (_1 < 0): # src/fusion/Model.mbi:3573:14-24
    pass
   elif (_1 <= self.sol_numcon): # src/fusion/Model.mbi:3577:18-38
    self.sol_numcon = _1
   elif (_1 <= int((self.xx).shape[0])): # src/fusion/Model.mbi:3582:18-35
    for _12 in range(self.sol_numcon,_1):
     self.slc[_12] = 0.0
     self.suc[_12] = 0.0
     self.xc[_12] = 0.0
     self.y[_12] = 0.0
    self.sol_numcon = _1
   else:
    if ((self.sol_numcon * 2) > (_1 + 100)): # src/fusion/Model.mbi:3599:18-47
     _13 = (self.sol_numcon * 2)
    else:
     _13 = (_1 + 100)
    _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slc,0,_14,0,int((self.slc).shape[0]))
    self.slc = _14
    _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.suc,0,_15,0,int((self.suc).shape[0]))
    self.suc = _15
    _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xc,0,_16,0,int((self.xc).shape[0]))
    self.xc = _16
    _17=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.y,0,_17,0,int((self.y).shape[0]))
    self.y = _17
    for _18 in range(self.sol_numcon,_1):
     self.slc[_18] = 0.0
     self.suc[_18] = 0.0
     self.xc[_18] = 0.0
     self.y[_18] = 0.0
    self.sol_numcon = _1
   if (_2 < 0): # src/fusion/Model.mbi:3633:14-25
    pass
   elif (_2 <= self.sol_numcone): # src/fusion/Model.mbi:3637:18-40
    self.sol_numcone = _2
   elif (_2 <= int((self.xx).shape[0])): # src/fusion/Model.mbi:3642:18-36
    for _19 in range(self.sol_numcone,_2):
     self.snx[_19] = 0.0
    self.sol_numcone = _2
   else:
    if ((self.sol_numcone * 2) > (_2 + 100)): # src/fusion/Model.mbi:3657:18-49
     _20 = (self.sol_numcone * 2)
    else:
     _20 = (_2 + 100)
    _21=numpy.zeros((_20,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.snx,0,_21,0,int((self.snx).shape[0]))
    self.snx = _21
    _22=self.sol_numcone
    while (_22 < _2):
     self.snx[_22] = 0.0
     _22 += 1
    self.sol_numcone = _2
  @staticmethod
  def _match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.dstatus,_0))
  @staticmethod
  def _match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.pstatus,_0))
  def __isAcceptable_alt_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_t__0,_t__1):
    return self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(__0,__1)
  def __isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_0,_1):
   if (_1==mosek.fusion.AccSolutionStatus.Anything): # src/fusion/Model.mbi:3460:16-53
    return (True)
   elif (_1==mosek.fusion.AccSolutionStatus.Optimal): # src/fusion/Model.mbi:3464:16-52
    return ((_0==mosek.fusion.SolutionStatus.Optimal))
   elif (_1==mosek.fusion.AccSolutionStatus.Feasible): # src/fusion/Model.mbi:3468:16-53
    return (((_0==mosek.fusion.SolutionStatus.Optimal) or (_0==mosek.fusion.SolutionStatus.Feasible)))
   elif (_1==mosek.fusion.AccSolutionStatus.Certificate): # src/fusion/Model.mbi:3474:16-56
    return ((_0==mosek.fusion.SolutionStatus.Certificate))
   return (False)
 return SolutionStruct
mosek_fusion_SolutionStruct=__mk_mosek_fusion_SolutionStruct()
del __mk_mosek_fusion_SolutionStruct
#BEFORE CLASS
def __mk_mosek_fusion_ConNZStruct():
 class ConNZStruct(object):
  __slots__ = ['barmidx','barsubj','barsubi','bfix','cof','subj','ptrb']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3I_3D_3D_3I_3I_3I(*args): # []int64,[]int32,[]double,[]double,[]int32,[]int32,[]int32
      self._ctor_init__3J_3I_3D_3D_3I_3I_3I(*args)
    elif self.__match_alt_ctor__3J_3I_3D_3D_3I_3I_3I(*args):# []int64,[]int32,[]double,[]double,[]int32,[]int32,[]int32
      self._ctor_alt_init__3J_3I_3D_3D_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ConNZStruct.ctor(array(int64,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ConNZStruct'
  @staticmethod
  def _ctor__3J_3I_3D_3D_3I_3I_3I(ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
    o = ConNZStruct.__new__(ConNZStruct)
    o._ctor_init__3J_3I_3D_3D_3I_3I_3I(ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_)
    return o
  @staticmethod
  def __match_ctor__3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3I__(subj_) and __arg_match__3D__(cof_) and __arg_match__3D__(bfix_) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barmidx_))
  @staticmethod
  def __match_alt_ctor__3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barmidx_))
  def _ctor_alt_init__3J_3I_3D_3D_3I_3I_3I(self,ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
    self._ctor_init__3J_3I_3D_3D_3I_3I_3I(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barmidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3J_3I_3D_3D_3I_3I_3I(self,ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
   assert ptrb_ is None or isinstance(ptrb_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   assert bfix_ is None or isinstance(bfix_,numpy.ndarray)
   assert barsubi_ is None or isinstance(barsubi_,numpy.ndarray)
   assert barsubj_ is None or isinstance(barsubj_,numpy.ndarray)
   assert barmidx_ is None or isinstance(barmidx_,numpy.ndarray)
   self.ptrb = ptrb_
   self.subj = subj_
   self.cof = cof_
   self.bfix = bfix_
   self.barsubi = barsubi_
   self.barsubj = barsubj_
   self.barmidx = barmidx_
 return ConNZStruct
mosek_fusion_ConNZStruct=__mk_mosek_fusion_ConNZStruct()
del __mk_mosek_fusion_ConNZStruct
#BEFORE CLASS
def __mk_mosek_fusion_BaseVariable():
 class BaseVariable(mosek_fusion_Variable,object):
  __slots__ = ['_BaseVariable__sparsity','_BaseVariable__nativeidxs','_BaseVariable__model','_BaseVariable__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args): # mosek.fusion.Model,[]int32,[]int64,[]int64
      self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):# mosek.fusion.Model,[]int32,[]int64,[]int64
      self._ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseVariable.ctor(mosek.fusion.Model,array(int32,ndim=1),array(int64,ndim=1),array(int64,ndim=1))')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_BaseVariable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.dual()')
  def setLevel(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_setLevel__3D(*args): # []double
      return self._setLevel__3D(*args)
    elif mosek_fusion_BaseVariable._match_alt_setLevel__3D(*args): # []double
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.setLevel(array(double,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_integer()')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_BaseVariable._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_BaseVariable._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_BaseVariable._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.eval()\n\tmosek.fusion.BaseVariable.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_set_1values__3DZ(*args): # []double,bool
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_set_1values__3DZ(*args): # []double,bool
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.set_values(array(double,ndim=1),bool)')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.index(int32)\n\tmosek.fusion.BaseVariable.index(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.index(int32,int32)\n\tmosek.fusion.BaseVariable.index(int32,int32,int32)')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeInteger()')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getModel()')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getND()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_BaseVariable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.transpose()')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.antidiag()\n\tmosek.fusion.BaseVariable.antidiag(int32)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.values(int32,array(double,ndim=1),bool)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.slice(int32,int32)\n\tmosek.fusion.BaseVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getDim(int32)')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getShape()')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_inst_I_3J(*args): # int32,[]int64
      return self._inst_I_3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst_I_3J(*args): # int32,[]int64
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_BaseVariable._match_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.BaseVariable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_BaseVariable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.asExpr()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getSize()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_BaseVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.toString()')
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeContinuous()')
  def numInst(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_numInst_(*args): # 
      return self._numInst_(*args)
    elif mosek_fusion_BaseVariable._match_alt_numInst_(*args): # 
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.numInst()')
  def reshape(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_reshape__3I(*args): # []int32
      return self._reshape__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape__3I(*args): # []int32
      return self._reshape_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_reshape_I(*args): # int32
      return self._reshape_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_I(*args): # int32
      return self._reshape_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_reshape_II(*args): # int32,int32
      return self._reshape_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_II(*args): # int32,int32
      return self._reshape_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_reshape_III(*args): # int32,int32,int32
      return self._reshape_III(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_III(*args): # int32,int32,int32
      return self._reshape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.reshape(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.reshape(int32)\n\tmosek.fusion.BaseVariable.reshape(int32,int32)\n\tmosek.fusion.BaseVariable.reshape(int32,int32,int32)')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.diag()\n\tmosek.fusion.BaseVariable.diag(int32)')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_BaseVariable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.level()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_continuous()')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=2))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.BaseVariable: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   self.__model = m
   self.__shape = (v.__shape)
   self.__sparsity = (v.__sparsity)
   self.__nativeidxs = (v.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   self.__model = m
   (self.__shape) = shape
   (self.__sparsity) = sparsity
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Variable((")
   if (int((self.__shape).shape[0]) > 0): # src/fusion/BaseVariable.monty:785:12-26
    _0._a_I(self.__shape[0])
    for _1 in range(1,int((self.__shape).shape[0])):
     _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S("))")
   return (_0._toString_())
  @staticmethod
  def _match_eval_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_eval_(*args):
    if len(args) != 0: return False
    return True
  def _eval_alt_(self,):
    return self._eval_()
  def _eval_(self,):
   return (self.asExpr().eval())
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__nativeidxs).shape[0])
   _4=_3
   _5=int((self.__shape).shape[0])
   _6=(self.__sparsity is not None)
   _0.alloc_expr(_5,_4,_3,_6)
   _7=(_0.ptr_base)
   _8=(_0.nidxs_base)
   _9=(_0.sp_base)
   _10=(_0.cof_base)
   _11=(_0.bfix_base)
   _12=(_0.shape_base)
   _13=(_0.i32)
   _14=(_0.i64)
   _15=(_0.f64)
   for _16 in range(0,_5):
    _13[(_12 + _16)] = self.__shape[_16]
   for _17 in range(0,(_3 + 1)):
    _13[(_7 + _17)] = _17
   for _18 in range(0,_3):
    _14[(_8 + _18)] = self.__nativeidxs[_18]
   if _6: # src/fusion/BaseVariable.monty:756:14-19
    for _19 in range(0,_3):
     _14[(_9 + _19)] = self.__sparsity[_19]
   for _20 in range(0,_3):
    _15[(_10 + _20)] = 1.0
   for _21 in range(0,_3):
    _15[(_11 + _21)] = 0.0
  @staticmethod
  def _match_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _reshape_alt_III(self,_t__0,_t__1,_t__2):
    return self._reshape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _reshape_III(self,_0,_1,_2):
   return (self.reshape(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _reshape_alt_II(self,_t__0,_t__1):
    return self._reshape_II(numpy.int32(__0),numpy.int32(__1))
  def _reshape_II(self,_0,_1):
   return (self.reshape(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _reshape_alt_I(self,_t__0):
    return self._reshape_I(numpy.int32(__0))
  def _reshape_I(self,_0):
   return (self.reshape(numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _reshape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._reshape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _reshape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   for _2 in range(0,int((_0).shape[0])):
    if (_0[_2] < 0): # src/fusion/BaseVariable.monty:716:14-26
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape")
    _1 *= _0[_2]
   if (_1!=self.getSize()): # src/fusion/BaseVariable.monty:720:12-34
    raise mosek_fusion_LengthError._ctor_S("Shape size does not match variable size")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),numpy.array([_0[_3] for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),self.__sparsity,self.__nativeidxs))
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setLevel_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setLevel__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setLevel__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:701:12-28
    if (int((_0).shape[0])!=int((self.__nativeidxs).shape[0])): # src/fusion/BaseVariable.monty:702:14-39
     raise mosek_fusion_LengthError._ctor_S("Invalid length of solution values vector")
    self.__model.setVariableValues(True,self.__nativeidxs,_0)
   else:
    if (int((_0).shape[0])!=self.getSize()): # src/fusion/BaseVariable.monty:706:14-33
     raise mosek_fusion_LengthError._ctor_S("Invalid length of solution values vector")
    _1=numpy.array([_0[self.__sparsity[_2]] for _2 in range(0,int((self.__nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.float64))
    self.__model.setVariableValues(True,self.__nativeidxs,_1)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   return numpy.int32(self.__shape[_0])
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   _0=1
   for _1 in range(0,int((self.__shape).shape[0])):
    _0 *= self.__shape[_1]
   return numpy.int64(_0)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__model.getVariableValues(False,self.__nativeidxs,_0,0)
   if (self.__sparsity is not None): # src/fusion/BaseVariable.monty:684:12-28
    _1=numpy.zeros((self.getSize(),), dtype=numpy.dtype(numpy.float64))
    for _2 in range(0,int((self.__nativeidxs).shape[0])):
     _1[self.__sparsity[_2]] = _0[_2]
    _0 = _1
   return (_0)
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _0=numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__model.getVariableValues(True,self.__nativeidxs,_0,0)
   if (self.__sparsity is not None): # src/fusion/BaseVariable.monty:672:12-28
    _1=numpy.zeros((self.getSize(),), dtype=numpy.dtype(numpy.float64))
    for _2 in range(0,int((self.__nativeidxs).shape[0])):
     _1[self.__sparsity[_2]] = _0[_2]
    _0 = _1
   return (_0)
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   self.make_continuous()
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   self.make_integer()
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   if (int((self.__shape).shape[0])==1): # src/fusion/BaseVariable.monty:626:12-27
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),numpy.array([1,self.__shape[0]], dtype=numpy.dtype(numpy.int32)),self.__sparsity,self.__nativeidxs))
   elif (int((self.__shape).shape[0]) > 2): # src/fusion/BaseVariable.monty:629:16-30
    raise mosek_fusion_DimensionError._ctor_S("Invalid shape for operation")
   else:
    _0=numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _1=(None if ((self.__sparsity is None) ) else numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.int64)))
    if (self.__sparsity is None): # src/fusion/BaseVariable.monty:634:14-30
     _2=0
     for _3 in range(0,self.__shape[1]):
      for _4 in range(0,self.__shape[0]):
       _0[_2] = self.__nativeidxs[((_4 * self.__shape[1]) + _3)]
       _2 += 1
    else:
     _5=numpy.zeros(((self.__shape[1] + 1),), dtype=numpy.dtype(numpy.int32))
     _6=self.__shape[0]
     _7=self.__shape[1]
     for _8 in range(0,int((self.__sparsity).shape[0])):
      _5[((self.__sparsity[_8] % _7) + 1)] += 1
     for _9 in range(0,_7):
      _5[(_9 + 1)] += _5[_9]
     for _10 in range(0,int((self.__sparsity).shape[0])):
      _11=(self.__sparsity[_10] % _7)
      _0[_5[_11]] = self.__nativeidxs[_10]
      _1[_5[_11]] = ((self.__sparsity[_10] // _7) + ((self.__sparsity[_10] % _7) * _6))
      _5[_11] += 1
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),numpy.array([self.__shape[1],self.__shape[0]], dtype=numpy.dtype(numpy.int32)),_1,_0))
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _index_alt_III(self,_t__0,_t__1,_t__2):
    return self._index_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _index_III(self,_0,_1,_2):
   return (self.index(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _index_alt_II(self,_t__0,_t__1):
    return self._index_II(numpy.int32(__0),numpy.int32(__1))
  def _index_II(self,_0,_1):
   return (self.index(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((1,int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   for _2 in range(0,int((_0).shape[0])):
    _1[0,_2] = _0[_2]
   return (self.pick(_1).reshape(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (self.pick(numpy.array([_0], dtype=numpy.dtype(numpy.int32))).reshape(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (int((self.__shape).shape[0])!=3): # src/fusion/BaseVariable.monty:578:12-27
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[0])!=int((_2).shape[0]))): # src/fusion/BaseVariable.monty:580:12-52
    raise mosek_fusion_LengthError._ctor_S("Mismatching argument lengths")
   _3=numpy.zeros((int((_0).shape[0]),3,), dtype=numpy.dtype(numpy.int32))
   for _4 in range(0,int((_0).shape[0])):
    _3[_4,0] = _0[_4]
    _3[_4,1] = _1[_4]
    _3[_4,2] = _2[_4]
   return (self.pick(_3))
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int((self.__shape).shape[0])!=2) or (int((_0).shape[0])!=int((_1).shape[0]))): # src/fusion/BaseVariable.monty:560:12-49
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _2=numpy.zeros((int((_0).shape[0]),2,), dtype=numpy.dtype(numpy.int32))
   for _3 in range(0,int((_0).shape[0])):
    _2[_3,0] = _0[_3]
    _2[_3,1] = _1[_3]
   return (self.pick(_2))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((self.__shape).shape[0])!=int((_0).shape[1])): # src/fusion/BaseVariable.monty:496:12-38
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _1=False
   for _2 in range(0,int((_0).shape[0])):
    for _3 in range(0,int((_0).shape[1])):
     if ((_0[_2,_3] < 0) or (_0[_2,_3] >= self.__shape[_3])): # src/fusion/BaseVariable.monty:502:16-56
      _1 = True
   if _1: # src/fusion/BaseVariable.monty:504:12-24
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _4=int((self.__shape).shape[0])
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
   _5[(_4 - 1)] = 1
   for _6 in range(1,_4):
    _5[((_4 - _6) - 1)] = (_5[(_4 - _6)] * self.__shape[(_4 - _6)])
   _7=numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))
   _9=None
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:516:12-28
    _8 = numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    for _10 in range(0,int((_0).shape[0])):
     _11=0
     for _12 in range(0,_4):
      _11 += (_5[_12] * _0[_10,_12])
     _8[_10] = self.__nativeidxs[_11]
   else:
    _13=0
    for _14 in range(0,int((_0).shape[0])):
     _15=0
     for _16 in range(0,_4):
      _15 += (_5[_16] * _0[_14,_16])
     if (mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_15) >= 0): # src/fusion/BaseVariable.monty:530:16-59
      _13 += 1
    _8 = numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
    _9 = numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
    _17=0
    for _18 in range(0,int((_0).shape[0])):
     _19=0
     for _20 in range(0,_4):
      _19 += (_5[_20] * _0[_18,_20])
     _21=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_19)
     if (_21 >= 0): # src/fusion/BaseVariable.monty:541:18-27
      _8[_17] = self.__nativeidxs[_21]
      _9[_17] = _18
      _17 += 1
    if (_13==int((_0).shape[0])): # src/fusion/BaseVariable.monty:548:14-33
     _9 = None
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),_7,_9,_8))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((self.__shape).shape[0])!=1): # src/fusion/BaseVariable.monty:453:12-27
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _1=False
   for _2 in range(0,int((_0).shape[0])):
    if ((_0[_2] < 0) or (_0[_2] >= self.__shape[0])): # src/fusion/BaseVariable.monty:458:14-48
     _1 = True
   if _1: # src/fusion/BaseVariable.monty:460:12-24
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _4=None
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:465:12-28
    _3 = numpy.array([self.__nativeidxs[_0[_5]] for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   else:
    _6=0
    for _7 in range(0,int((_0).shape[0])):
     if (mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_0[_7]) >= 0): # src/fusion/BaseVariable.monty:471:16-64
      _6 += 1
    _3 = numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
    _4 = numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
    _8=0
    for _9 in range(0,int((_0).shape[0])):
     _10=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_0[_9])
     if (_10 >= 0): # src/fusion/BaseVariable.monty:480:16-22
      _4[_8] = _9
      _3[_8] = self.__nativeidxs[_10]
      _8 += 1
    if (_6==int((_0).shape[0])): # src/fusion/BaseVariable.monty:486:14-30
     _4 = None
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32)),_4,_3))
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:433:12-27
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   elif ((_0 >= self.__shape[1]) or ((- _0) >= self.__shape[2])): # src/fusion/BaseVariable.monty:435:16-55
    raise mosek_fusion_IndexError._ctor_S("Diagonal index out of bounds")
   if (_0 >= 0): # src/fusion/BaseVariable.monty:438:12-22
    return (self.__general_1diag__3I_3II(numpy.array([0,((self.__shape[1] - 1) - _0)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < (self.__shape[1] - _0)) ) else (self.__shape[1] - _0))))
   else:
    return (self.__general_1diag__3I_3II(numpy.array([(- _0),(self.__shape[1] - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[1] if ((self.__shape[1] < (self.__shape[0] + _0)) ) else (self.__shape[0] + _0))))
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:425:12-27
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3II(numpy.array([0,(self.__shape[1] - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < self.__shape[1]) ) else self.__shape[1])))
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:412:12-27
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   elif ((_0 >= self.__shape[1]) or ((- _0) >= self.__shape[2])): # src/fusion/BaseVariable.monty:414:16-55
    raise mosek_fusion_IndexError._ctor_S("Diagonal index out of bounds")
   if (_0 >= 0): # src/fusion/BaseVariable.monty:417:12-22
    return (self.__general_1diag__3I_3II(numpy.array([0,_0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < (self.__shape[1] - _0)) ) else (self.__shape[1] - _0))))
   else:
    return (self.__general_1diag__3I_3II(numpy.array([(- _0),0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[1] if ((self.__shape[1] < (self.__shape[0] + _0)) ) else (self.__shape[0] + _0))))
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:405:12-27
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3II(numpy.array([0,0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < self.__shape[1]) ) else self.__shape[1])))
  def __general_1diag_alt__3I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self.__general_1diag__3I_3II(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __general_1diag__3I_3II(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=int((self.__shape).shape[0])
   if ((_3!=int((_0).shape[0])) or (_3!=int((_1).shape[0]))): # src/fusion/BaseVariable.monty:356:13-357:28
    raise mosek_fusion_DimensionError._ctor_S("Invalid start or step definition")
   for _4 in range(0,_3):
    if ((_0[_4] < 0) or (_0[_4] >= self.__shape[_4])): # src/fusion/BaseVariable.monty:360:15-57
     raise mosek_fusion_LengthError._ctor_S("Start element is out of bounds")
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _5[(_3 - 1)] = 1
   for _6 in range(1,_3):
    _5[((_3 - _6) - 1)] = (_5[(_3 - _6)] * self.__shape[(_3 - _6)])
   _7=0
   for _8 in range(0,int((_1).shape[0])):
    _7 += (_0[_8] * _5[_8])
   _9=0
   for _10 in range(0,int((_1).shape[0])):
    _9 += (_1[_10] * _5[_10])
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:369:12-28
    _11=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    for _12 in range(0,_2):
     _11[_12] = self.__nativeidxs[(_7 + (_9 * _12))]
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),numpy.array([_2], dtype=numpy.dtype(numpy.int32)),None,_11))
   else:
    _13=0
    for _14 in range(0,_2):
     _15=(_7 + (_9 * _14))
     _16=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_15)
     if (_16 >= 0): # src/fusion/BaseVariable.monty:380:16-26
      _13 += 1
    _17=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
    _18=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
    _19=0
    for _20 in range(0,_2):
     _17[_20] = self.__nativeidxs[(_7 + (_9 * _20))]
     _21=(_7 + (_9 * _20))
     _22=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_21)
     if (_22 >= 0): # src/fusion/BaseVariable.monty:390:16-26
      _18[_19] = _20
      _17[_19] = self.__nativeidxs[_22]
      _19 += 1
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),numpy.array([_2], dtype=numpy.dtype(numpy.int32)),_18,_17))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])): # src/fusion/BaseVariable.monty:248:12-35
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   elif (int((_0).shape[0])!=int((self.__shape).shape[0])): # src/fusion/BaseVariable.monty:250:16-40
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   else:
    for _2 in range(0,int((self.__shape).shape[0])):
     if ((_0[_2] < 0) or (_1[_2] > self.__shape[_2])): # src/fusion/BaseVariable.monty:254:16-50
      raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
     elif (_0[_2] > _1[_2]): # src/fusion/BaseVariable.monty:256:20-38
      raise mosek_fusion_SliceError._ctor_S("Invalid slice")
    _3=int((self.__shape).shape[0])
    _4=numpy.array([(_1[_5] - _0[_5]) for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
    _6=1
    for _7 in range(0,_3):
     _6 *= (_1[_7] - _0[_7])
    if (_6==0): # src/fusion/BaseVariable.monty:263:14-28
     return (mosek_fusion_NilVariable._ctor_())
    elif (self.__sparsity is not None): # src/fusion/BaseVariable.monty:265:18-34
     _8=0
     _9=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
     for _10 in range(0,int((self.__sparsity).shape[0])):
      _11=self.__sparsity[_10]
      for _12 in range(1,_3):
       _9[(_3 - _12)] = numpy.int32((_11 % self.__shape[(_3 - _12)]))
       _11 /= self.__shape[(_3 - _12)]
      _9[0] = numpy.int32(_11)
      _13=0
      while ((_9[_13] >= _0[_13]) and (_9[_13] < _1[_13])):
       _13 += 1
      if (_13==_3): # src/fusion/BaseVariable.monty:279:18-25
       _8 += 1
     _14=0
     _15=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
     _16=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
     for _17 in range(0,int((self.__sparsity).shape[0])):
      _18=self.__sparsity[_17]
      for _19 in range(1,_3):
       _9[(_3 - _19)] = numpy.int32((_18 % self.__shape[(_3 - _19)]))
       _18 /= self.__shape[(_3 - _19)]
      _9[0] = numpy.int32(_18)
      _20=0
      while ((_9[_20] >= _0[_20]) and (_9[_20] < _1[_20])):
       _20 += 1
      if (_20==_3): # src/fusion/BaseVariable.monty:295:18-25
       _15[_14] = self.__nativeidxs[_17]
       _21=0
       for _22 in range(0,_3):
        _21 = ((_21 * _4[_22]) + (_9[_22] - _0[_22]))
       _16[_14] = _21
       _14 += 1
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),_4,_16,_15))
    else:
     _23=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
     _24=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
     _24[(_3 - 1)] = 1
     for _25 in range(1,_3):
      _24[((_3 - _25) - 1)] = (_24[(_3 - _25)] * self.__shape[(_3 - _25)])
     _26=0
     for _27 in range(0,_3):
      _26 += (_0[_27] * _24[_27])
     _28=numpy.array([_26 for _29 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     _30=numpy.array([_0[_31] for _31 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     for _32 in range(0,_6):
      _23[_32] = self.__nativeidxs[_28[(_3 - 1)]]
      _30[(_3 - 1)] += 1
      _28[(_3 - 1)] += _24[(_3 - 1)]
      if (_30[(_3 - 1)] >= _1[(_3 - 1)]): # src/fusion/BaseVariable.monty:325:20-42
       _33=(_3 - 1)
       while ((_33 > 0) and (_30[_33] >= _1[_33])):
        _30[_33] = _0[_33]
        _30[(_33 - 1)] += 1
        _28[(_33 - 1)] += _24[(_33 - 1)]
        _33 -= 1
       for _34 in range((_33 + 1),_3):
        _28[_34] = _28[_33]
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),_4,None,_23))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (int((self.__shape).shape[0])!=1): # src/fusion/BaseVariable.monty:215:12-27
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   if ((_0==0) and (_1==self.__shape[0])): # src/fusion/BaseVariable.monty:217:12-43
    return (self)
   elif ((_0 < 0) or (_1 > self.__shape[0])): # src/fusion/BaseVariable.monty:219:16-44
    raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   elif (_0 > _1): # src/fusion/BaseVariable.monty:221:16-28
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   elif (_0==_1): # src/fusion/BaseVariable.monty:223:16-29
    return (mosek_fusion_NilVariable._ctor_())
   elif (self.__sparsity is not None): # src/fusion/BaseVariable.monty:225:16-32
    _2=(_1 - _0)
    _3=0
    _4=mosek.fusion.CommonTools._binarySearchL__3JJ(self.__sparsity,_0)
    _5=mosek.fusion.CommonTools._binarySearchL__3JJ(self.__sparsity,_1)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),numpy.array([_2], dtype=numpy.dtype(numpy.int32)),numpy.array([(self.__sparsity[_6] - _0) for _6 in range(_4,_5)], dtype=numpy.dtype(numpy.int64)),numpy.array([self.__nativeidxs[_7] for _7 in range(_4,_5)], dtype=numpy.dtype(numpy.int64))))
   else:
    _8=(_1 - _0)
    _9=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.__nativeidxs,_0,_9,0,_8)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self.getModel(),numpy.array([_8], dtype=numpy.dtype(numpy.int32)),None,_9))
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   return (mosek_fusion_ExprFromVar._ctor_Lmosek_4fusion_4Variable_2(self))
  @staticmethod
  def _match_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match__3J__(_3))
  @staticmethod
  def _match_alt_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match__3J__(_3))
  def _inst_alt_I_3JI_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3JI_3J(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3JI_3J(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=(self.__nativeidxs)
   _5=(self.__sparsity)
   if (_5 is None): # src/fusion/BaseVariable.monty:179:12-26
    for _6 in range(0,int((_4).shape[0])):
     _1[(_6 + _0)] = _6
     _3[(_6 + _2)] = _4[_6]
   else:
    for _7 in range(0,int(((self.__sparsity)).shape[0])):
     _1[(_0 + _7)] = _5[_7]
     _3[(_7 + _2)] = _4[_7]
   return numpy.int32(int(((self.__nativeidxs)).shape[0]))
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   return numpy.int32(int((self.__nativeidxs).shape[0]))
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1))
  def _inst_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:154:17-33
    for _2 in range(0,int((self.__nativeidxs).shape[0])):
     _1[(_0 + _2)] = self.__nativeidxs[_2]
   else:
    _3=self.getShape()
    _4=1
    for _5 in range(0,int((_3).shape[0])):
     _4 *= _3[_5]
    for _6 in range(0,_4):
     _1[(_0 + _6)] = 0
    for _7 in range(0,int((self.__sparsity).shape[0])):
     _1[(_0 + self.__sparsity[_7])] = self.__nativeidxs[_7]
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Z__(_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Z__(_1))
  def _set_1values_alt__3DZ(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = self._set_1values__3DZ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3DZ(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:136:12-28
    self.getModel().setVariableValues(_1,self.__nativeidxs,_0)
   else:
    _2=1
    for _3 in range(0,int((self.__shape).shape[0])):
     _2 *= self.__shape[_3]
    _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    for _5 in range(0,int((self.__nativeidxs).shape[0])):
     _4[self.__sparsity[_5]] = self.__nativeidxs[_5]
    self.getModel().setVariableValues(_1,_4,_0)
  def _dual_1lu_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._dual_1lu_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1lu_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:121:12-28
    self.__model.getVariableDuals(_2,self.__nativeidxs,_1,_0)
   else:
    _3=numpy.zeros((self.getSize(),), dtype=numpy.dtype(numpy.int64))
    for _4 in range(0,int((self.__sparsity).shape[0])):
     _3[self.__sparsity[_4]] = self.__nativeidxs[_4]
    self.__model.getVariableDuals(_2,_3,_1,_0)
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:106:12-28
    self.__model.getVariableValues(_2,self.__nativeidxs,_1,_0)
   else:
    _3=numpy.zeros((self.getSize(),), dtype=numpy.dtype(numpy.int64))
    for _4 in range(0,int((self.__sparsity).shape[0])):
     _3[self.__sparsity[_4]] = self.__nativeidxs[_4]
    self.__model.getVariableValues(_2,_3,_1,_0)
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   self.getModel()._make_1continuous__3J(self.__nativeidxs)
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   self.getModel()._make_1integer__3J(self.__nativeidxs)
 return BaseVariable
mosek_fusion_BaseVariable=__mk_mosek_fusion_BaseVariable()
del __mk_mosek_fusion_BaseVariable
#BEFORE CLASS
def __mk_mosek_fusion_SliceVariable():
 class SliceVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_SliceVariable__shape','_SliceVariable__sparsity','_SliceVariable__nativeidxs']
  def __repr__(self): return 'mosek.fusion.SliceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs):
    o = SliceVariable.__new__(SliceVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs)
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__shape) = shape
 return SliceVariable
mosek_fusion_SliceVariable=__mk_mosek_fusion_SliceVariable()
del __mk_mosek_fusion_SliceVariable
#BEFORE CLASS
def __mk_mosek_fusion_ModelVariable():
 class ModelVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_ModelVariable__sparsity','_ModelVariable__shape','_ModelVariable__nativeidxs','_ModelVariable__varid','_ModelVariable__name']
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_ModelVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_ModelVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.ModelVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__name = (v.__name)
   self.__varid = (v.__varid)
   self.__nativeidxs = (v.__nativeidxs)
   self.__shape = (v.__shape)
   self.__sparsity = (v.__sparsity)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,shape,varid,sparsity,nativeidxs):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,shape,varid,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(*args):
    if len(args) != 6: return False
    model,name,shape,varid,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match_J__(varid) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(*args):
    if len(args) != 6: return False
    model,name,shape,varid,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match_J__(varid) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,model,shape,sparsity,nativeidxs)
   (self.__name) = name
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__sparsity) = sparsity
   (self.__nativeidxs) = nativeidxs
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _1._a_S(("_" if ((int(len(self.__name))==0) ) else self.__name))._a_S("[")._a_S(mosek.fusion.Set._indexToString__3IJ(self.__shape,_0))._a_S("]")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
 return ModelVariable
mosek_fusion_ModelVariable=__mk_mosek_fusion_ModelVariable()
del __mk_mosek_fusion_ModelVariable
#BEFORE CLASS
def __mk_mosek_fusion_SymRangedVariable():
 class SymRangedVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_SymRangedVariable__dim','_SymRangedVariable__sparsity','_SymRangedVariable__nativeidxs','_SymRangedVariable__names_flushed','_SymRangedVariable__name']
  def __repr__(self): return 'mosek.fusion.SymRangedVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = SymRangedVariable.__new__(SymRangedVariable)
    o._ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymRangedVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__names_flushed = (v.__names_flushed)
   self.__name = (v.__name)
   self.__sparsity = (v.__sparsity)
   self.__nativeidxs = (v.__nativeidxs)
   self.__dim = (v.__dim)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,varid,dim,sparsity,nativeidxs):
    o = SymRangedVariable.__new__(SymRangedVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,varid,dim,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,dim,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match_I__(dim) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,dim,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match_I__(dim) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJI_3J_3I(self,model,name,varid,dim,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,numpy.int64(varid),numpy.int32(dim),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(self,model,name,varid,dim,sparsity,nativeidxs):
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,numpy.array([dim,dim], dtype=numpy.dtype(numpy.int32)),varid,mosek.fusion.SymRangedVariable.__mirror_1sp_I_3J(dim,sparsity),mosek.fusion.SymRangedVariable.__mirror_1idxs_I_3J_3I(dim,sparsity,nativeidxs))
   self.__names_flushed = False
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__dim) = dim
  def _dual_1u_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_I_3D(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._dual_1lu_I_3DZ(_0,_1,False)
  def _dual_1l_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_I_3D(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._dual_1lu_I_3DZ(_0,_1,True)
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self.getModel()
   if ((not self.__names_flushed) and (int(len(self.__name)) > 0)): # src/fusion/SymRangedVariable.mbi:140:12-47
    if (self.__sparsity is None): # src/fusion/SymRangedVariable.mbi:142:14-30
     for _1 in range(0,int((self.__nativeidxs).shape[0])):
      _0._varname_IS(self.__nativeidxs[_1],("" if ((int(len(self.__name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self.__name)._a_S("[")._a_I((_1 // self.__dim))._a_S(",")._a_I((_1 % self.__dim))._a_S("]")._toString_()))
    else:
     for _2 in range(0,int((self.__sparsity).shape[0])):
      _0._varname_IS(self.__nativeidxs[_2],mosek.fusion.Utils.StringBuffer()._a_S(self.__name)._a_S("[")._a_J((self.__sparsity[_2] // self.__dim))._a_S(",")._a_J((self.__sparsity[_2] % self.__dim))._a_S("]")._toString_())
    self.__names_flushed = True
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_SymRangedVariable._ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __mirror_1idxs_alt_I_3J_3I(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_SymRangedVariable.__mirror_1idxs_I_3J_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mirror_1idxs_I_3J_3I(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_1 is None): # src/fusion/SymRangedVariable.mbi:60:12-22
    _3=numpy.zeros(((_0 * _0),), dtype=numpy.dtype(numpy.int64))
    _4=0
    for _5 in range(0,_0):
     _3[((_5 * _0) + _5)] = (_2[_4] + 1)
     _4 += 1
     for _6 in range((_5 + 1),_0):
      _3[((_5 * _0) + _6)] = (_2[_4] + 1)
      _3[((_6 * _0) + _5)] = (_2[_4] + 1)
      _4 += 1
    return (_3)
   else:
    _7=0
    for _8 in range(0,int((_1).shape[0])):
     _7 += (1 if (((_1[_8] % (_0 + 1))==0) ) else 2)
    _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _10=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _11=0
    for _12 in range(0,int((_1).shape[0])):
     _13=(_1[_12] // _0)
     _14=(_1[_12] % _0)
     _9[_11] = _1[_12]
     _10[_11] = (_2[_12] + 1)
     _11 += 1
     if (_13!=_14): # src/fusion/SymRangedVariable.mbi:93:18-30
      _9[_11] = ((_14 * _0) + _13)
      _10[_11] = (_2[_12] + 1)
      _11 += 1
    _15=numpy.array([_16 for _16 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_15,_9,None,0,_7)
    return (numpy.array([_10[_15[_17]] for _17 in range(0,_7)], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def __mirror_1sp_alt_I_3J(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_SymRangedVariable.__mirror_1sp_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mirror_1sp_I_3J(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (_1 is None): # src/fusion/SymRangedVariable.mbi:30:12-22
    return (None)
   else:
    _2=0
    for _3 in range(0,int((_1).shape[0])):
     _2 += (1 if (((_1[_3] % (_0 + 1))==0) ) else 2)
    _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _5=0
    for _6 in range(0,int((_1).shape[0])):
     _7=(_1[_6] // _0)
     _8=(_1[_6] % _0)
     _4[_5] = _1[_6]
     _5 += 1
     if (_7!=_8): # src/fusion/SymRangedVariable.mbi:47:18-30
      _4[_5] = ((_8 * _0) + _7)
      _5 += 1
    _9=numpy.array([_10 for _10 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_9,_4,None,0,_2)
    return (numpy.array([_4[_9[_11]] for _11 in range(0,_2)], dtype=numpy.dtype(numpy.int64)))
 return SymRangedVariable
mosek_fusion_SymRangedVariable=__mk_mosek_fusion_SymRangedVariable()
del __mk_mosek_fusion_SymRangedVariable
#BEFORE CLASS
def __mk_mosek_fusion_RangedVariable():
 class RangedVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_RangedVariable__shape','_RangedVariable__name','_RangedVariable__names_flushed','_RangedVariable__nativeidxs','_RangedVariable__sparsity']
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_RangedVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.RangedVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__name = (v.__name)
   self.__nativeidxs = (v.__nativeidxs)
   self.__sparsity = (v.__sparsity)
   self.__names_flushed = (v.__names_flushed)
   self.__shape = (v.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,numpy.int64(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,mosek.fusion.RangedVariable.__globalNativeIndexes__3I(nativeidxs))
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__name) = name
   (self.__shape) = shape
   self.__names_flushed = False
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self.elementName(_0,_1)
   _1._a_S(" : in range")
   return (_1)
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self.getModel()
   if ((not self.__names_flushed) and (int(len(self.__name)) > 0)): # src/fusion/RangedVariable.mbi:95:12-47
    _1=mosek.fusion.Utils.StringBuffer()
    _1._a_S(self.__name)._a_S("[")
    if (self.getND() > 0): # src/fusion/RangedVariable.mbi:99:14-25
     _1._a_S("%0")
     for _2 in range(1,self.getND()):
      _1._a_S(",%")._a_I(_2)
    _1._a_S("]")
    _0._varnames__3IS_3I_3J(self.__nativeidxs,_1._toString_(),self.getShape(),self.__sparsity)
    self.__names_flushed = True
  def _dual_1u_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_I_3D(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._dual_1lu_I_3DZ(_0,_1,False)
  def _dual_1l_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_I_3D(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._dual_1lu_I_3DZ(_0,_1,True)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_RangedVariable.__globalNativeIndexes__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _2 in range(0,int((_0).shape[0])):
    _1[_2] = (_0[_2] + 1)
   return (_1)
 return RangedVariable
mosek_fusion_RangedVariable=__mk_mosek_fusion_RangedVariable()
del __mk_mosek_fusion_RangedVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDVariable():
 class LinearPSDVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearPSDVariable__shape','_LinearPSDVariable__name','_LinearPSDVariable__varid','_LinearPSDVariable__nativeidxs','_LinearPSDVariable__conedim']
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    elif mosek_fusion_LinearPSDVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_integer()\n\tmosek.fusion.LinearPSDVariable.make_integer(array(int64,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.toString()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    elif mosek_fusion_LinearPSDVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_continuous()\n\tmosek.fusion.LinearPSDVariable.make_continuous(array(int64,ndim=1))')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.LinearPSDVariable: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   (self.__conedim) = (v.__conedim)
   (self.__varid) = (v.__varid)
   (self.__name) = (v.__name)
   (self.__shape) = (v.__shape)
   (self.__nativeidxs) = (v.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,varid,shape,conedim,nativeidxs):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,varid,shape,conedim,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3II_3J(*args):
    if len(args) != 6: return False
    model,name,varid,shape,conedim,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match_I__(conedim) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3II_3J(*args):
    if len(args) != 6: return False
    model,name,varid,shape,conedim,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3II_3J(self,model,name,varid,shape,conedim,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(self,model,name,varid,shape,conedim,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.LinearPSDVariable.__globalNativeIndexes__3J(nativeidxs))
   (self.__name) = name
   (self.__conedim) = conedim
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("PSDVariable(")
   if (int(len(self.__name)) > 0): # src/fusion/LinearPSDVariable.monty:64:12-25
    _0._a_S("'")._a_S(self.__name)._a_S("',")
   _0._a_I(self.__shape[0])
   for _1 in range(1,int((self.__shape).shape[0])):
    _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearPSDVariable._ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3J(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_LinearPSDVariable.__globalNativeIndexes__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3J(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (numpy.array([(- (_0[_1] + 1)) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
 return LinearPSDVariable
mosek_fusion_LinearPSDVariable=__mk_mosek_fusion_LinearPSDVariable()
del __mk_mosek_fusion_LinearPSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_PSDVariable():
 class PSDVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_PSDVariable__conedim2','_PSDVariable__conedim1','_PSDVariable__shape','_PSDVariable__name','_PSDVariable__nativeidxs','_PSDVariable__varid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_PSDVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.toString()')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PSDVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.PSDVariable: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__varid = (v.__varid)
   self.__nativeidxs = (v.__nativeidxs)
   self.__name = (v.__name)
   self.__shape = (v.__shape)
   self.__conedim1 = (v.__conedim1)
   self.__conedim2 = (v.__conedim2)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3III_3J(model,name,varid,shape,conedim1,conedim2,nativeidxs):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J(model,name,varid,shape,conedim1,conedim2,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3III_3J(*args):
    if len(args) != 7: return False
    model,name,varid,shape,conedim1,conedim2,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match_I__(conedim1) and __arg_match_I__(conedim2) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3III_3J(*args):
    if len(args) != 7: return False
    model,name,varid,shape,conedim1,conedim2,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim1) and __arg_alt_match_I__(conedim2) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3III_3J(self,model,name,varid,shape,conedim1,conedim2,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim1),numpy.int32(conedim2),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J(self,model,name,varid,shape,conedim1,conedim2,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.PSDVariable.__fullnativeidxs__3III_3J(shape,conedim1,conedim2,nativeidxs))
   (self.__varid) = varid
   (self.__nativeidxs) = nativeidxs
   (self.__name) = name
   (self.__shape) = shape
   (self.__conedim1) = conedim1
   (self.__conedim2) = conedim2
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("PSDVariable(")
   if (int(len(self.__name)) > 0): # src/fusion/SemidefiniteVariable.mbi:110:12-25
    _0._a_S("'")._a_S(self.__name)._a_S("',")
   _0._a_I(self.__shape[0])
   for _1 in range(1,int((self.__shape).shape[0])):
    _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self.elementName(_0,_1)
   _1._a_S(" : element in positive semidefinite cone")
   return (_1)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __fullnativeidxs_alt__3III_3J(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_PSDVariable.__fullnativeidxs__3III_3J(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __fullnativeidxs__3III_3J(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=int((_0).shape[0])
   _5=(_1 < _2)
   _6=(_1 if (_5 ) else _2)
   _7=(_1 if ((not _5) ) else _2)
   _8=1
   for _9 in range(0,_6):
    _8 *= _0[_9]
   _10=_0[_6]
   _11=1
   for _12 in range((_6 + 1),_7):
    _11 *= _0[_12]
   _13=_0[_7]
   _14=1
   for _15 in range((_7 + 1),_4):
    _14 *= _0[_15]
   _16=((((_8 * _10) * _11) * _13) * _14)
   _17=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
   _18=_14
   _19=(_18 * _13)
   _20=(_19 * _11)
   _21=(_20 * _20)
   _22=0
   for _23 in range(0,_8):
    for _24 in range(0,_13):
     for _25 in range(0,_11):
      for _26 in range(_24,_10):
       for _27 in range(0,_14):
        _17[(((((_23 * _21) + (_26 * _20)) + (_25 * _19)) + (_24 * _18)) + _27)] = (- (_3[_22] + 1))
        _17[(((((_23 * _21) + (_24 * _20)) + (_25 * _19)) + (_26 * _18)) + _27)] = (- (_3[_22] + 1))
        _22 += 1
   return (_17)
 return PSDVariable
mosek_fusion_PSDVariable=__mk_mosek_fusion_PSDVariable()
del __mk_mosek_fusion_PSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_SymLinearVariable():
 class SymLinearVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_SymLinearVariable__dim','_SymLinearVariable__sparsity','_SymLinearVariable__nativeidxs','_SymLinearVariable__names_flushed','_SymLinearVariable__name']
  def __repr__(self): return 'mosek.fusion.SymLinearVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = SymLinearVariable.__new__(SymLinearVariable)
    o._ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymLinearVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__names_flushed = (v.__names_flushed)
   self.__name = (v.__name)
   self.__sparsity = (v.__sparsity)
   self.__nativeidxs = (v.__nativeidxs)
   self.__dim = (v.__dim)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,varid,dim,sparsity,nativeidxs):
    o = SymLinearVariable.__new__(SymLinearVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,varid,dim,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,dim,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match_I__(dim) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,dim,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match_I__(dim) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJI_3J_3I(self,model,name,varid,dim,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,numpy.int64(varid),numpy.int32(dim),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(self,model,name,varid,dim,sparsity,nativeidxs):
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,numpy.array([dim,dim], dtype=numpy.dtype(numpy.int32)),varid,mosek.fusion.SymLinearVariable.__mirror_1sp_I_3J(dim,sparsity),mosek.fusion.SymLinearVariable.__mirror_1idxs_I_3J_3I(dim,sparsity,nativeidxs))
   self.__names_flushed = False
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__dim) = dim
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self.getModel()
   if ((not self.__names_flushed) and (int(len(self.__name)) > 0)): # src/fusion/SymLinearVariable.monty:144:12-47
    if (self.__sparsity is None): # src/fusion/SymLinearVariable.monty:146:14-30
     for _1 in range(0,int((self.__nativeidxs).shape[0])):
      _0._varname_IS(self.__nativeidxs[_1],("" if ((int(len(self.__name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self.__name)._a_S("[")._a_I((_1 // self.__dim))._a_S(",")._a_I((_1 % self.__dim))._a_S("]")._toString_()))
    else:
     for _2 in range(0,int((self.__sparsity).shape[0])):
      _0._varname_IS(self.__nativeidxs[_2],mosek.fusion.Utils.StringBuffer()._a_S(self.__name)._a_S("[")._a_J((self.__sparsity[_2] // self.__dim))._a_S(",")._a_J((self.__sparsity[_2] % self.__dim))._a_S("]")._toString_())
    self.__names_flushed = True
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_SymLinearVariable._ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __mirror_1idxs_alt_I_3J_3I(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_SymLinearVariable.__mirror_1idxs_I_3J_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mirror_1idxs_I_3J_3I(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_1 is None): # src/fusion/SymLinearVariable.monty:63:12-22
    _3=numpy.zeros(((_0 * _0),), dtype=numpy.dtype(numpy.int64))
    _4=0
    for _5 in range(0,_0):
     _3[((_5 * _0) + _5)] = (_2[_4] + 1)
     _4 += 1
     for _6 in range((_5 + 1),_0):
      _3[((_5 * _0) + _6)] = (_2[_4] + 1)
      _3[((_6 * _0) + _5)] = (_2[_4] + 1)
      _4 += 1
    return (_3)
   else:
    _7=0
    for _8 in range(0,int((_1).shape[0])):
     _7 += (1 if (((_1[_8] % (_0 + 1))==0) ) else 2)
    _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _10=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _11=0
    for _12 in range(0,int((_1).shape[0])):
     _13=(_1[_12] // _0)
     _14=(_1[_12] % _0)
     _9[_11] = _1[_12]
     _10[_11] = (_2[_12] + 1)
     _11 += 1
     if (_13!=_14): # src/fusion/SymLinearVariable.monty:96:18-30
      _9[_11] = ((_14 * _0) + _13)
      _10[_11] = (_2[_12] + 1)
      _11 += 1
    _15=numpy.array([_16 for _16 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_15,_9,None,0,_7)
    return (numpy.array([_10[_15[_17]] for _17 in range(0,_7)], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def __mirror_1sp_alt_I_3J(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_SymLinearVariable.__mirror_1sp_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mirror_1sp_I_3J(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (_1 is None): # src/fusion/SymLinearVariable.monty:33:12-22
    return (None)
   else:
    _2=0
    for _3 in range(0,int((_1).shape[0])):
     _2 += (1 if (((_1[_3] % (_0 + 1))==0) ) else 2)
    _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _5=0
    for _6 in range(0,int((_1).shape[0])):
     _7=(_1[_6] // _0)
     _8=(_1[_6] % _0)
     _4[_5] = _1[_6]
     _5 += 1
     if (_7!=_8): # src/fusion/SymLinearVariable.monty:50:18-30
      _4[_5] = ((_8 * _0) + _7)
      _5 += 1
    _9=numpy.array([_10 for _10 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_9,_4,None,0,_2)
    return (numpy.array([_4[_9[_11]] for _11 in range(0,_2)], dtype=numpy.dtype(numpy.int64)))
 return SymLinearVariable
mosek_fusion_SymLinearVariable=__mk_mosek_fusion_SymLinearVariable()
del __mk_mosek_fusion_SymLinearVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearVariable():
 class LinearVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearVariable__shape','_LinearVariable__sparsity','_LinearVariable__nativeidxs','_LinearVariable__names_flushed','_LinearVariable__name']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.LinearVariable: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__names_flushed = (v.__names_flushed)
   self.__nativeidxs = (v.__nativeidxs)
   self.__sparsity = (v.__sparsity)
   self.__shape = (v.__shape)
   self.__name = (v.__name)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,numpy.int64(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,mosek.fusion.LinearVariable.__globalNativeIndexes__3I(nativeidxs))
   self.__names_flushed = False
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__shape) = shape
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("LinearVariable((")
   if (int((self.__shape).shape[0]) > 0): # src/fusion/LinearVariable.mbi:92:12-26
    _0._a_I(self.__shape[0])
    for _1 in range(1,int((self.__shape).shape[0])):
     _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S("))")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self.getModel()
   if ((not self.__names_flushed) and (int(len(self.__name)) > 0)): # src/fusion/LinearVariable.mbi:70:12-47
    _1=mosek.fusion.Utils.StringBuffer()
    _1._a_S(self.__name)._a_S("[")
    if (self.getND() > 0): # src/fusion/LinearVariable.mbi:74:14-25
     _1._a_S("%0")
     for _2 in range(1,self.getND()):
      _1._a_S(",%")._a_I(_2)
    _1._a_S("]")
    _0._varnames__3IS_3I_3J(self.__nativeidxs,_1._toString_(),(self.getShape() if ((self.getND() > 0) ) else numpy.array([1], dtype=numpy.dtype(numpy.int32))),self.__sparsity)
    self.__names_flushed = True
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_LinearVariable.__globalNativeIndexes__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _2 in range(0,int((_0).shape[0])):
    _1[_2] = (_0[_2] + 1)
   return (_1)
 return LinearVariable
mosek_fusion_LinearVariable=__mk_mosek_fusion_LinearVariable()
del __mk_mosek_fusion_LinearVariable
#BEFORE CLASS
def __mk_mosek_fusion_ConicVariable():
 class ConicVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_ConicVariable__nativeidxs','_ConicVariable__shape','_ConicVariable__name','_ConicVariable__names_flushed','_ConicVariable__varid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ConicVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ConicVariable: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__names_flushed = (v.__names_flushed)
   self.__shape = (v.__shape)
   self.__nativeidxs = (v.__nativeidxs)
   self.__shape = (v.__shape)
   self.__varid = (v.__varid)
   self.__name = (v.__name)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,varid,shape,nativeidxs):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,varid,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,varid,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,varid,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,varid,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,varid,shape,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.ConicVariable.__globalNativeIndexes__3I(nativeidxs))
   (self.__name) = name
   (self.__names_flushed) = False
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("ConicVariable( ")
   if (int(len(self.__name)) > 0): # src/fusion/ConicVariable.mbi:92:12-25
    _0._a_S("'")._a_S(self.__name)._a_S("',")
   _0._a_S("(")
   _0._a_I(self.__shape[0])
   for _1 in range(1,int((self.__shape).shape[0])):
    _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(") )")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self.getModel()
   if ((not self.__names_flushed) and (int(len(self.__name)) > 0)): # src/fusion/ConicVariable.mbi:74:12-47
    _1=mosek.fusion.Utils.StringBuffer()
    _1._a_S(self.__name)._a_S("[")
    _1._a_S("%0")
    for _2 in range(1,self.getND()):
     _1._a_S(",%")._a_I(_2)
    _1._a_S("]")
    _0._varnames__3IS_3I_3J(self.__nativeidxs,_1._toString_(),(self.getShape() if ((self.getND() > 0) ) else numpy.array([0], dtype=numpy.dtype(numpy.int32))),None)
    self.__names_flushed = True
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ConicVariable.__globalNativeIndexes__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _2 in range(0,int((_0).shape[0])):
    _1[_2] = (_0[_2] + 1)
   return (_1)
 return ConicVariable
mosek_fusion_ConicVariable=__mk_mosek_fusion_ConicVariable()
del __mk_mosek_fusion_ConicVariable
#BEFORE CLASS
def __mk_mosek_fusion_NilVariable():
 class NilVariable(mosek_fusion_SymmetricVariable,mosek_fusion_BaseVariable):
  __slots__ = ['_NilVariable__shape']
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_integer()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_set_1values__3DZ(*args): # []double,bool
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_set_1values__3DZ(*args): # []double,bool
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.set_values(array(double,ndim=1),bool)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.values(int32,array(double,ndim=1),bool)')
  def numInst(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_numInst_(*args): # 
      return self._numInst_(*args)
    elif mosek_fusion_NilVariable._match_alt_numInst_(*args): # 
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.numInst()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_NilVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_NilVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_NilVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.slice(int32,int32)\n\tmosek.fusion.NilVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_NilVariable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_NilVariable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_NilVariable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_NilVariable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_NilVariable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_NilVariable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_NilVariable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.index(int32)\n\tmosek.fusion.NilVariable.index(array(int32,ndim=1))\n\tmosek.fusion.NilVariable.index(int32,int32)\n\tmosek.fusion.NilVariable.index(int32,int32,int32)')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_NilVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.toString()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_continuous()')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_inst_I_3J(*args): # int32,[]int64
      return self._inst_I_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3J(*args): # int32,[]int64
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_NilVariable._match_inst_I_3J_3J(*args): # int32,[]int64,[]int64
      return self._inst_I_3J_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3J_3J(*args): # int32,[]int64,[]int64
      return self._inst_alt_I_3J_3J(*args)
    elif mosek_fusion_NilVariable._match_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.NilVariable: '+self._toString_()
  @staticmethod
  def _ctor__3I(shape):
    o = NilVariable.__new__(NilVariable)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   assert shape is None or isinstance(shape,numpy.ndarray)
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,None,mosek.fusion.Utils.Tools._arraycopy__3I(shape),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)))
   (self.__shape) = numpy.array([shape[_0] for _0 in range(0,int((shape).shape[0]))], dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_():
    o = NilVariable.__new__(NilVariable)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_NilVariable._ctor_init__3I(self,numpy.array([1], dtype=numpy.dtype(numpy.int32)))
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   return numpy.int32(0)
  @staticmethod
  def _match_inst_I_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2))
  @staticmethod
  def _match_alt_inst_I_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2))
  def _inst_alt_I_3J_3J(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J_3J(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J_3J(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return numpy.int32(0)
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1))
  def _inst_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Z__(_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Z__(_1))
  def _set_1values_alt__3DZ(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = self._set_1values__3DZ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3DZ(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   pass
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("NilVariable")
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([1 for _1 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([1 for _1 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int((self.__shape).shape[0])!=int((_0).shape[0])) or (int((self.__shape).shape[0])!=int((_1).shape[0]))): # src/fusion/BaseVariable.monty:853:12-63
    raise mosek_fusion_DimensionError._ctor_S("Mismatching slice shape")
   for _2 in range(0,int((_0).shape[0])):
    if ((_1[_2] > _0[_2]) or ((_0[_2] < 0) or (_1[_2] >= self.__shape[_2]))): # src/fusion/BaseVariable.monty:856:14-71
     raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([(_1[_3] - _0[_3]) for _3 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if ((_1 > _0) or ((_0 < 0) or (_1 > self.__shape[0]))): # src/fusion/BaseVariable.monty:841:12-56
    raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   elif (int((self.__shape).shape[0])!=1): # src/fusion/BaseVariable.monty:843:16-31
    raise mosek_fusion_DimensionError._ctor_S("Mismatching slice shape")
   else:
    return (mosek_fusion_NilVariable._ctor__3I(numpy.array([(_1 - _0)], dtype=numpy.dtype(numpy.int32))))
 return NilVariable
mosek_fusion_NilVariable=__mk_mosek_fusion_NilVariable()
del __mk_mosek_fusion_NilVariable
#BEFORE CLASS
def __mk_mosek_fusion_Var():
 class Var(object):
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Var._match_hstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def flatten(*args):
    if False: pass
    elif mosek_fusion_Var._match_flatten_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_flatten_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._flatten_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.flatten(mosek.fusion.Variable)')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Var._match_stack__3_3Lmosek_4fusion_4Variable_2(*args): # [][]mosek.fusion.Variable
      return mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args): # [][]mosek.fusion.Variable
      return mosek_fusion_Var._stack_alt__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_stack__3Lmosek_4fusion_4Variable_2I(*args): # []mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args): # []mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.stack(array(array(mosek.fusion.Variable,ndim=1),ndim=1))\n\tmosek.fusion.Var.stack(array(mosek.fusion.Variable,ndim=1),int32)\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32)')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32,int32)')
  @staticmethod
  def vrepeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_vrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._vrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list vrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def promote(*args):
    if False: pass
    elif mosek_fusion_Var._match_promote_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._promote_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_promote_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._promote_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list promote('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.promote(mosek.fusion.Variable,int32)')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Var._match_vstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def reshape(*args):
    if False: pass
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2_3I(*args): # mosek.fusion.Variable,[]int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args): # mosek.fusion.Variable,[]int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,array(int32,ndim=1))\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32,int32)')
  @staticmethod
  def hrepeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_hrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._hrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list hrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def empty(*args):
    if False: pass
    elif mosek_fusion_Var._match_empty__3I(*args): # []int32
      return mosek_fusion_Var._empty__3I(*args)
    elif mosek_fusion_Var._match_alt_empty__3I(*args): # []int32
      return mosek_fusion_Var._empty_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list empty('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.empty(array(int32,ndim=1))')
  @staticmethod
  def compress(*args):
    if False: pass
    elif mosek_fusion_Var._match_compress_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_compress_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._compress_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list compress('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.compress(mosek.fusion.Variable)')
  def __repr__(self): return 'mosek.fusion.Var'
  @staticmethod
  def _match_empty__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_empty__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _empty_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._empty__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _empty__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] < 0): # src/fusion/Var.monty:809:14-26
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape")
   return (mosek_fusion_NilVariable._ctor__3I(_0))
  @staticmethod
  def _match_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _compress_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _compress_Lmosek_4fusion_4Variable_2(_0):
   _1=_0.getShape()
   _2=int((_1).shape[0])
   _3=0
   for _4 in range(0,_2):
    if (_1[_4]!=1): # src/fusion/Var.monty:787:14-27
     _3 += 1
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _6=0
   for _7 in range(0,_2):
    if (_1[_7]!=1): # src/fusion/Var.monty:792:16-29
     _5[_6] = _1[_7]
     _6 += 1
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,_5))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Variable_2(_0):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,numpy.array([numpy.int32(mosek.fusion.Set._size__3I(_0.getShape()))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (_0.reshape(_1))
  @staticmethod
  def _index_1permute_1_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _4=_0.getShape()
   _5=int((_4).shape[0])
   _6=1
   for _7 in range(0,_5):
    _6 *= _4[_7]
   _8=_0.numInst()
   _9=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
   _9[(_5 - 1)] = 1
   for _10 in range(1,_5):
    _9[((_5 - _10) - 1)] = (_9[(_5 - _10)] * _4[_1[(_5 - _10)]])
   if (_8 < _6): # src/fusion/Var.monty:628:12-27
    _2 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _3 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _0.inst(0,_2,0,_3)
   else:
    _2 = None
    _3 = numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _0.inst(0,_3)
   if (_2 is None): # src/fusion/Var.monty:639:12-28
    _11=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _12=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
    for _13 in range(0,_8):
     _14=_13
     for _15 in range(0,_5):
      _12[((_5 - _13) - 1)] = (_14 % _4[((_5 - _13) - 1)])
      _14 /= _4[((_5 - _13) - 1)]
     _16=0
     for _17 in range(0,_5):
      _16 += numpy.int32((_12[_1[_17]] * _9[_17]))
     _11[_16] = _3[_13]
    _3 = _11
   else:
    _18=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _19=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
    for _20 in range(0,_8):
     _21=_20
     for _22 in range(0,_5):
      _19[((_5 - _20) - 1)] = (_21 % _4[((_5 - _20) - 1)])
      _21 /= _4[((_5 - _20) - 1)]
     _23=0
     for _24 in range(0,_5):
      _23 += numpy.int32((_19[_1[_24]] * _9[_24]))
     _18[_20] = _23
    _25=numpy.array([_26 for _26 in range(0,_8)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_25,_18,None,0,_8)
    _2 = numpy.array([_2[_25[_27]] for _27 in range(0,_8)], dtype=numpy.dtype(numpy.int64))
    _3 = numpy.array([_3[_25[_28]] for _28 in range(0,_8)], dtype=numpy.dtype(numpy.int64))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_0.getModel(),numpy.array([_4[_1[_29]] for _29 in range(0,_5)], dtype=numpy.dtype(numpy.int32)),_2,_3))
  @staticmethod
  def _match_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _hrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _hrepeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,1,_1))
  @staticmethod
  def _match_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _vrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _vrepeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,0,_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,0,_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2))
  @staticmethod
  def __drepeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __drepeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   if (_2 < 0): # src/fusion/Var.monty:474:12-17
    raise mosek_fusion_LengthError._ctor_S("Cannot repeat less than 0 times")
   elif (_2==0): # src/fusion/Var.monty:476:16-22
    return (mosek_fusion_NilVariable._ctor_())
   elif (_2==1): # src/fusion/Var.monty:478:16-22
    return (_0)
   else:
    _3=_0.getModel()
    _4=_0.getShape()
    _5=int((_4).shape[0])
    if ((_1 < 0) or (_1 > _5)): # src/fusion/Var.monty:485:14-33
     raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
    _6=mosek.fusion.Set._size__3I(_4)
    _7=_0.numInst()
    _8=(_7 * _2)
    _9=1
    for _10 in range(0,_1):
     _9 *= _4[_10]
    _11=(_4[_1] if ((_1 < _5) ) else 1)
    _12=(_11 * _2)
    _13=1
    for _14 in range((_1 + 1),_5):
     _13 *= _4[_14]
    _15=(_5 if ((_1 < _5) ) else (_1 + 1))
    _16=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int32))
    for _17 in range(0,_5):
     _16[_17] = _4[_17]
    for _18 in range(_5,_15):
     _16[_18] = 1
    _16[_1] = _12
    if (_7 < _6): # src/fusion/Var.monty:502:14-27
     _19=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _20=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _21=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
     _22=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
     _0.inst(0,_20,0,_19)
     _23=(_12 * _13)
     _24=(_11 * _13)
     _25=_13
     if (_1==0): # src/fusion/Var.monty:515:18-26
      _26=0
      for _27 in range(0,_2):
       for _28 in range(0,_7):
        _22[_26] = (_20[_28] + (_27 * _6))
        _21[_26] = _19[_28]
        _26 += 1
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_16,_22,_21))
     elif (_1 >= _5): # src/fusion/Var.monty:525:22-31
      _29=0
      for _30 in range(0,_7):
       for _31 in range(0,_2):
        _22[_29] = ((_20[_30] * _2) + _31)
        _21[_29] = _19[_30]
        _29 += 1
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_16,_22,_21))
     else:
      _32=0
      for _33 in range(0,_7):
       _34=(_20[_33] // _24)
       _35=((_20[_33] // _25) % _11)
       _36=(_20[_33] % _13)
       for _37 in range(0,_2):
        _22[_32] = (((_34 * _23) + ((_35 + (_11 * _37)) * _13)) + _36)
        _21[_32] = _19[_33]
        _32 += 1
      _38=1
      for _39 in range(0,_15):
       if (_38 < _16[_39]): # src/fusion/Var.monty:551:57-75
        _38 = _16[_39]
      _40=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
      _41=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
      _42=numpy.zeros(((_38 + 1),), dtype=numpy.dtype(numpy.int32))
      _43=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int64))
      _43[(_15 - 1)] = 1
      for _44 in range(1,_15):
       _43[((_15 - _44) - 1)] = (_43[(_15 - _44)] * _16[(_15 - _44)])
      for _45 in range(0,_8):
       _40[_45] = _45
      for _46 in range(0,_15):
       _47=((_15 - _46) - 1)
       for _48 in range(0,(_16[_47] + 1)):
        _42[_48] = 0
       for _49 in range(0,_8):
        _42[(((_22[_49] // _43[_47]) % _16[_47]) + 1)] += 1
       for _50 in range(0,_16[_47]):
        _42[(_50 + 1)] += _42[_50]
       for _51 in range(0,_8):
        _52=_40[_51]
        _53=((_22[_52] // _43[_47]) % _16[_47])
        _41[_42[_53]] = _52
        _42[_53] += 1
       _54=_40
       _40 = _41
       _41 = _54
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_16,numpy.array([_22[_40[_55]] for _55 in range(0,_8)], dtype=numpy.dtype(numpy.int64)),numpy.array([_21[_40[_56]] for _56 in range(0,_8)], dtype=numpy.dtype(numpy.int64))))
    else:
     _57=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _58=numpy.zeros(((_7 * _2),), dtype=numpy.dtype(numpy.int64))
     _0.inst(0,_57)
     _59=(_12 * _13)
     _60=_13
     _61=0
     for _62 in range(0,_9):
      for _63 in range(0,_11):
       for _64 in range(0,_13):
        for _65 in range(0,_2):
         _58[(((_62 * _59) + ((_63 + (_65 * _11)) * _60)) + _64)] = _57[_61]
        _61 += 1
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_16,None,_58))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Variable_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0[_1],1) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,1))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_I__(_3))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2,numpy.int32(__3))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2,_3):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),_3))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,numpy.int32(__2))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),_2))
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3Lmosek_4fusion_4Variable_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=_1
   for _3 in range(0,int((_0).shape[0])):
    if (_2 < _0[_3].getND()): # src/fusion/Var.monty:289:53-73
     _2 = _0[_3].getND()
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,_1))
  @staticmethod
  def _match_promote_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_promote_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _promote_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._promote_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _promote_Lmosek_4fusion_4Variable_2I(_0,_1):
   if (_1 > _0.getND()): # src/fusion/Var.monty:276:12-26
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    _3=_0.getShape()
    for _4 in range(0,int((_3).shape[0])):
     _2[_4] = _3[_4]
    for _5 in range(int((_3).shape[0]),_1):
     _2[_5] = 1
    return (_0.reshape(_2))
   else:
    return (_0)
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Variable_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_1 < 0): # src/fusion/Var.monty:155:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
   _2=None
   for _3 in range(0,int((_0).shape[0])):
    if (_2 is None): # src/fusion/Var.monty:161:16-26
     _2 = _0[_3].getModel()
    elif ((_0[_3].getModel() is not None) and (_0[_3].getModel() is not _2)): # src/fusion/Var.monty:162:20-69
     _4=mosek.fusion.Utils.StringBuffer()
     _5=(_2._getName_() if ((int(len(_2._getName_())) > 0) ) else "?")
     _6=(_0[_3].getModel()._getName_() if ((int(len(_0[_3].getModel()._getName_())) > 0) ) else "?")
     _4._a_S("Variables belong to different models: '")._a_S(_5)._a_S("' and '")._a_S(_6)._a_S("'")
     raise mosek_fusion_ModelError._ctor_S(_4._toString_())
   if (int((_0).shape[0])==0): # src/fusion/Var.monty:173:12-23
    return (mosek_fusion_NilVariable._ctor_())
   elif (int((_0).shape[0])==1): # src/fusion/Var.monty:174:16-27
    return (_0[1])
   else:
    _7=int((_0).shape[0])
    _8=numpy.array([_0[_9].numInst() for _9 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    _10=_monty.initJaggedArray([_0[_11].getShape() for _11 in range(0,_7)], 1)
    _12=numpy.array([int((_10[_13]).shape[0]) for _13 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    _14=_10[0]
    _15=_12[0]
    _16=0
    for _17 in range(0,_7):
     _16 += _8[_17]
    _18=(_1 + 1)
    for _19 in range(0,_7):
     if (_18 < _12[_19]): # src/fusion/Var.monty:184:50-62
      _18 = _12[_19]
    _20=numpy.zeros((_18,), dtype=numpy.dtype(numpy.int32))
    for _21 in range(0,_15):
     _20[_21] = _14[_21]
    for _22 in range(_15,_18):
     _20[_22] = 1
    _20[_1] = 0
    for _23 in range(0,_7):
     _20[_1] += (_10[_23][_1] if ((int((_10[_23]).shape[0]) > _1) ) else 1)
    for _24 in range(0,_7):
     for _25 in range(0,int((_10[_24]).shape[0])):
      if ((_25!=_1) and (_10[_24][_25]!=_20[_25])): # src/fusion/Var.monty:191:18-56
       raise mosek_fusion_DimensionError._ctor_S("Variable dimensions do not match")
     for _26 in range(int((_10[_24]).shape[0]),_18):
      if ((_26!=_1) and (1!=_20[_26])): # src/fusion/Var.monty:194:18-45
       raise mosek_fusion_DimensionError._ctor_S("Variable dimensions do not match")
    _27=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
    _28=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
    _29=numpy.array([(_10[_30][_1] if ((_1 < int((_10[_30]).shape[0])) ) else 1) for _30 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
    _31=1
    for _32 in range(0,_1):
     _31 *= (_14[_32] if ((_32 < int((_14).shape[0])) ) else 1)
    _33=0
    for _34 in range(0,_7):
     _33 += _29[_34]
    _35=1
    for _36 in range((_1 + 1),int((_14).shape[0])):
     _35 *= _14[_36]
    if (_31==1): # src/fusion/Var.monty:206:14-21
     _37=0
     _38=0
     for _39 in range(0,_7):
      _0[_39].inst(_37,_28,_37,_27)
      for _40 in range(0,_8[_39]):
       _28[_37] += _38
       _37 += 1
      _38 += mosek.fusion.Set._size__3I(_10[_39])
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_2,_20,(_28 if ((_16 < ((_31 * _33) * _35)) ) else None),_27))
    else:
     _41=0
     for _42 in range(0,_7):
      _41 += _0[_42].inst(_41,_28,_41,_27)
     _43=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int32))
     _44=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int32))
     _45=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     for _46 in range(0,(_7 - 1)):
      _45[(_46 + 1)] = (_45[_46] + _29[_46])
     for _47 in range(0,_16):
      _43[_47] = _47
     _48=0
     for _49 in range(0,_7):
      for _50 in range(0,_8[_49]):
       _51=(_28[_48] // (_29[_49] * _35))
       _52=((_28[_48] // _35) % _29[_49])
       _53=(_28[_48] % _35)
       _28[_48] = (((((_51 * _33) + _52) + _45[_49]) * _35) + _53)
       _48 += 1
     _54=1
     for _55 in range(0,_18):
      _54 = (_20[_55] if ((_54 < _20[_55]) ) else _54)
     _56=numpy.zeros((_18,), dtype=numpy.dtype(numpy.int64))
     _56[(_18 - 1)] = 1
     for _57 in range(1,_18):
      _56[((_18 - _57) - 1)] = (_56[(_18 - _57)] * _20[(_18 - _57)])
     _58=numpy.zeros(((_54 + 1),), dtype=numpy.dtype(numpy.int32))
     for _59 in range(0,_18):
      _60=((_18 - _59) - 1)
      for _61 in range(0,(_20[_60] + 1)):
       _58[_61] = 0
      for _62 in range(0,_16):
       _58[(((_28[_62] // _56[_60]) % _20[_60]) + 1)] += 1
      for _63 in range(0,_20[_60]):
       _58[(_63 + 1)] += _58[_63]
      for _64 in range(0,_16):
       _65=_43[_64]
       _66=((_28[_65] // _56[_60]) % _20[_60])
       _44[_58[_66]] = _65
       _58[_66] += 1
      _67=_43
      _43 = _44
      _44 = _67
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_2,_20,(numpy.array([_28[_43[_68]] for _68 in range(0,_16)], dtype=numpy.dtype(numpy.int64)) if ((_16 < ((_31 * _33) * _35)) ) else None),numpy.array([_27[_43[_69]] for _69 in range(0,_16)], dtype=numpy.dtype(numpy.int64))))
 return Var
mosek_fusion_Var=__mk_mosek_fusion_Var()
del __mk_mosek_fusion_Var
#BEFORE CLASS
def __mk_mosek_fusion_ConstraintCache():
 class ConstraintCache(object):
  __slots__ = ['barmatidx','barsubj','barsubi','nbarnz','nunordered','buffer_subi','buffer_subj','buffer_cof','bfix','cof','subi','subj','nnz','nrows']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3D_3I_3D_3I_3I_3I(*args): # []int64,[]double,[]int32,[]double,[]int32,[]int32,[]int32
      self._ctor_init__3J_3D_3I_3D_3I_3I_3I(*args)
    elif self.__match_alt_ctor__3J_3D_3I_3D_3I_3I_3I(*args):# []int64,[]double,[]int32,[]double,[]int32,[]int32,[]int32
      self._ctor_alt_init__3J_3D_3I_3D_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ConstraintCache.ctor(array(int64,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def flush(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_flush__3I_3I_3D_3D(*args): # []int32,[]int32,[]double,[]double
      return self._flush__3I_3I_3D_3D(*args)
    elif mosek_fusion_ConstraintCache._match_alt_flush__3I_3I_3D_3D(*args): # []int32,[]int32,[]double,[]double
      return self._flush_alt__3I_3I_3D_3D(*args)
    else:
      raise ValueError('Invalid argument list flush('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.flush(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1))')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_add__3J_3I_3D_3D(*args): # []int64,[]int32,[]double,[]double
      return self._add__3J_3I_3D_3D(*args)
    elif mosek_fusion_ConstraintCache._match_alt_add__3J_3I_3D_3D(*args): # []int64,[]int32,[]double,[]double
      return self._add_alt__3J_3I_3D_3D(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.add(array(int64,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1))')
  def numUnsorted(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_numUnsorted_(*args): # 
      return self._numUnsorted_(*args)
    elif mosek_fusion_ConstraintCache._match_alt_numUnsorted_(*args): # 
      return self._numUnsorted_alt_(*args)
    else:
      raise ValueError('Invalid argument list numUnsorted('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.numUnsorted()')
  def __repr__(self): return 'mosek.fusion.ConstraintCache'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConstraintCache_2(cc):
    o = ConstraintCache.__new__(ConstraintCache)
    o._ctor_init_Lmosek_4fusion_4ConstraintCache_2(cc)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConstraintCache_2(*args):
    if len(args) != 1: return False
    cc, = args
    return (__arg_match_Lmosek_4fusion_4ConstraintCache_2__(cc))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConstraintCache_2(*args):
    if len(args) != 1: return False
    cc, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConstraintCache_2__(cc))
  def _ctor_alt_init_Lmosek_4fusion_4ConstraintCache_2(self,cc):
    self._ctor_init_Lmosek_4fusion_4ConstraintCache_2(cc)
  def _ctor_init_Lmosek_4fusion_4ConstraintCache_2(self,cc):
   self.nrows = (cc.nrows)
   self.nnz = (cc.nnz)
   self.subj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.subj)) if (((cc.subj) is not None) ) else None)
   self.subi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.subi)) if (((cc.subi) is not None) ) else None)
   self.cof = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.cof)) if (((cc.cof) is not None) ) else None)
   self.bfix = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.bfix)) if (((cc.bfix) is not None) ) else None)
   self.buffer_cof = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.buffer_cof)) if (((cc.buffer_cof) is not None) ) else None)
   self.buffer_subj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.buffer_subj)) if (((cc.buffer_subj) is not None) ) else None)
   self.buffer_subi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.buffer_subi)) if (((cc.buffer_subi) is not None) ) else None)
   self.nunordered = (cc.nunordered)
   self.nbarnz = (cc.nbarnz)
   self.barsubi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barsubi)) if (((cc.barsubi) is not None) ) else None)
   self.barsubj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barsubj)) if (((cc.barsubj) is not None) ) else None)
   self.barmatidx = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barmatidx)) if (((cc.barmatidx) is not None) ) else None)
  @staticmethod
  def _ctor__3J_3D_3I_3D_3I_3I_3I(ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
    o = ConstraintCache.__new__(ConstraintCache)
    o._ctor_init__3J_3D_3I_3D_3I_3I_3I(ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_)
    return o
  @staticmethod
  def __match_ctor__3J_3D_3I_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3D__(cof_) and __arg_match__3I__(subj_) and __arg_match__3D__(bfix_) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barmatidx_))
  @staticmethod
  def __match_alt_ctor__3J_3D_3I_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barmatidx_))
  def _ctor_alt_init__3J_3D_3I_3D_3I_3I_3I(self,ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
    self._ctor_init__3J_3D_3I_3D_3I_3I_3I(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barmatidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3J_3D_3I_3D_3I_3I_3I(self,ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
   assert ptrb_ is None or isinstance(ptrb_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert bfix_ is None or isinstance(bfix_,numpy.ndarray)
   assert barsubi_ is None or isinstance(barsubi_,numpy.ndarray)
   assert barsubj_ is None or isinstance(barsubj_,numpy.ndarray)
   assert barmatidx_ is None or isinstance(barmatidx_,numpy.ndarray)
   self.nrows = (int((ptrb_).shape[0]) - 1)
   self.nnz = ptrb_[(int((ptrb_).shape[0]) - 1)]
   self.subj = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.int32))
   self.subi = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.int32))
   self.cof = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.float64))
   if (bfix_ is not None): # src/fusion/ConstraintCache.mbi:73:12-25
    self.bfix = bfix_
   else:
    self.bfix = numpy.zeros((self.nrows,), dtype=numpy.dtype(numpy.float64))
   if ((barsubi_ is not None) and ((barsubj_ is not None) and (barmatidx_ is not None))): # src/fusion/ConstraintCache.mbi:76:13-78:31
    self.nbarnz = int((barsubi_).shape[0])
    if (self.nbarnz > int((barsubj_).shape[0])): # src/fusion/ConstraintCache.mbi:81:14-36
     self.nbarnz = int((barsubj_).shape[0])
    if (self.nbarnz > int((barmatidx_).shape[0])): # src/fusion/ConstraintCache.mbi:82:14-38
     self.nbarnz = int((barmatidx_).shape[0])
    self.barsubi = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    self.barsubj = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    self.barmatidx = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barsubi_,0,self.barsubi,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barsubj_,0,self.barsubj,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barmatidx_,0,self.barmatidx,0,self.nbarnz)
   else:
    self.nbarnz = 0
    self.barsubi = None
    self.barsubj = None
    self.barmatidx = None
   mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(subj_,0,self.subj,0,self.nnz)
   mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(cof_,0,self.cof,0,self.nnz)
   for _0 in range(0,self.nrows):
    for _1 in range(ptrb_[_0],ptrb_[(_0 + 1)]):
     self.subi[_1] = _0
   self.buffer_cof = None
   self.buffer_subj = None
   self.buffer_subi = None
   self.nunordered = 0
  def _unchecked_1add_1fx_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._unchecked_1add_1fx__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _unchecked_1add_1fx__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   for _1 in range(0,self.nrows):
    self.bfix[_1] = (self.bfix[_1] + _0[_1])
  def _order_1barentries_alt_(self,):
    return self._order_1barentries_()
  def _order_1barentries_(self,):
   _0=numpy.array([_1 for _1 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int64))
   if (not mosek.fusion.Sort._issorted__3J_3I_3IJJZ(_0,self.barsubi,self.barsubj,0,self.nbarnz,False)): # src/fusion/ConstraintCache.mbi:458:12-66
    mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,self.barsubi,self.barsubj,0,self.nbarnz,False)
    _2=self.barsubi
    _3=self.barsubj
    _4=self.barmatidx
    self.barsubi = numpy.array([_2[_0[_5]] for _5 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
    self.barsubj = numpy.array([_3[_0[_6]] for _6 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
    self.barmatidx = numpy.array([_4[_0[_7]] for _7 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
   return numpy.int64(self.nbarnz)
  def _add_1bar_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._add_1bar__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1bar__3I_3I_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_0 is not None): # src/fusion/ConstraintCache.mbi:424:12-28
    _3=int((_0).shape[0])
    if (int((_0).shape[0]) <= (self.nbarnz + _3)): # src/fusion/ConstraintCache.mbi:427:15-50
     _4=self.barsubi
     _5=self.barsubj
     _6=self.barmatidx
     _7=((2 * self.nbarnz) if (((2 * self.nbarnz) > (self.nbarnz + _3)) ) else (self.nbarnz + (_3 * 2)))
     self.barsubi = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     self.barsubj = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     self.barmatidx = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     if (self.nbarnz > 0): # src/fusion/ConstraintCache.mbi:440:16-26
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_4,0,self.barsubi,0,self.nbarnz)
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_5,0,self.barsubj,0,self.nbarnz)
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_6,0,self.barmatidx,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_0,0,self.barsubi,self.nbarnz,_3)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_1,0,self.barsubj,self.nbarnz,_3)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_2,0,self.barmatidx,self.nbarnz,_3)
    self.nbarnz += _3
  def _unchecked_1add_1l_alt__3J_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._unchecked_1add_1l__3J_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _unchecked_1add_1l__3J_3I_3D_3D(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=(self.nunordered + _0[self.nrows])
   _5=_0[self.nrows]
   if ((self.buffer_cof is None) or (int((self.buffer_cof).shape[0]) < _4)): # src/fusion/ConstraintCache.mbi:381:13-382:37
    _6 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    _7 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    _8 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
    if (self.buffer_cof is not None): # src/fusion/ConstraintCache.mbi:388:14-32
     mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self.buffer_subi,0,_6,0,self.nunordered)
     mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self.buffer_subj,0,_7,0,self.nunordered)
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self.buffer_cof,0,_8,0,self.nunordered)
   else:
    _6 = self.buffer_subi
    _7 = self.buffer_subj
    _8 = self.buffer_cof
   for _9 in range(0,self.nrows):
    for _10 in range(_0[_9],_0[(_9 + 1)]):
     _6[(self.nunordered + _10)] = _9
   mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_1,0,_7,self.nunordered,_5)
   mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_2,0,_8,self.nunordered,_5)
   self.buffer_subi = _6
   self.buffer_subj = _7
   self.buffer_cof = _8
   if (_3 is not None): # src/fusion/ConstraintCache.mbi:412:17-30
    for _11 in range(0,self.nrows):
     self.bfix[_11] = (self.bfix[_11] + _3[_11])
   self.nunordered = _4
  @staticmethod
  def _match_add__3J_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3D__(_3))
  @staticmethod
  def _match_alt_add__3J_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3D__(_3))
  def _add_alt__3J_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._add__3J_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add__3J_3I_3D_3D(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   if ((int((_0).shape[0])!=(self.nrows + 1)) or ((_3 is not None) and (int((_3).shape[0])!=self.nrows))): # src/fusion/ConstraintCache.mbi:353:17-354:56
    raise mosek_fusion_LengthError._ctor_S("Mismatching expression lengths")
   self._unchecked_1add_1l__3J_3I_3D_3D(_0,_1,_2,_3)
  @staticmethod
  def _match_flush__3I_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3D__(_3))
  @staticmethod
  def _match_alt_flush__3I_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3D__(_3))
  def _flush_alt__3I_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._flush__3I_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _flush__3I_3I_3D_3D(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=None
   if ((self.bfix is not None) and (_3 is not None)): # src/fusion/ConstraintCache.mbi:169:12-44
    for _5 in range(0,self.nrows):
     _3[_5] = self.bfix[_5]
   if (self.nunordered==0): # src/fusion/ConstraintCache.mbi:173:12-28
    return numpy.int64(0)
   _6=False
   _7=1
   while ((_7 < self.nunordered) and ((self.buffer_subi[(_7 - 1)] < self.buffer_subi[_7]) or ((self.buffer_subi[(_7 - 1)]==self.buffer_subi[_7]) and (self.buffer_subj[(_7 - 1)] <= self.buffer_subj[_7])))):
    _7 += 1
   _6 = (_7==self.nunordered)
   if (not _6): # src/fusion/ConstraintCache.mbi:185:12-26
    _4 = numpy.array([_8 for _8 in range(0,self.nunordered)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_4,self.buffer_subi,self.buffer_subj,0,self.nunordered)
   _9=self.nnz
   _10=numpy.zeros(((self.nunordered + _9),), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros(((self.nunordered + _9),), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros(((self.nunordered + _9),), dtype=numpy.dtype(numpy.float64))
   _13=0
   if _6: # src/fusion/ConstraintCache.mbi:198:12-22
    _14=0
    _15=0
    _16=self.nunordered
    _17=_9
    _18=0
    _19=0
    while ((_19 < _17) and (_18 < _16)):
     if ((self.subi[_19] < self.buffer_subi[_18]) or ((self.subi[_19]==self.buffer_subi[_18]) and (self.subj[_19] < self.buffer_subj[_18]))): # src/fusion/ConstraintCache.mbi:208:21-210:52
      _10[_15] = self.subi[_19]
      _11[_15] = self.subj[_19]
      _12[_15] = self.cof[_19]
      _19 += 1
      _15 += 1
     elif ((self.subi[_19] > self.buffer_subi[_18]) or ((self.subi[_19]==self.buffer_subi[_18]) and (self.subj[_19] > self.buffer_subj[_18]))): # src/fusion/ConstraintCache.mbi:217:21-219:51
      _10[_15] = self.buffer_subi[_18]
      _11[_15] = self.buffer_subj[_18]
      _12[_15] = self.buffer_cof[_18]
      _0[_13] = _10[_15]
      _1[_13] = _11[_15]
      _2[_13] = _12[_15]
      _13 += 1
      _18 += 1
      _15 += 1
     else:
      _10[_15] = self.subi[_19]
      _11[_15] = self.subj[_19]
      _12[_15] = self.cof[_19]
      while ((_19 < int((self.subi).shape[0])) and ((_18 < int((self.buffer_subi).shape[0])) and ((self.subi[_19]==self.buffer_subi[_18]) and (self.subj[_19]==self.buffer_subj[_18])))):
       _12[_15] = (_12[_15] + self.buffer_cof[_18])
       _18 += 1
      _0[_13] = _10[_15]
      _1[_13] = _11[_15]
      _2[_13] = _12[_15]
      _13 += 1
      _19 += 1
      _15 += 1
    while (_19 < _17):
     _10[_15] = self.subi[_19]
     _11[_15] = self.subj[_19]
     _12[_15] = self.cof[_19]
     _19 += 1
     _15 += 1
    while (_18 < _16):
     _10[_15] = self.buffer_subi[_18]
     _11[_15] = self.buffer_subj[_18]
     _12[_15] = self.buffer_cof[_18]
     _0[_13] = _10[_15]
     _1[_13] = _11[_15]
     _2[_13] = _12[_15]
     _13 += 1
     _18 += 1
     _15 += 1
    self.nnz = _15
   else:
    _20=0
    _21=0
    _22=self.nunordered
    _23=_9
    _24=0
    _25=0
    while ((_25 < _23) and (_24 < _22)):
     if ((self.subi[_25] < self.buffer_subi[_4[_24]]) or ((self.subi[_25]==self.buffer_subi[_4[_24]]) and (self.subj[_25] < self.buffer_subj[_4[_24]]))): # src/fusion/ConstraintCache.mbi:284:21-129
      _10[_21] = self.subi[_25]
      _11[_21] = self.subj[_25]
      _12[_21] = self.cof[_25]
      _25 += 1
      _21 += 1
     elif ((self.subi[_25] > self.buffer_subi[_4[_24]]) or ((self.subi[_25]==self.buffer_subi[_4[_24]]) and (self.subj[_25] > self.buffer_subj[_4[_24]]))): # src/fusion/ConstraintCache.mbi:291:21-129
      _10[_21] = self.buffer_subi[_4[_24]]
      _11[_21] = self.buffer_subj[_4[_24]]
      _12[_21] = self.buffer_cof[_4[_24]]
      _0[_13] = _10[_21]
      _1[_13] = _11[_21]
      _2[_13] = _12[_21]
      _13 += 1
      _24 += 1
      _21 += 1
     else:
      _10[_21] = self.subi[_25]
      _11[_21] = self.subj[_25]
      _12[_21] = self.cof[_25]
      while ((self.subi[_25]==self.buffer_subi[_4[_24]]) and (self.subj[_25]==self.buffer_subj[_4[_24]])):
       _12[_21] = (_12[_21] + self.buffer_cof[_4[_24]])
       _24 += 1
      _0[_13] = _10[_21]
      _1[_13] = _11[_21]
      _2[_13] = _12[_21]
      _13 += 1
      _25 += 1
      _21 += 1
    self.nnz = _21
   self.subi = _10
   self.subj = _11
   self.cof = _12
   self.nunordered = 0
   return numpy.int64(_13)
  @staticmethod
  def _match_numUnsorted_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numUnsorted_(*args):
    if len(args) != 0: return False
    return True
  def _numUnsorted_alt_(self,):
    return self._numUnsorted_()
  def _numUnsorted_(self,):
   return numpy.int64(self.nunordered)
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_ConstraintCache._ctor_Lmosek_4fusion_4ConstraintCache_2(self))
 return ConstraintCache
mosek_fusion_ConstraintCache=__mk_mosek_fusion_ConstraintCache()
del __mk_mosek_fusion_ConstraintCache
#BEFORE CLASS
def __mk_mosek_fusion_Constraint():
 class Constraint(object):
  __slots__ = ['_Constraint__nativeidxs','_Constraint__shape','_Constraint__model']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Constraint,mosek.fusion.Model
      self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):# mosek.fusion.Constraint,mosek.fusion.Model
      self._ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args): # mosek.fusion.Model,[]int32,[]int32
      self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):# mosek.fusion.Model,[]int32,[]int32
      self._ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Constraint,mosek.fusion.Model)\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Model,array(int32,ndim=1),array(int32,ndim=1))')
  def get_model(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_get_1model_(*args): # 
      return self._get_1model_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1model_(*args): # 
      return self._get_1model_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_model('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_model()')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Constraint._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getND()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Constraint._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getShape()')
  def get_nd(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_get_1nd_(*args): # 
      return self._get_1nd_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1nd_(*args): # 
      return self._get_1nd_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_nd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_nd()')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_stack__3Lmosek_4fusion_4Constraint_2I(*args): # []mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack__3Lmosek_4fusion_4Constraint_2I(*args): # []mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_alt__3Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.stack(array(mosek.fusion.Constraint,ndim=1),int32)\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,int32)\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32)')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Constraint._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.size()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Constraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Constraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Constraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.slice(int32,int32)\n\tmosek.fusion.Constraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Constraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.toString()')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_Constraint._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.dual()')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_hstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_alt__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.hstack(array(mosek.fusion.Constraint,ndim=1))\n\tmosek.fusion.Constraint.hstack(mosek.fusion.Constraint,mosek.fusion.Constraint)\n\tmosek.fusion.Constraint.hstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Constraint._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getModel()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Constraint._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getSize()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Constraint._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Constraint._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Constraint._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.index(int32)\n\tmosek.fusion.Constraint.index(array(int32,ndim=1))')
  def update(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._update_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._update_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_update__3D(*args): # []double
      return self._update__3D(*args)
    elif mosek_fusion_Constraint._match_alt_update__3D(*args): # []double
      return self._update_alt__3D(*args)
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args): # mosek.fusion.Expression,mosek.fusion.Variable,bool
      return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args): # mosek.fusion.Expression,mosek.fusion.Variable,bool
      return self._update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args)
    else:
      raise ValueError('Invalid argument list update('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression)\n\tmosek.fusion.Constraint.update(array(double,ndim=1))\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression,mosek.fusion.Variable,bool)')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_Constraint._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.level()')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_vstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_alt__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.vstack(array(mosek.fusion.Constraint,ndim=1))\n\tmosek.fusion.Constraint.vstack(mosek.fusion.Constraint,mosek.fusion.Constraint)\n\tmosek.fusion.Constraint.vstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.Constraint: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
   self.__model = m
   self.__shape = (c.__shape)
   self.__nativeidxs = (c.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   (self.__model) = model
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   raise mosek_fusion_UnimplementedError._ctor_S("Constraint.toString")
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__values_ZI_3D(False,0,_0)
   return (_0)
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _0=numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__values_ZI_3D(True,0,_0)
   return (_0)
  def __values_alt_ZI_3D(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__values_ZI_3D(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __values_ZI_3D(self,_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   self.__model.getConstraintValues(_0,self.__nativeidxs,_2,_1)
  @staticmethod
  def _match_update__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_update__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _update_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._update__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _update__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   self.__model._update_1bfix__3I_3D(self.__nativeidxs,_0)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  def _update_alt_Lmosek_4fusion_4Expression_2(self,_t__0):
    return self._update_Lmosek_4fusion_4Expression_2(_0)
  def _update_Lmosek_4fusion_4Expression_2(self,_0):
   _1=_0.getShape()
   if (int((self.__shape).shape[0]) < int((_1).shape[0])): # src/fusion/Constraint.mbi:591:12-36
    raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _2 in range(0,int((_1).shape[0])):
    if (_1[_2]!=self.__shape[_2]): # src/fusion/Constraint.mbi:594:14-35
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _3 in range(int((_1).shape[0]),int((self.__shape).shape[0])):
    if (self.__shape[_3]!=1): # src/fusion/Constraint.mbi:597:14-27
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   self.__model._update__3ILmosek_4fusion_4Expression_2(self.__nativeidxs,_0)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Z__(_2))
  def _update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(self,_t__0,_t__1,_t__2):
    return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(_0,_1,_2)
  def _update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(self,_0,_1,_2):
   _3=self.getND()
   _4=_0.getShape()
   if (_3 < int((_4).shape[0])): # src/fusion/Constraint.mbi:542:12-28
    raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _5 in range(0,int((_4).shape[0])):
    if (_4[_5]!=self.__shape[_5]): # src/fusion/Constraint.mbi:545:14-35
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _6 in range(int((_4).shape[0]),int((self.__shape).shape[0])):
    if (self.__shape[_6]!=1): # src/fusion/Constraint.mbi:548:14-27
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   _7=_1.numInst()
   _8=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
   if (_7 < _1.getSize()): # src/fusion/Constraint.mbi:553:12-28
    _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _1.inst(0,_9,0,_8)
   else:
    _1.inst(0,_8)
   for _10 in range(0,_7):
    if (_8[_10] < 0): # src/fusion/Constraint.mbi:561:14-28
     raise mosek_fusion_UnimplementedError._ctor_S("Updating semidefinite terms is currently not possible")
   _12=True
   for _13 in range(0,(_7 - 1)):
    _12 = (_12 and (_8[_13] < _8[(_13 + 1)]))
   if _12: # src/fusion/Constraint.mbi:569:14-22
    _11 = numpy.array([numpy.int32((_8[_14] - 1)) for _14 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
   else:
    _15=numpy.array([_16 for _16 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_15,_8,None,0,_7)
    _17=1
    for _18 in range(1,_7):
     if (_8[_15[(_18 - 1)]] < _8[_15[_18]]): # src/fusion/Constraint.mbi:575:36-73
      _17 += 1
    _11 = numpy.zeros((_17,), dtype=numpy.dtype(numpy.int32))
    _19=0
    _11[0] = numpy.int32((_8[_15[0]] - 1))
    for _20 in range(1,_7):
     if (_8[(_20 - 1)] < _8[_20]): # src/fusion/Constraint.mbi:579:36-61
      _11[_19] = numpy.int32((_8[_15[_20]] - 1))
      _19 += 1
   self.__model._update__3ILmosek_4fusion_4Expression_2_3IZ(self.__nativeidxs,_0,_11,_2)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  def _update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_t__0,_t__1):
    return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  def _update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_0,_1):
   self.update(_0,_1,False)
  @staticmethod
  def _match_get_1model_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1model_(*args):
    if len(args) != 0: return False
    return True
  def _get_1model_alt_(self,):
    return self._get_1model_()
  def _get_1model_(self,):
   return (self.__model)
  @staticmethod
  def _match_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  def _get_1nd_alt_(self,):
    return self._get_1nd_()
  def _get_1nd_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   _0=1
   for _1 in range(0,int((self.__shape).shape[0])):
    _0 *= self.__shape[_1]
   return numpy.int64(_0)
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Constraint_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3Lmosek_4fusion_4Constraint_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,_1))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2) and __arg_alt_match_I__(_3))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,_2,numpy.int32(__3))
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,_2,_3):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),_3))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,numpy.int32(__2))
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),_2))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Constraint._hstack__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Constraint_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,1))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Constraint._vstack__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Constraint_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1):
    return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1):
    return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Constraint_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Constraint_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=None
   for _3 in range(0,int((_0).shape[0])):
    if (_2 is None): # src/fusion/Constraint.mbi:305:16-26
     _2 = _0[_3].getModel()
    elif (((_0[_3].__model) is not None) and ((_0[_3].__model) is not _2)): # src/fusion/Constraint.mbi:306:20-59
     _4=mosek.fusion.Utils.StringBuffer()
     _5=(_2._getName_() if ((int(len(_2._getName_())) > 0) ) else "?")
     _6=(_0[_3].getModel()._getName_() if ((int(len(_0[_3].getModel()._getName_())) > 0) ) else "?")
     _4._a_S("Constraints belong to different models: '")._a_S(_5)._a_S("' and '")._a_S(_6)._a_S("'")
     raise mosek_fusion_ModelError._ctor_S(_4._toString_())
   if (int((_0).shape[0])==0): # src/fusion/Constraint.mbi:317:12-23
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(None,numpy.array([0], dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
   elif (int((_0).shape[0])==1): # src/fusion/Constraint.mbi:318:16-27
    return (_0[1])
   else:
    _7=int((_0).shape[0])
    _8=1
    for _9 in range(0,_7):
     _8 = (_0[_9].getND() if ((_0[_9].getND() > _8) ) else _8)
    if (_1==_8): # src/fusion/Constraint.mbi:323:14-23
     _8 += 1
    _10=numpy.zeros((_7,_8,), dtype=numpy.dtype(numpy.int32))
    for _11 in range(0,_7):
     for _12 in range(0,_8):
      _10[_11,_12] = 1
    _13=numpy.array([_0[_14].getSize() for _14 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    _15=0
    for _16 in range(0,_7):
     _15 += _13[_16]
    for _17 in range(0,_7):
     _18=_0[_17].getShape()
     for _19 in range(0,int((_18).shape[0])):
      _10[_17,_19] = _18[_19]
    if ((_1 < 0) or (_1 > _8)): # src/fusion/Constraint.mbi:340:14-33
     raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
    for _20 in range(0,_1):
     for _21 in range(1,_7):
      if (_10[0,_20]!=_10[_21,_20]): # src/fusion/Constraint.mbi:345:18-42
       raise mosek_fusion_DimensionError._ctor_S("Constraint dimensions do not match")
    for _22 in range((_1 + 1),_8):
     for _23 in range(1,_7):
      if (_10[0,_22]!=_10[_23,_22]): # src/fusion/Constraint.mbi:350:18-42
       raise mosek_fusion_DimensionError._ctor_S("Constraint dimensions do not match")
    _24=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int32))
    _25=numpy.array([_10[0,_26] for _26 in range(0,_8)], dtype=numpy.dtype(numpy.int32))
    for _27 in range(0,_8):
     _25[_1] += _10[_27,_1]
    _28=int((_25).shape[0])
    _29=numpy.zeros(((int((_0).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
    for _30 in range(0,int((_0).shape[0])):
     _29[(_30 + 1)] = (_29[_30] + _10[_30,_1])
    if (_1==0): # src/fusion/Constraint.mbi:363:16-24
     _31=0
     for _32 in range(0,_7):
      _33=int(((_0[_32].__nativeidxs)).shape[0])
      mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0[_32].__nativeidxs),0,_24,_31,_33)
      _31 += _33
    else:
     _34=_monty.initJaggedArray([(_0[_35].__nativeidxs) for _35 in range(0,_7)], 1)
     if (_1 < _8): # src/fusion/Constraint.mbi:374:18-26
      _36=1
      for _37 in range(0,_1):
       _36 *= _25[_37]
      _38=1
      for _39 in range((_1 + 1),_8):
       _38 *= _25[_39]
      _40=0
      for _41 in range(0,_36):
       for _42 in range(0,_7):
        _43=0
        _44=_10[_42,_1]
        for _45 in range(0,_44):
         for _46 in range(0,_38):
          _24[_40] = (_0[_7].__nativeidxs)[(((_41 * _38) * _44) + _43)]
          _40 += 1
          _43 += 1
     else:
      _47=1
      for _48 in range(0,_8):
       _47 *= _25[_48]
      _49=0
      for _50 in range(0,_47):
       for _51 in range(0,_7):
        _24[_49] = _34[_51][_50]
        _49 += 1
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(_2,_25,_24))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])!=int((self.__shape).shape[0])): # src/fusion/Constraint.mbi:272:12-35
    raise mosek_fusion_DimensionError._ctor_S("variable shape and slice do not match")
   else:
    for _1 in range(0,int((self.__shape).shape[0])):
     if ((_0[_1] < 0) or (_0[_1] > self.__shape[_1])): # src/fusion/Constraint.mbi:276:16-49
      raise mosek_fusion_IndexError._ctor_S("index is out of bounds")
    _2=int((self.__shape).shape[0])
    _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _3[(_2 - 1)] = 1
    for _4 in range(1,_2):
     _3[((_2 - _4) - 1)] = (_3[(_2 - _4)] * self.__shape[_4])
    _5=0
    for _6 in range(0,_2):
     _5 += numpy.int32((_3[_6] * _0[_6]))
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.array([self.__nativeidxs[_5]], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   if ((int((self.__shape).shape[0])==0) and (_0==0)): # src/fusion/Constraint.mbi:257:12-40
    return (self)
   elif (int((self.__shape).shape[0])!=1): # src/fusion/Constraint.mbi:259:16-31
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   elif ((_0 < 0) or (_0 > self.__shape[0])): # src/fusion/Constraint.mbi:261:16-41
    raise mosek_fusion_IndexError._ctor_S("Index is out of bounds")
   else:
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.array([self.__nativeidxs[_0]], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])): # src/fusion/Constraint.mbi:199:12-37
    raise mosek_fusion_SliceError._ctor_S("invalid slice")
   elif (int((_0).shape[0])!=int((self.__shape).shape[0])): # src/fusion/Constraint.mbi:201:16-41
    raise mosek_fusion_DimensionError._ctor_S("variable shape and slice do not match")
   else:
    for _2 in range(0,int((self.__shape).shape[0])):
     if ((_0[_2] < 0) or (_1[_2] > self.__shape[_2])): # src/fusion/Constraint.mbi:205:16-52
      raise mosek_fusion_IndexError._ctor_S("slice is out of bounds")
     elif (_0[_2] > _1[_2]): # src/fusion/Constraint.mbi:207:20-40
      raise mosek_fusion_SliceError._ctor_S("invalid slice")
    _3=int((self.__shape).shape[0])
    _4=numpy.array([(_1[_5] - _0[_5]) for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
    _6=1
    for _7 in range(0,_3):
     _6 *= (_1[_7] - _0[_7])
    if (_6==0): # src/fusion/Constraint.mbi:214:14-28
     return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,_4,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
    else:
     _8=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     _9=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
     _9[(_3 - 1)] = 1
     for _10 in range(1,_3):
      _9[((_3 - _10) - 1)] = (_9[(_3 - _10)] * self.__shape[(_3 - _10)])
     _11=0
     for _12 in range(0,_3):
      _11 += (_0[_12] * _9[_12])
     _13=numpy.array([_11 for _14 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     _15=numpy.array([_0[_16] for _16 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
     for _17 in range(0,_6):
      _8[_17] = self.__nativeidxs[_13[(_3 - 1)]]
      _15[(_3 - 1)] += 1
      _13[(_3 - 1)] += _9[(_3 - 1)]
      if (_15[(_3 - 1)] >= _1[(_3 - 1)]): # src/fusion/Constraint.mbi:232:20-43
       _18=(_3 - 1)
       while ((_18 > 0) and (_15[_18] >= _1[_18])):
        _15[_18] = _0[_18]
        _15[(_18 - 1)] += 1
        _13[(_18 - 1)] += _9[(_18 - 1)]
        _18 -= 1
       for _19 in range((_18 + 1),_3):
        _13[_19] = _13[_18]
     return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.getModel(),_4,_8))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (int((self.__shape).shape[0])!=1): # src/fusion/Constraint.mbi:174:12-27
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   if ((_0==0) and (_1==self.__shape[0])): # src/fusion/Constraint.mbi:176:12-43
    return (self)
   elif ((_0 < 0) or (_1 > self.__shape[0])): # src/fusion/Constraint.mbi:178:16-44
    raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   elif (_0 > _1): # src/fusion/Constraint.mbi:180:16-28
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   else:
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.array([(_1 - _0)], dtype=numpy.dtype(numpy.int32)),numpy.array([self.__nativeidxs[_2] for _2 in range(_0,_1)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   _0=1
   for _1 in range(0,int((self.__shape).shape[0])):
    _0 *= self.__shape[_1]
   return numpy.int32(_0)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (numpy.array([self.__shape[_0] for _0 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32)))
 return Constraint
mosek_fusion_Constraint=__mk_mosek_fusion_Constraint()
del __mk_mosek_fusion_Constraint
#BEFORE CLASS
def __mk_mosek_fusion_SliceConstraint():
 class SliceConstraint(mosek_fusion_Constraint):
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SliceConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SliceConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceConstraint.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.SliceConstraint: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs):
    o = SliceConstraint.__new__(SliceConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SliceConstraint()")
   return (_0._toString_())
 return SliceConstraint
mosek_fusion_SliceConstraint=__mk_mosek_fusion_SliceConstraint()
del __mk_mosek_fusion_SliceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ModelConstraint():
 class ModelConstraint(mosek_fusion_Constraint):
  __slots__ = ['_ModelConstraint__shape','_ModelConstraint__nativeidxs','_ModelConstraint__names_flushed','_ModelConstraint__name']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ModelConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ModelConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ModelConstraint: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__name = (c.__name)
   self.__names_flushed = (c.__names_flushed)
   self.__nativeidxs = (c.__nativeidxs)
   self.__shape = (c.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3I_3I(model,name,shape,nidxs):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(model,name,shape,nidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3I_3I(*args):
    if len(args) != 4: return False
    model,name,shape,nidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match__3I__(nidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3I_3I(*args):
    if len(args) != 4: return False
    model,name,shape,nidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3I_3I(self,model,name,shape,nidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(self,model,name,shape,nidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nidxs is None or isinstance(nidxs,numpy.ndarray)
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nidxs)
   (self.__name) = name
   (self.__names_flushed) = False
   (self.__nativeidxs) = nidxs
   (self.__shape) = shape
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Constraint('")._a_S(self.__name)._a_S("')")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self.getModel()
   if (not self.__names_flushed): # src/fusion/ModelConstraint.mbi:74:12-29
    if (int(len(self.__name))==0): # src/fusion/ModelConstraint.mbi:75:14-28
     _0._connames__3IS_3I_3J(self.__nativeidxs,"",numpy.array([self.getSize()], dtype=numpy.dtype(numpy.int32)),None)
    else:
     _1=mosek.fusion.Utils.StringBuffer()
     _1._a_S(self.__name)._a_S("[")
     if (self.getND() > 0): # src/fusion/ModelConstraint.mbi:81:16-27
      _1._a_S("%0")
      for _2 in range(1,self.getND()):
       _1._a_S(",%")._a_I(_2)
     _1._a_S("]")
     _0._connames__3IS_3I_3J(self.__nativeidxs,_1._toString_(),(self.getShape() if ((self.getND() > 0) ) else numpy.array([1], dtype=numpy.dtype(numpy.int32))),None)
     self.__names_flushed = True
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
 return ModelConstraint
mosek_fusion_ModelConstraint=__mk_mosek_fusion_ModelConstraint()
del __mk_mosek_fusion_ModelConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDConstraint():
 class LinearPSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearPSDConstraint__conedim','_LinearPSDConstraint__shape','_LinearPSDConstraint__conid','_LinearPSDConstraint__slackidxs','_LinearPSDConstraint__nativeidxs']
  def __repr__(self): return 'mosek.fusion.LinearPSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__slackidxs = (c.__slackidxs)
   self.__nativeidxs = (c.__nativeidxs)
   self.__conedim = (c.__conedim)
   self.__shape = (c.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,conid,shape,conedim,nativeidxs,slackidxs):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,conid,shape,conedim,nativeidxs,slackidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(*args):
    if len(args) != 7: return False
    model,name,conid,shape,conedim,nativeidxs,slackidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match_I__(conedim) and __arg_match__3I__(nativeidxs) and __arg_match__3J__(slackidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(*args):
    if len(args) != 7: return False
    model,name,conid,shape,conedim,nativeidxs,slackidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match__3J__(slackidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(self,model,name,conid,shape,conedim,nativeidxs,slackidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.array(slackidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(self,model,name,conid,shape,conedim,nativeidxs,slackidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   assert slackidxs is None or isinstance(slackidxs,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(self,model,name,shape,nativeidxs)
   (self.__conid) = conid
   (self.__slackidxs) = slackidxs
   (self.__nativeidxs) = nativeidxs
   (self.__conedim) = conedim
   (self.__shape) = shape
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=mosek.fusion.Set._idxtokey__3IJ(self.__shape,_0)
   _1._a_S(" : element (")._a_I(_2[0])
   for _3 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(_2[_3])
   _1._a_S(") in a positive semi-definite cone of size (")._a_I(self.__shape[0])
   for _4 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(self.__shape[_4])
   _1._a_S(")")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearPSDConstraint._ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearPSDConstraint
mosek_fusion_LinearPSDConstraint=__mk_mosek_fusion_LinearPSDConstraint()
del __mk_mosek_fusion_LinearPSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_PSDConstraint():
 class PSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_PSDConstraint__names_flushed','_PSDConstraint__conedim1','_PSDConstraint__conedim0','_PSDConstraint__shape','_PSDConstraint__name','_PSDConstraint__slackidxs','_PSDConstraint__nativeidxs','_PSDConstraint__conid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_PSDConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_PSDConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDConstraint.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.PSDConstraint: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__name = (c.__name)
   self.__shape = (c.__shape)
   self.__slackidxs = (c.__slackidxs)
   self.__nativeidxs = (c.__nativeidxs)
   self.__names_flushed = (c.__names_flushed)
   self.__conedim0 = (c.__conedim0)
   self.__conedim1 = (c.__conedim1)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(*args):
    if len(args) != 8: return False
    model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match_I__(conedim0) and __arg_match_I__(conedim1) and __arg_match__3J__(slackidxs) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(*args):
    if len(args) != 8: return False
    model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim0) and __arg_alt_match_I__(conedim1) and __arg_alt_match__3J__(slackidxs) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(self,model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim0),numpy.int32(conedim1),numpy.array(slackidxs,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(self,model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert slackidxs is None or isinstance(slackidxs,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(self,model,name,shape,mosek.fusion.PSDConstraint.__computenidxs__3III_3I(shape,conedim0,conedim1,nativeidxs))
   (self.__conid) = conid
   (self.__nativeidxs) = nativeidxs
   (self.__slackidxs) = slackidxs
   (self.__name) = name
   (self.__shape) = shape
   (self.__conedim0) = conedim0
   (self.__conedim1) = conedim1
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   raise mosek_fusion_UnimplementedError._ctor_S("PSDConstraint.toString not implemented")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_PSDConstraint._ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __computenidxs_alt__3III_3I(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_PSDConstraint.__computenidxs__3III_3I(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computenidxs__3III_3I(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=int((_0).shape[0])
   _5=(_1 < _2)
   _6=(_1 if (_5 ) else _2)
   _7=(_2 if (_5 ) else _1)
   _8=numpy.array([1,1,1,1,1], dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros((5,), dtype=numpy.dtype(numpy.int32))
   _10=1
   for _11 in range(0,int((_0).shape[0])):
    _10 *= _0[_11]
   for _12 in range(0,_6):
    _8[0] *= _0[_12]
   _8[1] = _0[_6]
   for _13 in range((_6 + 1),_7):
    _8[2] *= _0[_13]
   _8[3] = _0[_7]
   for _14 in range((_7 + 1),_4):
    _8[4] *= _0[_14]
   _9[4] = 1
   for _15 in range(1,5):
    _9[((5 - _15) - 1)] = (_9[(5 - _15)] * _8[(5 - _15)])
   _16=numpy.zeros((_10,), dtype=numpy.dtype(numpy.int32))
   _17=0
   if _5: # src/fusion/SemidefiniteConstraint.mbi:51:12-16
    for _18 in range(0,_8[0]):
     for _19 in range(0,_8[1]):
      for _20 in range(0,_8[2]):
       for _21 in range(_19,_8[1]):
        for _22 in range(0,_8[4]):
         _16[(((((_18 * _9[0]) + (_19 * _9[1])) + (_20 * _9[2])) + (_21 * _9[3])) + (_22 * _9[4]))] = _3[_17]
         _16[(((((_18 * _9[0]) + (_21 * _9[1])) + (_20 * _9[2])) + (_19 * _9[3])) + (_22 * _9[4]))] = _3[_17]
         _17 += 1
   else:
    for _23 in range(0,_8[0]):
     for _24 in range(0,_8[1]):
      for _25 in range(0,_8[2]):
       for _26 in range(0,(_24 + 1)):
        for _27 in range(0,_8[4]):
         _16[(((((_23 * _9[0]) + (_24 * _9[1])) + (_25 * _9[2])) + (_26 * _9[3])) + (_27 * _9[4]))] = _3[_17]
         _16[(((((_23 * _9[0]) + (_26 * _9[1])) + (_25 * _9[2])) + (_24 * _9[3])) + (_27 * _9[4]))] = _3[_17]
         _17 += 1
   return (_16)
 return PSDConstraint
mosek_fusion_PSDConstraint=__mk_mosek_fusion_PSDConstraint()
del __mk_mosek_fusion_PSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_RangedConstraint():
 class RangedConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_RangedConstraint__nativeidxs','_RangedConstraint__shape']
  def __repr__(self): return 'mosek.fusion.RangedConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__shape = (c.__shape)
   self.__nativeidxs = (c.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3I_3I(model,name,shape,nativeidxs):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(model,name,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3I_3I(*args):
    if len(args) != 4: return False
    model,name,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3I_3I(*args):
    if len(args) != 4: return False
    model,name,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3I_3I(self,model,name,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(self,model,name,shape,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(self,model,name,shape,nativeidxs)
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return RangedConstraint
mosek_fusion_RangedConstraint=__mk_mosek_fusion_RangedConstraint()
del __mk_mosek_fusion_RangedConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ConicConstraint():
 class ConicConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_ConicConstraint__nativeslack','_ConicConstraint__nativeidxs','_ConicConstraint__names_flushed','_ConicConstraint__name','_ConicConstraint__shape','_ConicConstraint__dom','_ConicConstraint__conid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ConicConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ConicConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicConstraint.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ConicConstraint: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__dom = (c.__dom)
   self.__conid = (c.__conid)
   self.__shape = (c.__shape)
   self.__name = (c.__name)
   self.__nativeidxs = (c.__nativeidxs)
   self.__nativeslack = (c.__nativeslack)
   self.__names_flushed = (c.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(model,name,dom,shape,conid,nativeidxs,nativeslack):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(model,name,dom,shape,conid,nativeidxs,nativeslack)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(*args):
    if len(args) != 7: return False
    model,name,dom,shape,conid,nativeidxs,nativeslack, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(dom) and __arg_match__3I__(shape) and __arg_match_I__(conid) and __arg_match__3I__(nativeidxs) and __arg_match__3I__(nativeslack))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(*args):
    if len(args) != 7: return False
    model,name,dom,shape,conid,nativeidxs,nativeslack, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(dom) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match__3I__(nativeslack))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(self,model,name,dom,shape,conid,nativeidxs,nativeslack):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(model,name,dom,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conid),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeslack,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(self,model,name,dom,shape,conid,nativeidxs,nativeslack):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   assert nativeslack is None or isinstance(nativeslack,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(self,model,name,shape,nativeidxs)
   (self.__dom) = dom
   (self.__shape) = shape
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__nativeslack) = nativeslack
   (self.__conid) = conid
   self.__names_flushed = False
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   mosek_fusion_ModelConstraint._flushNames_(self)
   _0=int((self.__nativeslack).shape[0])
   _1=self.getModel()
   if ((not self.__names_flushed) and (int(len(self.__name)) > 0)): # src/fusion/ConicConstraint.mbi:112:12-47
    if (int(len(self.__name))==0): # src/fusion/ConicConstraint.mbi:113:14-28
     for _2 in range(0,_0):
      _1._task_1var_1name_IS(self.__nativeslack[_2],"")
    else:
     _3=mosek.fusion.Utils.StringBuffer()
     for _4 in range(0,_0):
      _1._task_1var_1name_IS(self.__nativeslack[_4],_3._clear_()._a_S(self.__name)._a_S("[")._a_S(mosek.fusion.Set._indexToString__3IJ(self.__shape,_4))._a_S("].coneslack")._toString_())
    self.__names_flushed = True
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("ConicConstraint('")._a_S(self.__name)._a_S("')")
   return (_0._toString_())
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   raise mosek_fusion_UnimplementedError._ctor_S("ConicConstraint.domainToString")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return ConicConstraint
mosek_fusion_ConicConstraint=__mk_mosek_fusion_ConicConstraint()
del __mk_mosek_fusion_ConicConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearConstraint():
 class LinearConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearConstraint__name','_LinearConstraint__conid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearConstraint.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.LinearConstraint: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__name = (c.__name)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,conid,shape,nidxs):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,conid,shape,nidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,conid,shape,nidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match__3I__(nidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,conid,shape,nidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,conid,shape,nidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,conid,shape,nidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nidxs is None or isinstance(nidxs,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3I(self,model,name,shape,nidxs)
   (self.__conid) = conid
   (self.__name) = name
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("LinearConstraint('")._a_S(self.__name)._a_S("')")
   return (_0._toString_())
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearConstraint
mosek_fusion_LinearConstraint=__mk_mosek_fusion_LinearConstraint()
del __mk_mosek_fusion_LinearConstraint
#BEFORE CLASS
def __mk_mosek_fusion_Set():
 class Set(object):
  @staticmethod
  def indexToKey(*args):
    if False: pass
    elif mosek_fusion_Set._match_indexToKey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._indexToKey__3IJ_3I(*args)
    elif mosek_fusion_Set._match_alt_indexToKey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._indexToKey_alt__3IJ_3I(*args)
    else:
      raise ValueError('Invalid argument list indexToKey('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.indexToKey(array(int32,ndim=1),int64,array(int32,ndim=1))')
  @staticmethod
  def match(*args):
    if False: pass
    elif mosek_fusion_Set._match_match__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._match__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_match__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._match_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list match('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.match(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def strides(*args):
    if False: pass
    elif mosek_fusion_Set._match_strides__3I(*args): # []int32
      return mosek_fusion_Set._strides__3I(*args)
    elif mosek_fusion_Set._match_alt_strides__3I(*args): # []int32
      return mosek_fusion_Set._strides_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list strides('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.strides(array(int32,ndim=1))')
  @staticmethod
  def make(*args):
    if False: pass
    elif mosek_fusion_Set._match_make__3S(*args): # []string
      return mosek_fusion_Set._make__3S(*args)
    elif mosek_fusion_Set._match_alt_make__3S(*args): # []string
      return mosek_fusion_Set._make_alt__3S(*args)
    elif mosek_fusion_Set._match_make_I(*args): # int32
      return mosek_fusion_Set._make_I(*args)
    elif mosek_fusion_Set._match_alt_make_I(*args): # int32
      return mosek_fusion_Set._make_alt_I(*args)
    elif mosek_fusion_Set._match_make__3I(*args): # []int32
      return mosek_fusion_Set._make__3I(*args)
    elif mosek_fusion_Set._match_alt_make__3I(*args): # []int32
      return mosek_fusion_Set._make_alt__3I(*args)
    elif mosek_fusion_Set._match_make__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._make__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_make__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._make_alt__3I_3I(*args)
    elif mosek_fusion_Set._match_make_II(*args): # int32,int32
      return mosek_fusion_Set._make_II(*args)
    elif mosek_fusion_Set._match_alt_make_II(*args): # int32,int32
      return mosek_fusion_Set._make_alt_II(*args)
    elif mosek_fusion_Set._match_make_III(*args): # int32,int32,int32
      return mosek_fusion_Set._make_III(*args)
    elif mosek_fusion_Set._match_alt_make_III(*args): # int32,int32,int32
      return mosek_fusion_Set._make_alt_III(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.make(array(string,ndim=1))\n\tmosek.fusion.Set.make(int32)\n\tmosek.fusion.Set.make(array(int32,ndim=1))\n\tmosek.fusion.Set.make(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Set.make(int32,int32)\n\tmosek.fusion.Set.make(int32,int32,int32)')
  @staticmethod
  def linearidx(*args):
    if False: pass
    elif mosek_fusion_Set._match_linearidx__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._linearidx__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_linearidx__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._linearidx_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list linearidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.linearidx(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def scalar(*args):
    if False: pass
    elif mosek_fusion_Set._match_scalar_(*args): # 
      return mosek_fusion_Set._scalar_(*args)
    elif mosek_fusion_Set._match_alt_scalar_(*args): # 
      return mosek_fusion_Set._scalar_alt_(*args)
    else:
      raise ValueError('Invalid argument list scalar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.scalar()')
  @staticmethod
  def keyToString(*args):
    if False: pass
    elif mosek_fusion_Set._match_keyToString__3I(*args): # []int32
      return mosek_fusion_Set._keyToString__3I(*args)
    elif mosek_fusion_Set._match_alt_keyToString__3I(*args): # []int32
      return mosek_fusion_Set._keyToString_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list keyToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.keyToString(array(int32,ndim=1))')
  @staticmethod
  def idxtokey(*args):
    if False: pass
    elif mosek_fusion_Set._match_idxtokey__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._idxtokey__3IJ(*args)
    elif mosek_fusion_Set._match_alt_idxtokey__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._idxtokey_alt__3IJ(*args)
    elif mosek_fusion_Set._match_idxtokey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._idxtokey__3IJ_3I(*args)
    elif mosek_fusion_Set._match_alt_idxtokey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._idxtokey_alt__3IJ_3I(*args)
    else:
      raise ValueError('Invalid argument list idxtokey('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.idxtokey(array(int32,ndim=1),int64)\n\tmosek.fusion.Set.idxtokey(array(int32,ndim=1),int64,array(int32,ndim=1))')
  @staticmethod
  def indexToString(*args):
    if False: pass
    elif mosek_fusion_Set._match_indexToString__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._indexToString__3IJ(*args)
    elif mosek_fusion_Set._match_alt_indexToString__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._indexToString_alt__3IJ(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.indexToString(array(int32,ndim=1),int64)')
  @staticmethod
  def size(*args):
    if False: pass
    elif mosek_fusion_Set._match_size__3I(*args): # []int32
      return mosek_fusion_Set._size__3I(*args)
    elif mosek_fusion_Set._match_alt_size__3I(*args): # []int32
      return mosek_fusion_Set._size_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.size(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Set'
  @staticmethod
  def _match_size__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_size__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _size_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._size__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _size__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   for _2 in range(0,int((_0).shape[0])):
    _1 *= _0[_2]
   return numpy.int64(_1)
  @staticmethod
  def _match_match__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_match__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _match_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._match__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _match__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])): # src/fusion/Set.mbi:196:12-30
    return (False)
   for _2 in range(0,int((_0).shape[0])):
    if (_0[_2]!=_1[_2]): # src/fusion/Set.mbi:198:14-28
     return (False)
   return (True)
  @staticmethod
  def _match_linearidx__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_linearidx__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _linearidx_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._linearidx__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _linearidx__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=_1[0]
   for _3 in range(1,int((_1).shape[0])):
    _2 = ((_2 * _0[_3]) + _1[_3])
   return numpy.int64(_2)
  @staticmethod
  def _match_idxtokey__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_idxtokey__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _idxtokey_alt__3IJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_Set._idxtokey__3IJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _idxtokey__3IJ(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Set._idxtokey__3IJ_3I(_0,_1,_2)
   return (_2)
  @staticmethod
  def _match_idxtokey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_idxtokey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _idxtokey_alt__3IJ_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._idxtokey__3IJ_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _idxtokey__3IJ_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=int((_0).shape[0])
   if (_3 > 0): # src/fusion/Set.mbi:157:12-18
    _4=_1
    for _5 in range(0,(_3 - 1)):
     _2[((_3 - _5) - 1)] = numpy.int32((_4 % _0[((_3 - _5) - 1)]))
     _4 /= _0[((_3 - _5) - 1)]
    _2[0] = numpy.int32(_4)
  @staticmethod
  def _match_indexToString__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_indexToString__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _indexToString_alt__3IJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_Set._indexToString__3IJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _indexToString__3IJ(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=int((_0).shape[0])
   _3=mosek.fusion.Utils.StringBuffer()
   if (_2==0): # src/fusion/Set.mbi:128:12-19
    return ("0")
   elif (_2==1): # src/fusion/Set.mbi:130:16-23
    return (_3._a_J(_1)._toString_())
   else:
    _4=_1
    _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    for _6 in range(1,_2):
     _5[(_2 - _6)] = numpy.int32((_4 % _0[(_2 - _6)]))
     _4 /= _0[(_2 - _6)]
    _5[0] = numpy.int32(_4)
    _3._a_I(_5[0])
    for _7 in range(1,_2):
     _3._a_S(",")._a_I(_5[_7])
    return (_3._toString_())
  @staticmethod
  def _match_keyToString__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_keyToString__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _keyToString_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._keyToString__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _keyToString__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=mosek.fusion.Utils.StringBuffer()
   _1._a_I(_0[0])
   for _2 in range(1,int((_0).shape[0])):
    _1._a_S(",")._a_I(_0[_2])
   return (_1._toString_())
  @staticmethod
  def _match_indexToKey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_indexToKey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _indexToKey_alt__3IJ_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._indexToKey__3IJ_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _indexToKey__3IJ_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=int((_0).shape[0])
   if (_3==1): # src/fusion/Set.mbi:95:12-19
    _2[0] = numpy.int32(_1)
   else:
    _4=_1
    for _5 in range(1,_3):
     _2[(_3 - _5)] = numpy.int32((_4 % _0[(_3 - _5)]))
     _4 /= _0[(_3 - _5)]
    _2[0] = numpy.int32(_4)
  @staticmethod
  def _match_strides__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_strides__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _strides_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._strides__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _strides__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
   _2[(_1 - 1)] = 1
   for _3 in range(1,_1):
    _2[((_1 - _3) - 1)] = (_2[(_1 - _3)] * _0[(_1 - _3)])
   return (_2)
  @staticmethod
  def _match_make__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_make__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _make_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._make__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.zeros(((int((_0).shape[0]) + int((_1).shape[0])),), dtype=numpy.dtype(numpy.int32))
   for _3 in range(0,int((_0).shape[0])):
    _2[_3] = _0[_3]
   for _4 in range(0,int((_1).shape[0])):
    _2[(int((_0).shape[0]) + _4)] = _1[_4]
   return (_2)
  @staticmethod
  def _match_make__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_make__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _make_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._make__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_make_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _make_alt_III(_t__0,_t__1,_t__2):
    return mosek_fusion_Set._make_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _make_III(_0,_1,_2):
   return (numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_make_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _make_alt_II(_t__0,_t__1):
    return mosek_fusion_Set._make_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _make_II(_0,_1):
   return (numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_make_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _make_alt_I(_t__0):
    return mosek_fusion_Set._make_I(numpy.int32(__0))
  @staticmethod
  def _make_I(_0):
   return (numpy.array([_0], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _scalar_alt_():
    return mosek_fusion_Set._scalar_()
  @staticmethod
  def _scalar_():
   return (numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make__3S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3S__(_0))
  @staticmethod
  def _match_alt_make__3S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3S__(_0))
  @staticmethod
  def _make_alt__3S(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Set._make__3S(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3S(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32)))
 return Set
mosek_fusion_Set=__mk_mosek_fusion_Set()
del __mk_mosek_fusion_Set
#BEFORE CLASS
def __mk_mosek_fusion_ConeDomain():
 class ConeDomain(object):
  __slots__ = ['_alpha','_shape','_int_flag','_axisset','_axisidx','_key']
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_ConeDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.integral()')
  def getAxis(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_getAxis_(*args): # 
      return self._getAxis_(*args)
    elif mosek_fusion_ConeDomain._match_alt_getAxis_(*args): # 
      return self._getAxis_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.getAxis()')
  def axis(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_axis_I(*args): # int32
      return self._axis_I(*args)
    elif mosek_fusion_ConeDomain._match_alt_axis_I(*args): # int32
      return self._axis_alt_I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.axis(int32)')
  def axisIsSet(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_axisIsSet_(*args): # 
      return self._axisIsSet_(*args)
    elif mosek_fusion_ConeDomain._match_alt_axisIsSet_(*args): # 
      return self._axisIsSet_alt_(*args)
    else:
      raise ValueError('Invalid argument list axisIsSet('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.axisIsSet()')
  def __repr__(self): return 'mosek.fusion.ConeDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4QConeKey_2D_3I(k,alpha,d):
    o = ConeDomain.__new__(ConeDomain)
    o._ctor_init_Emosek_4fusion_4QConeKey_2D_3I(k,alpha,d)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4QConeKey_2D_3I(*args):
    if len(args) != 3: return False
    k,alpha,d, = args
    return (__arg_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_match_D__(alpha) and __arg_match__3I__(d))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4QConeKey_2D_3I(*args):
    if len(args) != 3: return False
    k,alpha,d, = args
    return (__arg_alt_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_alt_match_D__(alpha) and __arg_alt_match__3I__(d))
  def _ctor_alt_init_Emosek_4fusion_4QConeKey_2D_3I(self,k,alpha,d):
    self._ctor_init_Emosek_4fusion_4QConeKey_2D_3I(k,numpy.float64(alpha),numpy.array(d,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4QConeKey_2D_3I(self,k,alpha,d):
   assert d is None or isinstance(d,numpy.ndarray)
   self._shape = (mosek.fusion.Set._make__3I(d) if ((d is not None) ) else None)
   (self._alpha) = alpha
   self._key = k
   self._axisidx = 0
   self._axisset = False
   self._int_flag = False
   (self._alpha) = alpha
  @staticmethod
  def _ctor_Emosek_4fusion_4QConeKey_2_3I(k,d):
    o = ConeDomain.__new__(ConeDomain)
    o._ctor_init_Emosek_4fusion_4QConeKey_2_3I(k,d)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4QConeKey_2_3I(*args):
    if len(args) != 2: return False
    k,d, = args
    return (__arg_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_match__3I__(d))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4QConeKey_2_3I(*args):
    if len(args) != 2: return False
    k,d, = args
    return (__arg_alt_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_alt_match__3I__(d))
  def _ctor_alt_init_Emosek_4fusion_4QConeKey_2_3I(self,k,d):
    self._ctor_init_Emosek_4fusion_4QConeKey_2_3I(k,numpy.array(d,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4QConeKey_2_3I(self,k,d):
   assert d is None or isinstance(d,numpy.ndarray)
   mosek_fusion_ConeDomain._ctor_init_Emosek_4fusion_4QConeKey_2D_3I(self,k,1.0,d)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (((self._shape is None) or mosek.fusion.Set._match__3I_3I(_0,self._shape)))
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._int_flag = True
   return (self)
  @staticmethod
  def _match_axisIsSet_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_axisIsSet_(*args):
    if len(args) != 0: return False
    return True
  def _axisIsSet_alt_(self,):
    return self._axisIsSet_()
  def _axisIsSet_(self,):
   return (self._axisset)
  @staticmethod
  def _match_getAxis_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAxis_(*args):
    if len(args) != 0: return False
    return True
  def _getAxis_alt_(self,):
    return self._getAxis_()
  def _getAxis_(self,):
   return numpy.int32(self._axisidx)
  @staticmethod
  def _match_axis_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_axis_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _axis_alt_I(self,_t__0):
    return self._axis_I(numpy.int32(__0))
  def _axis_I(self,_0):
   self._axisidx = _0
   self._axisset = True
   return (self)
 return ConeDomain
mosek_fusion_ConeDomain=__mk_mosek_fusion_ConeDomain()
del __mk_mosek_fusion_ConeDomain
#BEFORE CLASS
def __mk_mosek_fusion_LinPSDDomain():
 class LinPSDDomain(object):
  __slots__ = ['_conedim','_shape']
  def __repr__(self): return 'mosek.fusion.LinPSDDomain'
  @staticmethod
  def _ctor__3II(shp,conedim):
    o = LinPSDDomain.__new__(LinPSDDomain)
    o._ctor_init__3II(shp,conedim)
    return o
  @staticmethod
  def __match_ctor__3II(*args):
    if len(args) != 2: return False
    shp,conedim, = args
    return (__arg_match__3I__(shp) and __arg_match_I__(conedim))
  @staticmethod
  def __match_alt_ctor__3II(*args):
    if len(args) != 2: return False
    shp,conedim, = args
    return (__arg_alt_match__3I__(shp) and __arg_alt_match_I__(conedim))
  def _ctor_alt_init__3II(self,shp,conedim):
    self._ctor_init__3II(numpy.array(shp,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim))
  def _ctor_init__3II(self,shp,conedim):
   assert shp is None or isinstance(shp,numpy.ndarray)
   (self._conedim) = conedim
   self._shape = mosek.fusion.Utils.Tools._arraycopy__3I(shp)
  @staticmethod
  def _ctor__3I(shp):
    o = LinPSDDomain.__new__(LinPSDDomain)
    o._ctor_init__3I(shp)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shp, = args
    return (__arg_match__3I__(shp))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shp, = args
    return (__arg_alt_match__3I__(shp))
  def _ctor_alt_init__3I(self,shp):
    self._ctor_init__3I(numpy.array(shp,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shp):
   assert shp is None or isinstance(shp,numpy.ndarray)
   self._shape = mosek.fusion.Utils.Tools._arraycopy__3I(shp)
   self._conedim = (int((self._shape).shape[0]) - 1)
  @staticmethod
  def _ctor_():
    o = LinPSDDomain.__new__(LinPSDDomain)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   self._conedim = 0
   self._shape = None
 return LinPSDDomain
mosek_fusion_LinPSDDomain=__mk_mosek_fusion_LinPSDDomain()
del __mk_mosek_fusion_LinPSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_PSDDomain():
 class PSDDomain(object):
  __slots__ = ['_axisIsSet','_conedim2','_conedim1','_key','_shape']
  def axis(self,*args):
    if False: pass
    elif mosek_fusion_PSDDomain._match_axis_II(*args): # int32,int32
      return self._axis_II(*args)
    elif mosek_fusion_PSDDomain._match_alt_axis_II(*args): # int32,int32
      return self._axis_alt_II(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDDomain.axis(int32,int32)')
  def __repr__(self): return 'mosek.fusion.PSDDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2_3III(k,shp,conedim1,conedim2):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2_3III(k,shp,conedim1,conedim2)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2_3III(*args):
    if len(args) != 4: return False
    k,shp,conedim1,conedim2, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_match__3I__(shp) and __arg_match_I__(conedim1) and __arg_match_I__(conedim2))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2_3III(*args):
    if len(args) != 4: return False
    k,shp,conedim1,conedim2, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_alt_match__3I__(shp) and __arg_alt_match_I__(conedim1) and __arg_alt_match_I__(conedim2))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,conedim1,conedim2):
    self._ctor_init_Emosek_4fusion_4PSDKey_2_3III(k,numpy.array(shp,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim1),numpy.int32(conedim2))
  def _ctor_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,conedim1,conedim2):
   assert shp is None or isinstance(shp,numpy.ndarray)
   self._axisIsSet = True
   self._shape = shp
   self._key = k
   (self._conedim1) = conedim1
   (self._conedim2) = conedim2
   _0=int((self._shape).shape[0])
   if ((not ((int((self._shape).shape[0]) > conedim1) and ((int((self._shape).shape[0]) > conedim2) and ((conedim1 >= 0) and ((conedim2 >= 0) and (conedim1!=conedim2)))))) and (self._shape[conedim1]==self._shape[conedim2])): # src/fusion/domain.mbi:916:13-921:47
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2_3I(k,shp):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2_3I(k,shp)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2_3I(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_match__3I__(shp))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2_3I(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_alt_match__3I__(shp))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2_3I(self,k,shp):
    self._ctor_init_Emosek_4fusion_4PSDKey_2_3I(k,numpy.array(shp,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4PSDKey_2_3I(self,k,shp):
   assert shp is None or isinstance(shp,numpy.ndarray)
   mosek_fusion_PSDDomain._ctor_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,(int((shp).shape[0]) - 2),(int((shp).shape[0]) - 1))
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2(k):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2(k)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2(self,k):
    self._ctor_init_Emosek_4fusion_4PSDKey_2(k)
  def _ctor_init_Emosek_4fusion_4PSDKey_2(self,k):
   self._shape = None
   self._key = k
   self._conedim1 = 0
   self._conedim2 = 0
   self._axisIsSet = False
  @staticmethod
  def _match_axis_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_axis_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _axis_alt_II(self,_t__0,_t__1):
    return self._axis_II(numpy.int32(__0),numpy.int32(__1))
  def _axis_II(self,_0,_1):
   (self._conedim1) = _0
   (self._conedim2) = _1
   self._axisIsSet = True
   if ((self._shape is None) and (not ((_0 >= 0) and ((_1 >= 0) and (_0!=_1))))): # src/fusion/domain.mbi:931:17-934:43
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
   elif ((self._shape is not None) and ((not ((int((self._shape).shape[0]) > _0) and ((int((self._shape).shape[0]) > _1) and ((_0 >= 0) and ((_1 >= 0) and (_0!=_1)))))) and (self._shape[_0]==self._shape[_1]))): # src/fusion/domain.mbi:936:17-942:51
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
   return (self)
 return PSDDomain
mosek_fusion_PSDDomain=__mk_mosek_fusion_PSDDomain()
del __mk_mosek_fusion_PSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_RangeDomain():
 class RangeDomain(object):
  __slots__ = ['_cardinal_flag','_scalable','_ub','_lb','_sparsity','_empty','_shape']
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    elif mosek_fusion_RangeDomain._match_sparse__3I(*args): # []int32
      return self._sparse__3I(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse__3I(*args): # []int32
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_RangeDomain._match_sparse__3_5I(*args): # [,]int32
      return self._sparse__3_5I(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse__3_5I(*args): # [,]int32
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.sparse()\n\tmosek.fusion.RangeDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.RangeDomain.sparse(array(int32,ndim=2))')
  def symmetric(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_symmetric_(*args): # 
      return self._symmetric_(*args)
    elif mosek_fusion_RangeDomain._match_alt_symmetric_(*args): # 
      return self._symmetric_alt_(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.symmetric()')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_RangeDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.integral()')
  def withShape(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_withShape__3I(*args): # []int32
      return self._withShape__3I(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape__3I(*args): # []int32
      return self._withShape_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list withShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.withShape(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.RangeDomain'
  @staticmethod
  def _ctor_Z_3D_3D_3I(scalable,lb,ub,dims):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I(scalable,lb,ub,dims)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I(*args):
    if len(args) != 4: return False
    scalable,lb,ub,dims, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I(*args):
    if len(args) != 4: return False
    scalable,lb,ub,dims, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_Z_3D_3D_3I(self,scalable,lb,ub,dims):
    self._ctor_init_Z_3D_3D_3I(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Z_3D_3D_3I(self,scalable,lb,ub,dims):
   assert lb is None or isinstance(lb,numpy.ndarray)
   assert ub is None or isinstance(ub,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   mosek_fusion_RangeDomain._ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,None,1)
  @staticmethod
  def _ctor_Z_3D_3D_3I_3_5I(scalable,lb,ub,dims,sp):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I_3_5I(scalable,lb,ub,dims,sp)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I_3_5I(*args):
    if len(args) != 5: return False
    scalable,lb,ub,dims,sp, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I_3_5I(*args):
    if len(args) != 5: return False
    scalable,lb,ub,dims,sp, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp))
  def _ctor_alt_init_Z_3D_3D_3I_3_5I(self,scalable,lb,ub,dims,sp):
    self._ctor_init_Z_3D_3D_3I_3_5I(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Z_3D_3D_3I_3_5I(self,scalable,lb,ub,dims,sp):
   assert lb is None or isinstance(lb,numpy.ndarray)
   assert ub is None or isinstance(ub,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   assert sp is None or isinstance(sp,numpy.ndarray)
   mosek_fusion_RangeDomain._ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,1)
  @staticmethod
  def _ctor_Z_3D_3D_3I_3_5II(scalable,lb,ub,dims,sp,steal):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I_3_5II(scalable,lb,ub,dims,sp,steal)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    scalable,lb,ub,dims,sp,steal, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp) and __arg_match_I__(steal))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    scalable,lb,ub,dims,sp,steal, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp) and __arg_alt_match_I__(steal))
  def _ctor_alt_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,steal):
    self._ctor_init_Z_3D_3D_3I_3_5II(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)),numpy.int32(steal))
  def _ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,steal):
   assert lb is None or isinstance(lb,numpy.ndarray)
   assert ub is None or isinstance(ub,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   assert sp is None or isinstance(sp,numpy.ndarray)
   self._cardinal_flag = False
   self._shape = dims
   self._sparsity = None
   (self._scalable) = scalable
   (self._ub) = ub
   (self._lb) = lb
   (self._sparsity) = sp
   (self._empty) = False
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   self._cardinal_flag = (other._cardinal_flag)
   self._sparsity = (other._sparsity)
   self._scalable = (other._scalable)
   self._shape = (other._shape)
   self._ub = (other._ub)
   self._lb = (other._lb)
   self._empty = (other._empty)
  @staticmethod
  def _match_symmetric_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_symmetric_(*args):
    if len(args) != 0: return False
    return True
  def _symmetric_alt_(self,):
    return self._symmetric_()
  def _symmetric_(self,):
   return (mosek_fusion_SymmetricRangeDomain._ctor_Lmosek_4fusion_4RangeDomain_2(self))
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _sparse_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3_5I(_0)
   return _1
  def _sparse__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),int((_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   _1=0
   while (_1 < int((_0).shape[0])):
    _2=0
    while (_2 < int((_0).shape[1])):
     (self._sparsity)[_1,_2] = _0[_1,_2]
     _2 += 1
    _1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _sparse_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _sparse__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   for _1 in range(0,int((_0).shape[0])):
    (self._sparsity)[_1,0] = _0[_1]
   return (self)
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   (self._empty) = True
   (self._sparsity) = None
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  @staticmethod
  def _match_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _withShape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._withShape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withShape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   self._shape = _0
   return (self)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if self._scalable: # src/fusion/domain.mbi:767:17-25
    return (True)
   elif (int((self._shape).shape[0])!=int((_0).shape[0])): # src/fusion/domain.mbi:769:17-39
    return (False)
   else:
    for _1 in range(0,int((self._shape).shape[0])):
     if (self._shape[_1]!=_0[_1]): # src/fusion/domain.mbi:773:16-34
      return (False)
   return (True)
 return RangeDomain
mosek_fusion_RangeDomain=__mk_mosek_fusion_RangeDomain()
del __mk_mosek_fusion_RangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricRangeDomain():
 class SymmetricRangeDomain(mosek_fusion_RangeDomain):
  __slots__ = ['_dim']
  def __repr__(self): return 'mosek.fusion.SymmetricRangeDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = SymmetricRangeDomain.__new__(SymmetricRangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   mosek_fusion_RangeDomain._ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other)
   if ((self._shape is not None) and ((int((self._shape).shape[0])!=2) or (self._shape[0]!=self._shape[1]))): # src/fusion/domain.mbi:855:13-857:37
    raise mosek_fusion_DimensionError._ctor_S("Only square domains can be symmetric")
   self._dim = (0 if ((self._shape is None) ) else self._shape[0])
 return SymmetricRangeDomain
mosek_fusion_SymmetricRangeDomain=__mk_mosek_fusion_SymmetricRangeDomain()
del __mk_mosek_fusion_SymmetricRangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricLinearDomain():
 class SymmetricLinearDomain(object):
  __slots__ = ['_sparsity','_cardinal_flag','_key','_shape','_dom','_dim']
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricLinearDomain._match_sparse__3I(*args): # []int32
      return self._sparse__3I(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_sparse__3I(*args): # []int32
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_sparse__3_5I(*args): # [,]int32
      return self._sparse__3_5I(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_sparse__3_5I(*args): # [,]int32
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricLinearDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.SymmetricLinearDomain.sparse(array(int32,ndim=2))')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricLinearDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricLinearDomain.integral()')
  def __repr__(self): return 'mosek.fusion.SymmetricLinearDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = SymmetricLinearDomain.__new__(SymmetricLinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   self._dom = other
   self._shape = (other._shape)
   self._key = (other._key)
   self._cardinal_flag = (other._cardinal_flag)
   self._sparsity = (other._sparsity)
   if ((self._shape is not None) and ((int((self._shape).shape[0])!=2) or (self._shape[0]!=self._shape[1]))): # src/fusion/domain.mbi:625:13-627:36
    raise mosek_fusion_DimensionError._ctor_S("Only square domains can be symmetric")
   self._dim = (0 if ((self._shape is None) ) else self._shape[0])
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _sparse_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3_5I(_0)
   return _1
  def _sparse__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),int((_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   _1=0
   while (_1 < int((_0).shape[0])):
    _2=0
    while (_2 < int((_0).shape[1])):
     (self._sparsity)[_1,_2] = _0[_1,_2]
     _2 += 1
    _1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _sparse_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _sparse__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   for _1 in range(0,int((_0).shape[0])):
    (self._sparsity)[_1,0] = _0[_1]
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1]==self._shape[_1]): # src/fusion/domain.mbi:635:14-32
     return (False)
   return (True)
 return SymmetricLinearDomain
mosek_fusion_SymmetricLinearDomain=__mk_mosek_fusion_SymmetricLinearDomain()
del __mk_mosek_fusion_SymmetricLinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_LinearDomain():
 class LinearDomain(object):
  __slots__ = ['_empty','_scalable','_sparsity','_cardinal_flag','_key','_bnd','_shape']
  def symmetric(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_symmetric_(*args): # 
      return self._symmetric_(*args)
    elif mosek_fusion_LinearDomain._match_alt_symmetric_(*args): # 
      return self._symmetric_alt_(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.symmetric()')
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    elif mosek_fusion_LinearDomain._match_sparse__3I(*args): # []int32
      return self._sparse__3I(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse__3I(*args): # []int32
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_LinearDomain._match_sparse__3_5I(*args): # [,]int32
      return self._sparse__3_5I(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse__3_5I(*args): # [,]int32
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.sparse()\n\tmosek.fusion.LinearDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.LinearDomain.sparse(array(int32,ndim=2))')
  def withShape(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_withShape__3I(*args): # []int32
      return self._withShape__3I(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape__3I(*args): # []int32
      return self._withShape_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list withShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.withShape(array(int32,ndim=1))')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_LinearDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.integral()')
  def __repr__(self): return 'mosek.fusion.LinearDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,rhs,dims):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,rhs,dims)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(*args):
    if len(args) != 4: return False
    k,scalable,rhs,dims, = args
    return (__arg_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_match_Z__(scalable) and __arg_match__3D__(rhs) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(*args):
    if len(args) != 4: return False
    k,scalable,rhs,dims, = args
    return (__arg_alt_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(rhs) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(self,k,scalable,rhs,dims):
    self._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,numpy.array(rhs,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(self,k,scalable,rhs,dims):
   assert rhs is None or isinstance(rhs,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   mosek_fusion_LinearDomain._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,None,1)
  @staticmethod
  def _ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,rhs,dims,sp,steal):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,rhs,dims,sp,steal)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    k,scalable,rhs,dims,sp,steal, = args
    return (__arg_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_match_Z__(scalable) and __arg_match__3D__(rhs) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp) and __arg_match_I__(steal))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    k,scalable,rhs,dims,sp,steal, = args
    return (__arg_alt_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(rhs) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp) and __arg_alt_match_I__(steal))
  def _ctor_alt_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,sp,steal):
    self._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,numpy.array(rhs,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)),numpy.int32(steal))
  def _ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,sp,steal):
   assert rhs is None or isinstance(rhs,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   assert sp is None or isinstance(sp,numpy.ndarray)
   (self._scalable) = scalable
   (self._shape) = dims
   (self._key) = k
   (self._bnd) = rhs
   (self._sparsity) = sp
   (self._cardinal_flag) = False
   (self._empty) = False
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   self._scalable = (other._scalable)
   self._shape = (other._shape)
   self._key = (other._key)
   self._bnd = (other._bnd)
   self._sparsity = (other._sparsity)
   self._cardinal_flag = (other._cardinal_flag)
   self._empty = (other._empty)
  @staticmethod
  def _match_symmetric_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_symmetric_(*args):
    if len(args) != 0: return False
    return True
  def _symmetric_alt_(self,):
    return self._symmetric_()
  def _symmetric_(self,):
   return (mosek_fusion_SymmetricLinearDomain._ctor_Lmosek_4fusion_4LinearDomain_2(self))
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _sparse_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3_5I(_0)
   return _1
  def _sparse__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),int((_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   (self._empty) = False
   _1=0
   while (_1 < int((_0).shape[0])):
    _2=0
    while (_2 < int((_0).shape[1])):
     (self._sparsity)[_1,_2] = _0[_1,_2]
     _2 += 1
    _1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _sparse_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _sparse__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   (self._empty) = False
   for _1 in range(0,int((_0).shape[0])):
    (self._sparsity)[_1,0] = _0[_1]
   return (self)
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   (self._empty) = True
   (self._sparsity) = None
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  @staticmethod
  def _match_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _withShape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._withShape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withShape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   self._shape = _0
   return (self)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (not self._scalable): # src/fusion/domain.mbi:528:12-24
    for _1 in range(0,int((_0).shape[0])):
     if (_0[_1]==self._shape[_1]): # src/fusion/domain.mbi:530:16-34
      return (False)
   return (True)
 return LinearDomain
mosek_fusion_LinearDomain=__mk_mosek_fusion_LinearDomain()
del __mk_mosek_fusion_LinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_Domain():
 class Domain(object):
  @staticmethod
  def inPExpCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPExpCone_(*args): # 
      return mosek_fusion_Domain._inPExpCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone_(*args): # 
      return mosek_fusion_Domain._inPExpCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPExpCone_I(*args): # int32
      return mosek_fusion_Domain._inPExpCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone_I(*args): # int32
      return mosek_fusion_Domain._inPExpCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inPExpCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inPExpCone_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list inPExpCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPExpCone()\n\tmosek.fusion.Domain.inPExpCone(int32)\n\tmosek.fusion.Domain.inPExpCone(array(int32,ndim=1))')
  @staticmethod
  def symmetric(*args):
    if False: pass
    elif mosek_fusion_Domain._match_symmetric_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_symmetric_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._symmetric_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_symmetric_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_symmetric_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._symmetric_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.symmetric(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.symmetric(mosek.fusion.RangeDomain)')
  @staticmethod
  def inPSDCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPSDCone_(*args): # 
      return mosek_fusion_Domain._inPSDCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_(*args): # 
      return mosek_fusion_Domain._inPSDCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inPSDCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inPSDCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPSDCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPSDCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inPSDCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPSDCone()\n\tmosek.fusion.Domain.inPSDCone(int32)\n\tmosek.fusion.Domain.inPSDCone(int32,int32)')
  @staticmethod
  def unbounded(*args):
    if False: pass
    elif mosek_fusion_Domain._match_unbounded_(*args): # 
      return mosek_fusion_Domain._unbounded_(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_(*args): # 
      return mosek_fusion_Domain._unbounded_alt_(*args)
    elif mosek_fusion_Domain._match_unbounded_I(*args): # int32
      return mosek_fusion_Domain._unbounded_I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_I(*args): # int32
      return mosek_fusion_Domain._unbounded_alt_I(*args)
    elif mosek_fusion_Domain._match_unbounded__3I(*args): # []int32
      return mosek_fusion_Domain._unbounded__3I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded__3I(*args): # []int32
      return mosek_fusion_Domain._unbounded_alt__3I(*args)
    elif mosek_fusion_Domain._match_unbounded_II(*args): # int32,int32
      return mosek_fusion_Domain._unbounded_II(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_II(*args): # int32,int32
      return mosek_fusion_Domain._unbounded_alt_II(*args)
    else:
      raise ValueError('Invalid argument list unbounded('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.unbounded()\n\tmosek.fusion.Domain.unbounded(int32)\n\tmosek.fusion.Domain.unbounded(array(int32,ndim=1))\n\tmosek.fusion.Domain.unbounded(int32,int32)')
  @staticmethod
  def inRange(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inRange_DD(*args): # double,double
      return mosek_fusion_Domain._inRange_DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DD(*args): # double,double
      return mosek_fusion_Domain._inRange_alt_DD(*args)
    elif mosek_fusion_Domain._match_inRange__3D_3D(*args): # []double,[]double
      return mosek_fusion_Domain._inRange__3D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3D_3D(*args): # []double,[]double
      return mosek_fusion_Domain._inRange_alt__3D_3D(*args)
    elif mosek_fusion_Domain._match_inRange__3DD(*args): # []double,double
      return mosek_fusion_Domain._inRange__3DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3DD(*args): # []double,double
      return mosek_fusion_Domain._inRange_alt__3DD(*args)
    elif mosek_fusion_Domain._match_inRange_D_3D(*args): # double,[]double
      return mosek_fusion_Domain._inRange_D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange_D_3D(*args): # double,[]double
      return mosek_fusion_Domain._inRange_alt_D_3D(*args)
    elif mosek_fusion_Domain._match_inRange_D_3D_3I(*args): # double,[]double,[]int32
      return mosek_fusion_Domain._inRange_D_3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange_D_3D_3I(*args): # double,[]double,[]int32
      return mosek_fusion_Domain._inRange_alt_D_3D_3I(*args)
    elif mosek_fusion_Domain._match_inRange__3DD_3I(*args): # []double,double,[]int32
      return mosek_fusion_Domain._inRange__3DD_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3DD_3I(*args): # []double,double,[]int32
      return mosek_fusion_Domain._inRange_alt__3DD_3I(*args)
    elif mosek_fusion_Domain._match_inRange__3D_3D_3I(*args): # []double,[]double,[]int32
      return mosek_fusion_Domain._inRange__3D_3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3D_3D_3I(*args): # []double,[]double,[]int32
      return mosek_fusion_Domain._inRange_alt__3D_3D_3I(*args)
    elif mosek_fusion_Domain._match_inRange_DD_3I(*args): # double,double,[]int32
      return mosek_fusion_Domain._inRange_DD_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DD_3I(*args): # double,double,[]int32
      return mosek_fusion_Domain._inRange_alt_DD_3I(*args)
    else:
      raise ValueError('Invalid argument list inRange('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRange(double,double)\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),double)\n\tmosek.fusion.Domain.inRange(double,array(double,ndim=1))\n\tmosek.fusion.Domain.inRange(double,array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),double,array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(double,double,array(int32,ndim=1))')
  @staticmethod
  def greaterThan(*args):
    if False: pass
    elif mosek_fusion_Domain._match_greaterThan__3D(*args): # []double
      return mosek_fusion_Domain._greaterThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D(*args): # []double
      return mosek_fusion_Domain._greaterThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_greaterThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._greaterThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_greaterThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._greaterThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._greaterThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D(*args): # double
      return mosek_fusion_Domain._greaterThan_D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D(*args): # double
      return mosek_fusion_Domain._greaterThan_alt_D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._greaterThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._greaterThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._greaterThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._greaterThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan_DI(*args): # double,int32
      return mosek_fusion_Domain._greaterThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DI(*args): # double,int32
      return mosek_fusion_Domain._greaterThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_greaterThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._greaterThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._greaterThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list greaterThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1))\n\tmosek.fusion.Domain.greaterThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=2))\n\tmosek.fusion.Domain.greaterThan(double)\n\tmosek.fusion.Domain.greaterThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(double,int32)\n\tmosek.fusion.Domain.greaterThan(double,int32,int32)')
  @staticmethod
  def isLinPSD(*args):
    if False: pass
    elif mosek_fusion_Domain._match_isLinPSD_(*args): # 
      return mosek_fusion_Domain._isLinPSD_(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_(*args): # 
      return mosek_fusion_Domain._isLinPSD_alt_(*args)
    elif mosek_fusion_Domain._match_isLinPSD_I(*args): # int32
      return mosek_fusion_Domain._isLinPSD_I(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_I(*args): # int32
      return mosek_fusion_Domain._isLinPSD_alt_I(*args)
    elif mosek_fusion_Domain._match_isLinPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isLinPSD_II(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isLinPSD_alt_II(*args)
    else:
      raise ValueError('Invalid argument list isLinPSD('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.isLinPSD()\n\tmosek.fusion.Domain.isLinPSD(int32)\n\tmosek.fusion.Domain.isLinPSD(int32,int32)')
  @staticmethod
  def binary(*args):
    if False: pass
    elif mosek_fusion_Domain._match_binary_(*args): # 
      return mosek_fusion_Domain._binary_(*args)
    elif mosek_fusion_Domain._match_alt_binary_(*args): # 
      return mosek_fusion_Domain._binary_alt_(*args)
    elif mosek_fusion_Domain._match_binary__3I(*args): # []int32
      return mosek_fusion_Domain._binary__3I(*args)
    elif mosek_fusion_Domain._match_alt_binary__3I(*args): # []int32
      return mosek_fusion_Domain._binary_alt__3I(*args)
    elif mosek_fusion_Domain._match_binary_I(*args): # int32
      return mosek_fusion_Domain._binary_I(*args)
    elif mosek_fusion_Domain._match_alt_binary_I(*args): # int32
      return mosek_fusion_Domain._binary_alt_I(*args)
    elif mosek_fusion_Domain._match_binary_II(*args): # int32,int32
      return mosek_fusion_Domain._binary_II(*args)
    elif mosek_fusion_Domain._match_alt_binary_II(*args): # int32,int32
      return mosek_fusion_Domain._binary_alt_II(*args)
    else:
      raise ValueError('Invalid argument list binary('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.binary()\n\tmosek.fusion.Domain.binary(array(int32,ndim=1))\n\tmosek.fusion.Domain.binary(int32)\n\tmosek.fusion.Domain.binary(int32,int32)')
  @staticmethod
  def inDExpCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inDExpCone_(*args): # 
      return mosek_fusion_Domain._inDExpCone_(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone_(*args): # 
      return mosek_fusion_Domain._inDExpCone_alt_(*args)
    elif mosek_fusion_Domain._match_inDExpCone_I(*args): # int32
      return mosek_fusion_Domain._inDExpCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone_I(*args): # int32
      return mosek_fusion_Domain._inDExpCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inDExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inDExpCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inDExpCone_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list inDExpCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inDExpCone()\n\tmosek.fusion.Domain.inDExpCone(int32)\n\tmosek.fusion.Domain.inDExpCone(array(int32,ndim=1))')
  @staticmethod
  def axis(*args):
    if False: pass
    elif mosek_fusion_Domain._match_axis_Lmosek_4fusion_4ConeDomain_2I(*args): # mosek.fusion.ConeDomain,int32
      return mosek_fusion_Domain._axis_Lmosek_4fusion_4ConeDomain_2I(*args)
    elif mosek_fusion_Domain._match_alt_axis_Lmosek_4fusion_4ConeDomain_2I(*args): # mosek.fusion.ConeDomain,int32
      return mosek_fusion_Domain._axis_alt_Lmosek_4fusion_4ConeDomain_2I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.axis(mosek.fusion.ConeDomain,int32)')
  @staticmethod
  def inPPowerCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPPowerCone_D(*args): # double
      return mosek_fusion_Domain._inPPowerCone_D(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_D(*args): # double
      return mosek_fusion_Domain._inPPowerCone_alt_D(*args)
    elif mosek_fusion_Domain._match_inPPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inPPowerCone_DI(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inPPowerCone_alt_DI(*args)
    elif mosek_fusion_Domain._match_inPPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inPPowerCone_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inPPowerCone_alt_D_3I(*args)
    else:
      raise ValueError('Invalid argument list inPPowerCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPPowerCone(double)\n\tmosek.fusion.Domain.inPPowerCone(double,int32)\n\tmosek.fusion.Domain.inPPowerCone(double,array(int32,ndim=1))')
  @staticmethod
  def integral(*args):
    if False: pass
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.integral(mosek.fusion.ConeDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.RangeDomain)')
  @staticmethod
  def inQCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inQCone_(*args): # 
      return mosek_fusion_Domain._inQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_(*args): # 
      return mosek_fusion_Domain._inQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inQCone_I(*args): # int32
      return mosek_fusion_Domain._inQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_I(*args): # int32
      return mosek_fusion_Domain._inQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inQCone()\n\tmosek.fusion.Domain.inQCone(int32)\n\tmosek.fusion.Domain.inQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inQCone(int32,int32)')
  @staticmethod
  def equalsTo(*args):
    if False: pass
    elif mosek_fusion_Domain._match_equalsTo__3D(*args): # []double
      return mosek_fusion_Domain._equalsTo__3D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D(*args): # []double
      return mosek_fusion_Domain._equalsTo_alt__3D(*args)
    elif mosek_fusion_Domain._match_equalsTo_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._equalsTo_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_equalsTo__3_5D(*args): # [,]double
      return mosek_fusion_Domain._equalsTo__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3_5D(*args): # [,]double
      return mosek_fusion_Domain._equalsTo_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D(*args): # double
      return mosek_fusion_Domain._equalsTo_D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D(*args): # double
      return mosek_fusion_Domain._equalsTo_alt_D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._equalsTo_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._equalsTo_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._equalsTo__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._equalsTo_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo_DI(*args): # double,int32
      return mosek_fusion_Domain._equalsTo_DI(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DI(*args): # double,int32
      return mosek_fusion_Domain._equalsTo_alt_DI(*args)
    elif mosek_fusion_Domain._match_equalsTo_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._equalsTo_DII(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._equalsTo_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list equalsTo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1))\n\tmosek.fusion.Domain.equalsTo(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=2))\n\tmosek.fusion.Domain.equalsTo(double)\n\tmosek.fusion.Domain.equalsTo(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(double,int32)\n\tmosek.fusion.Domain.equalsTo(double,int32,int32)')
  @staticmethod
  def inDPowerCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inDPowerCone_D(*args): # double
      return mosek_fusion_Domain._inDPowerCone_D(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_D(*args): # double
      return mosek_fusion_Domain._inDPowerCone_alt_D(*args)
    elif mosek_fusion_Domain._match_inDPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inDPowerCone_DI(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inDPowerCone_alt_DI(*args)
    elif mosek_fusion_Domain._match_inDPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inDPowerCone_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inDPowerCone_alt_D_3I(*args)
    else:
      raise ValueError('Invalid argument list inDPowerCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inDPowerCone(double)\n\tmosek.fusion.Domain.inDPowerCone(double,int32)\n\tmosek.fusion.Domain.inDPowerCone(double,array(int32,ndim=1))')
  @staticmethod
  def inRotatedQCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inRotatedQCone_(*args): # 
      return mosek_fusion_Domain._inRotatedQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_(*args): # 
      return mosek_fusion_Domain._inRotatedQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_I(*args): # int32
      return mosek_fusion_Domain._inRotatedQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_I(*args): # int32
      return mosek_fusion_Domain._inRotatedQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inRotatedQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inRotatedQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inRotatedQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inRotatedQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inRotatedQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRotatedQCone()\n\tmosek.fusion.Domain.inRotatedQCone(int32)\n\tmosek.fusion.Domain.inRotatedQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inRotatedQCone(int32,int32)')
  @staticmethod
  def isTrilPSD(*args):
    if False: pass
    elif mosek_fusion_Domain._match_isTrilPSD_(*args): # 
      return mosek_fusion_Domain._isTrilPSD_(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_(*args): # 
      return mosek_fusion_Domain._isTrilPSD_alt_(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_I(*args): # int32
      return mosek_fusion_Domain._isTrilPSD_I(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_I(*args): # int32
      return mosek_fusion_Domain._isTrilPSD_alt_I(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isTrilPSD_II(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isTrilPSD_alt_II(*args)
    else:
      raise ValueError('Invalid argument list isTrilPSD('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.isTrilPSD()\n\tmosek.fusion.Domain.isTrilPSD(int32)\n\tmosek.fusion.Domain.isTrilPSD(int32,int32)')
  @staticmethod
  def sparse(*args):
    if False: pass
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args): # mosek.fusion.LinearDomain,[]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args): # mosek.fusion.LinearDomain,[]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4LinearDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args): # mosek.fusion.LinearDomain,[,]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args): # mosek.fusion.LinearDomain,[,]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4LinearDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args): # mosek.fusion.RangeDomain,[]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args): # mosek.fusion.RangeDomain,[]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4RangeDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args): # mosek.fusion.RangeDomain,[,]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args): # mosek.fusion.RangeDomain,[,]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4RangeDomain_2_3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.sparse(mosek.fusion.LinearDomain,array(int32,ndim=1))\n\tmosek.fusion.Domain.sparse(mosek.fusion.LinearDomain,array(int32,ndim=2))\n\tmosek.fusion.Domain.sparse(mosek.fusion.RangeDomain,array(int32,ndim=1))\n\tmosek.fusion.Domain.sparse(mosek.fusion.RangeDomain,array(int32,ndim=2))')
  @staticmethod
  def lessThan(*args):
    if False: pass
    elif mosek_fusion_Domain._match_lessThan__3D(*args): # []double
      return mosek_fusion_Domain._lessThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D(*args): # []double
      return mosek_fusion_Domain._lessThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_lessThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._lessThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_lessThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._lessThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._lessThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_lessThan_D(*args): # double
      return mosek_fusion_Domain._lessThan_D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D(*args): # double
      return mosek_fusion_Domain._lessThan_alt_D(*args)
    elif mosek_fusion_Domain._match_lessThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._lessThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._lessThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._lessThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._lessThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan_DI(*args): # double,int32
      return mosek_fusion_Domain._lessThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DI(*args): # double,int32
      return mosek_fusion_Domain._lessThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_lessThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._lessThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._lessThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list lessThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1))\n\tmosek.fusion.Domain.lessThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.lessThan(array(double,ndim=2))\n\tmosek.fusion.Domain.lessThan(double)\n\tmosek.fusion.Domain.lessThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(double,int32)\n\tmosek.fusion.Domain.lessThan(double,int32,int32)')
  def __repr__(self): return 'mosek.fusion.Domain'
  @staticmethod
  def __dimsize_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__dimsize__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dimsize__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   for _2 in range(0,int((_0).shape[0])):
    _1 *= _0[_2]
   return numpy.int64(_1)
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(__0,_1)
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if _1.isSparse(): # src/fusion/domain.mbi:433:12-25
    _2=numpy.zeros((_1.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
    _3=numpy.zeros((_1.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((_1.numNonzeros(),), dtype=numpy.dtype(numpy.float64))
    _1.getDataAsTriplets(_2,_3,_4)
    _5=numpy.zeros((int((_2).shape[0]),2,), dtype=numpy.dtype(numpy.int32))
    for _6 in range(0,int((_2).shape[0])):
     _5[_6,0] = _2[_6]
     _5[_6,1] = _3[_6]
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(_0,False,_4,numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32)),_5,1))
   else:
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(_0,False,_1.getDataAsArray(),numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32)),None,1))
  @staticmethod
  def __prod_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__prod__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __prod__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   for _2 in range(0,int((_0).shape[0])):
    _1 *= _0[_2]
   return numpy.int64(_1)
  @staticmethod
  def __inRange_alt_Z_3D_3D_3_5I_3I(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,ndmin=_monty.checkShape(_t__3,2),dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__inRange_Z_3D_3D_3_5I_3I(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inRange_Z_3D_3D_3_5I_3I(_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((not _0) and (int((_1).shape[0])!=int((_2).shape[0]))): # src/fusion/domain.mbi:414:12-47
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of upper and lower bounds.")
   if ((_3 is not None) and (int((_3).shape[0])!=int((_1).shape[0]))): # src/fusion/domain.mbi:416:12-47
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of upper/lower bounds and sparsity.")
   for _5 in range(0,int((_2).shape[0])):
    if (_1[_5] > _2[_5]): # src/fusion/domain.mbi:420:14-27
     raise mosek_fusion_DomainError._ctor_S("Invalid range specified")
   if ((_4 is not None) and (mosek.fusion.Domain.__dimsize__3I(_4)!=int((_1).shape[0]))): # src/fusion/domain.mbi:423:12-53
    raise mosek_fusion_LengthError._ctor_S("Mismatching dimensions.")
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(_0,_1,_2,_4).sparse(_3))
  @staticmethod
  def _match_symmetric_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_symmetric_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _symmetric_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _symmetric_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0.symmetric())
  @staticmethod
  def _match_symmetric_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_symmetric_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _symmetric_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _symmetric_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0.symmetric())
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_alt_match__3_5I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4RangeDomain_2_3_5I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(_0,_1)
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (_0.sparse(_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4RangeDomain_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4RangeDomain_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (_0.sparse(_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_alt_match__3_5I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4LinearDomain_2_3_5I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(_0,_1)
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (_0.sparse(_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4LinearDomain_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4LinearDomain_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (_0.sparse(_1))
  @staticmethod
  def _match_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0.integral())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0.integral())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4ConeDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4ConeDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4ConeDomain_2(_0):
   return (_0.integral())
  @staticmethod
  def _match_axis_Lmosek_4fusion_4ConeDomain_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_axis_Lmosek_4fusion_4ConeDomain_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _axis_alt_Lmosek_4fusion_4ConeDomain_2I(_t__0,_t__1):
    return mosek_fusion_Domain._axis_Lmosek_4fusion_4ConeDomain_2I(_0,numpy.int32(__1))
  @staticmethod
  def _axis_Lmosek_4fusion_4ConeDomain_2I(_0,_1):
   return (_0.axis(_1))
  @staticmethod
  def _match_inDPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_inDPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _inDPowerCone_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inDPowerCone_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inDPowerCone_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InDPowCone,_0,numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inDPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inDPowerCone_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._inDPowerCone_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _inDPowerCone_DI(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InDPowCone,_0,numpy.array([_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_inDPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _inDPowerCone_alt_D(_t__0):
    return mosek_fusion_Domain._inDPowerCone_D(numpy.float64(__0))
  @staticmethod
  def _inDPowerCone_D(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InDPowCone,_0,None))
  @staticmethod
  def _match_inPPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_inPPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _inPPowerCone_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inPPowerCone_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inPPowerCone_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InPPowCone,_0,numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inPPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inPPowerCone_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._inPPowerCone_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _inPPowerCone_DI(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InPPowCone,_0,numpy.array([_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_inPPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _inPPowerCone_alt_D(_t__0):
    return mosek_fusion_Domain._inPPowerCone_D(numpy.float64(__0))
  @staticmethod
  def _inPPowerCone_D(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InPPowCone,_0,None))
  @staticmethod
  def _match_inDExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inDExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inDExpCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inDExpCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inDExpCone__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inDExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inDExpCone_alt_I(_t__0):
    return mosek_fusion_Domain._inDExpCone_I(numpy.int32(__0))
  @staticmethod
  def _inDExpCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,numpy.array([_0,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inDExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inDExpCone_alt_():
    return mosek_fusion_Domain._inDExpCone_()
  @staticmethod
  def _inDExpCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,None))
  @staticmethod
  def _match_inPExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inPExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inPExpCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inPExpCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inPExpCone__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inPExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inPExpCone_alt_I(_t__0):
    return mosek_fusion_Domain._inPExpCone_I(numpy.int32(__0))
  @staticmethod
  def _inPExpCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,numpy.array([_0,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPExpCone_alt_():
    return mosek_fusion_Domain._inPExpCone_()
  @staticmethod
  def _inPExpCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,None))
  @staticmethod
  def _match_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inRotatedQCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRotatedQCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRotatedQCone__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InRotatedQCone,0.0,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inRotatedQCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inRotatedQCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inRotatedQCone_II(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InRotatedQCone,0.0,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inRotatedQCone_alt_I(_t__0):
    return mosek_fusion_Domain._inRotatedQCone_I(numpy.int32(__0))
  @staticmethod
  def _inRotatedQCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InRotatedQCone,0.0,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inRotatedQCone_alt_():
    return mosek_fusion_Domain._inRotatedQCone_()
  @staticmethod
  def _inRotatedQCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InRotatedQCone,0.0,None))
  @staticmethod
  def _match_inQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inQCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inQCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inQCone__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InQCone,0.0,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inQCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inQCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inQCone_II(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InQCone,0.0,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inQCone_alt_I(_t__0):
    return mosek_fusion_Domain._inQCone_I(numpy.int32(__0))
  @staticmethod
  def _inQCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InQCone,0.0,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inQCone_alt_():
    return mosek_fusion_Domain._inQCone_()
  @staticmethod
  def _inQCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InQCone,0.0,None))
  @staticmethod
  def _match_isLinPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_isLinPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _isLinPSD_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._isLinPSD_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _isLinPSD_II(_0,_1):
   return (mosek_fusion_LinPSDDomain._ctor__3I(mosek.fusion.Set._make_II(((_0 * (_0 + 1)) // 2),_1)))
  @staticmethod
  def _match_isLinPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_isLinPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _isLinPSD_alt_I(_t__0):
    return mosek_fusion_Domain._isLinPSD_I(numpy.int32(__0))
  @staticmethod
  def _isLinPSD_I(_0):
   return (mosek_fusion_LinPSDDomain._ctor__3I(mosek.fusion.Set._make_I(((_0 * (_0 + 1)) // 2))))
  @staticmethod
  def _match_isLinPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isLinPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _isLinPSD_alt_():
    return mosek_fusion_Domain._isLinPSD_()
  @staticmethod
  def _isLinPSD_():
   return (mosek_fusion_LinPSDDomain._ctor_())
  @staticmethod
  def _match_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _isTrilPSD_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._isTrilPSD_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _isTrilPSD_II(_0,_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3III(mosek.fusion.PSDKey.IsTrilPSD,numpy.array([_1,_0,_0], dtype=numpy.dtype(numpy.int32)),1,2))
  @staticmethod
  def _match_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _isTrilPSD_alt_I(_t__0):
    return mosek_fusion_Domain._isTrilPSD_I(numpy.int32(__0))
  @staticmethod
  def _isTrilPSD_I(_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3III(mosek.fusion.PSDKey.IsTrilPSD,numpy.array([_0,_0], dtype=numpy.dtype(numpy.int32)),0,1))
  @staticmethod
  def _match_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _isTrilPSD_alt_():
    return mosek_fusion_Domain._isTrilPSD_()
  @staticmethod
  def _isTrilPSD_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsTrilPSD))
  @staticmethod
  def _match_inPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inPSDCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inPSDCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inPSDCone_II(_0,_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3I(mosek.fusion.PSDKey.IsSymPSD,numpy.array([_1,_0,_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inPSDCone_alt_I(_t__0):
    return mosek_fusion_Domain._inPSDCone_I(numpy.int32(__0))
  @staticmethod
  def _inPSDCone_I(_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3I(mosek.fusion.PSDKey.IsSymPSD,numpy.array([_0,_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPSDCone_alt_():
    return mosek_fusion_Domain._inPSDCone_()
  @staticmethod
  def _inPSDCone_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsSymPSD))
  @staticmethod
  def _match_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _binary_alt_():
    return mosek_fusion_Domain._binary_()
  @staticmethod
  def _binary_():
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),None).integral())
  @staticmethod
  def _match_binary__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_binary__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _binary_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._binary__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binary__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),_0).integral())
  @staticmethod
  def _match_binary_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_binary_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _binary_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._binary_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _binary_II(_0,_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))).integral())
  @staticmethod
  def _match_binary_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_binary_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _binary_alt_I(_t__0):
    return mosek_fusion_Domain._binary_I(numpy.int32(__0))
  @staticmethod
  def _binary_I(_0):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),numpy.array([_0], dtype=numpy.dtype(numpy.int32))).integral())
  @staticmethod
  def _match_inRange__3D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3D__(_0) and __arg_match__3D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange__3D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt__3D_3D_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange__3D_3D_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3D_3D_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,_1,_2))
  @staticmethod
  def _match_inRange__3DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3D__(_0) and __arg_match_D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange__3DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt__3DD_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.float64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange__3DD_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3DD_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,numpy.array([_1 for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64)),_2))
  @staticmethod
  def _match_inRange_D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match__3D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange_D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt_D_3D_3I(_t__0,_t__1,_t__2):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange_D_3D_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_D_3D_3I(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([_0 for _3 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),_1,_2))
  @staticmethod
  def _match_inRange_DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange_DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt_DD_3I(_t__0,_t__1,_t__2):
   _0=numpy.float64(_t__0)
   _1=numpy.float64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange_DD_3I(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_DD_3I(_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.float64)),_2))
  @staticmethod
  def _match_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _inRange_alt__3D_3D(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange__3D_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3D_3D(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,_1,numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange__3DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange__3DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt__3DD(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.float64(_t__1)
   _1 = mosek_fusion_Domain._inRange__3DD(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3DD(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,numpy.array([_1 for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_inRange_D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _inRange_alt_D_3D(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange_D_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_D_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([_0 for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),_1,numpy.array([int((_1).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange_DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt_DD(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_DD(numpy.float64(__0),numpy.float64(__1))
  @staticmethod
  def _inRange_DD(_0,_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _greaterThan_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _greaterThan_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _greaterThan_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._greaterThan__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan__3D_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),_1))
  @staticmethod
  def _match_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _greaterThan_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._greaterThan__3_5D(_0)
   return _1
  @staticmethod
  def _greaterThan__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_greaterThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _greaterThan_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._greaterThan__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _greaterThan_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._greaterThan_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,True,numpy.array([_0 for _2 in range(0,mosek.fusion.Domain.__prod__3I(_1))], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def _match_greaterThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_greaterThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _greaterThan_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._greaterThan_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _greaterThan_DII(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,True,numpy.array([_0 for _3 in range(0,(_2 * _1))], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_greaterThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _greaterThan_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._greaterThan_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _greaterThan_DI(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,True,numpy.array([_0 for _2 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_greaterThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _greaterThan_alt_D(_t__0):
    return mosek_fusion_Domain._greaterThan_D(numpy.float64(__0))
  @staticmethod
  def _greaterThan_D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _lessThan_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _lessThan_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _lessThan_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._lessThan__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan__3D_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),_1))
  @staticmethod
  def _match_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _lessThan_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._lessThan__3_5D(_0)
   return _1
  @staticmethod
  def _lessThan__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_lessThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _lessThan_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._lessThan__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _lessThan_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._lessThan_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def _match_lessThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_lessThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _lessThan_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._lessThan_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _lessThan_DII(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_lessThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _lessThan_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._lessThan_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _lessThan_DI(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_lessThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _lessThan_alt_D(_t__0):
    return mosek_fusion_Domain._lessThan_D(numpy.float64(__0))
  @staticmethod
  def _lessThan_D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _equalsTo_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _equalsTo_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _equalsTo_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._equalsTo__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo__3D_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),_1))
  @staticmethod
  def _match_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _equalsTo_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._equalsTo__3_5D(_0)
   return _1
  @staticmethod
  def _equalsTo__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_equalsTo__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _equalsTo_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._equalsTo__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _equalsTo_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._equalsTo_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def _match_equalsTo_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_equalsTo_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _equalsTo_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._equalsTo_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _equalsTo_DII(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_equalsTo_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _equalsTo_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._equalsTo_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _equalsTo_DI(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_equalsTo_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _equalsTo_alt_D(_t__0):
    return mosek_fusion_Domain._equalsTo_D(numpy.float64(__0))
  @staticmethod
  def _equalsTo_D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_unbounded__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_unbounded__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _unbounded_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._unbounded__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _unbounded__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_unbounded_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _unbounded_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._unbounded_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _unbounded_II(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_unbounded_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _unbounded_alt_I(_t__0):
    return mosek_fusion_Domain._unbounded_I(numpy.int32(__0))
  @staticmethod
  def _unbounded_I(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _unbounded_alt_():
    return mosek_fusion_Domain._unbounded_()
  @staticmethod
  def _unbounded_():
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,True,None,None))
 return Domain
mosek_fusion_Domain=__mk_mosek_fusion_Domain()
del __mk_mosek_fusion_Domain
#BEFORE CLASS
def __mk_mosek_fusion_BaseExpression():
 class BaseExpression(mosek_fusion_Expression,object):
  __slots__ = ['_BaseExpression__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I(*args): # []int32
      self._ctor_init__3I(*args)
    elif self.__match_alt_ctor__3I(*args):# []int32
      self._ctor_alt_init__3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseExpression.ctor(array(int32,ndim=1))')
  @staticmethod
  def storeexpr(*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_storeexpr_Lmosek_4fusion_4WorkStack_2_3I_3I_3J_3J_3D_3D(*args): # mosek.fusion.WorkStack,[]int32,[]int32,[]int64,[]int64,[]double,[]double
      return mosek_fusion_BaseExpression._storeexpr_Lmosek_4fusion_4WorkStack_2_3I_3I_3J_3J_3D_3D(*args)
    elif mosek_fusion_BaseExpression._match_alt_storeexpr_Lmosek_4fusion_4WorkStack_2_3I_3I_3J_3J_3D_3D(*args): # mosek.fusion.WorkStack,[]int32,[]int32,[]int64,[]int64,[]double,[]double
      return mosek_fusion_BaseExpression._storeexpr_alt_Lmosek_4fusion_4WorkStack_2_3I_3I_3J_3J_3D_3D(*args)
    else:
      raise ValueError('Invalid argument list storeexpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.storeexpr(mosek.fusion.WorkStack,array(int32,ndim=1),array(int32,ndim=1),array(int64,ndim=1),array(int64,ndim=1),array(double,ndim=1),array(double,ndim=1))')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BaseExpression._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_BaseExpression._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.pick(array(int32,ndim=1))\n\tmosek.fusion.BaseExpression.pick(array(int32,ndim=2))')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getShape()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BaseExpression._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BaseExpression._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.slice(int32,int32)\n\tmosek.fusion.BaseExpression.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_BaseExpression._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_BaseExpression._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_BaseExpression._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.eval()\n\tmosek.fusion.BaseExpression.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_BaseExpression._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.toString()')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getND()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_BaseExpression._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_BaseExpression._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.index(int32)\n\tmosek.fusion.BaseExpression.index(array(int32,ndim=1))')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getSize()')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_BaseExpression._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getDim(int32)')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.BaseExpression: '+self._toString_()
  @staticmethod
  def _ctor__3I(shape):
    o = BaseExpression.__new__(BaseExpression)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   assert shape is None or isinstance(shape,numpy.ndarray)
   (self.__shape) = shape
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("Expression()")
  @staticmethod
  def _match_eval_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_eval_(*args):
    if len(args) != 0: return False
    return True
  def _eval_alt_(self,):
    return self._eval_()
  def _eval_(self,):
   _0=mosek_fusion_WorkStack._ctor_()
   _1=mosek_fusion_WorkStack._ctor_()
   _2=mosek_fusion_WorkStack._ctor_()
   self.eval(_0,_1,_2)
   _3=_0.popi32()
   _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _0.popi32(_3,_4,0)
   _5=_0.popi32()
   _6=_0.popi32()
   _7=1
   for _8 in range(0,_3):
    _7 *= _4[_8]
   _9=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_5 + 1),), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   _13=None
   if (_7 < _5): # src/fusion/BaseExpression.monty:436:12-28
    _13 = numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _0.popi64(_5,_13,0)
   _0.popi32(_5,_10,1)
   _0.popi64(_6,_9,0)
   _0.popf64(_5,_11,0)
   _0.popf64(_6,_12,0)
   return (mosek_fusion_FlatExpr._ctor__3D_3J_3J_3D_3I_3J(_11,numpy.array([_10[_14] for _14 in range(0,(_5 + 1))], dtype=numpy.dtype(numpy.int64)),_9,_12,_4,_13))
  @staticmethod
  def _match_storeexpr_Lmosek_4fusion_4WorkStack_2_3I_3I_3J_3J_3D_3D(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match__3J__(_3) and __arg_match__3J__(_4) and __arg_match__3D__(_5) and __arg_match__3D__(_6))
  @staticmethod
  def _match_alt_storeexpr_Lmosek_4fusion_4WorkStack_2_3I_3I_3J_3J_3D_3D(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3J__(_3) and __arg_alt_match__3J__(_4) and __arg_alt_match__3D__(_5) and __arg_alt_match__3D__(_6))
  @staticmethod
  def _storeexpr_alt_Lmosek_4fusion_4WorkStack_2_3I_3I_3J_3J_3D_3D(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_BaseExpression._storeexpr_Lmosek_4fusion_4WorkStack_2_3I_3I_3J_3J_3D_3D(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _storeexpr_Lmosek_4fusion_4WorkStack_2_3I_3I_3J_3J_3D_3D(_0,_1,_2,_3,_4,_5,_6):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   _7=_2[(int((_2).shape[0]) - 1)]
   _8=(int((_2).shape[0]) - 1)
   _9=int((_1).shape[0])
   _10=_0.alloci32((_8 + 1))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(_2,0,(_0.i32),_10,(_8 + 1))
   _0.pushi32((1 if ((_3 is not None) ) else 0))
   _0.pushi32(_7)
   _0.pushi32(_8)
   _11=_0.alloci32(_9)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(_1,0,(_0.i32),_11,_9)
   _0.pushi32(_9)
   _12=_0.alloci64(_7)
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_4,0,(_0.i64),_12,_7)
   if (_3 is not None): # src/fusion/BaseExpression.monty:398:12-22
    _13=_0.alloci64(_8)
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_3,0,(_0.i64),_13,_8)
   _14=_0.allocf64(_7)
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_5,0,(_0.f64),_14,_7)
   _15=_0.allocf64(_8)
   if (_6 is not None): # src/fusion/BaseExpression.monty:410:14-26
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_6,0,(_0.f64),_15,_8)
   else:
    for _16 in range(0,_8):
     (_0.f64)[(_15 + _16)] = 0
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_0))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   for _2 in range(0,int((_0).shape[0])):
    _1[_2,0] = _0[_2]
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_1))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((1,int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   for _2 in range(0,int((_0).shape[0])):
    _1[0,_2] = _0[_2]
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_1))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   _1=numpy.zeros((1,1,), dtype=numpy.dtype(numpy.int32))
   _1[0,0] = _0
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_1))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprSlice._ctor_Lmosek_4fusion_4Expression_2_3I_3I(self,_0,_1))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_ExprSlice._ctor_Lmosek_4fusion_4Expression_2_3I_3I(self,numpy.array([_0], dtype=numpy.dtype(numpy.int32)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   return numpy.int64(mosek.fusion.Set._size__3I(self.__shape))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   return numpy.int32(self.__shape[_0])
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
 return BaseExpression
mosek_fusion_BaseExpression=__mk_mosek_fusion_BaseExpression()
del __mk_mosek_fusion_BaseExpression
#BEFORE CLASS
def __mk_mosek_fusion_ExprConst():
 class ExprConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprConst__sparsity','_ExprConst__bfix']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I_3J_3D(*args): # []int32,[]int64,[]double
      self._ctor_init__3I_3J_3D(*args)
    elif self.__match_alt_ctor__3I_3J_3D(*args):# []int32,[]int64,[]double
      self._ctor_alt_init__3I_3J_3D(*args)
    elif self.__match_ctor__3I_3JD(*args): # []int32,[]int64,double
      self._ctor_init__3I_3JD(*args)
    elif self.__match_alt_ctor__3I_3JD(*args):# []int32,[]int64,double
      self._ctor_alt_init__3I_3JD(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprConst.ctor(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.ExprConst.ctor(array(int32,ndim=1),array(int64,ndim=1),double)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprConst._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprConst._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprConst.eval()\n\tmosek.fusion.ExprConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprConst._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprConst._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprConst.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprConst: '+self._toString_()
  @staticmethod
  def _ctor__3I_3J_3D(shape,sparsity,bfix):
    o = ExprConst.__new__(ExprConst)
    o._ctor_init__3I_3J_3D(shape,sparsity,bfix)
    return o
  @staticmethod
  def __match_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3D__(bfix))
  @staticmethod
  def __match_alt_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3D__(bfix))
  def _ctor_alt_init__3I_3J_3D(self,shape,sparsity,bfix):
    self._ctor_init__3I_3J_3D(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3J_3D(self,shape,sparsity,bfix):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,shape)
   (self.__bfix) = mosek.fusion.Utils.Tools._arraycopy__3D(bfix)
   (self.__sparsity) = (mosek.fusion.Utils.Tools._arraycopy__3J(sparsity) if ((sparsity is not None) ) else None)
   mosek.fusion.ExprConst.__validate__3I_3D_3J(shape,bfix,sparsity)
  @staticmethod
  def _ctor__3I_3JD(shape,sparsity,bfix):
    o = ExprConst.__new__(ExprConst)
    o._ctor_init__3I_3JD(shape,sparsity,bfix)
    return o
  @staticmethod
  def __match_ctor__3I_3JD(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match_D__(bfix))
  @staticmethod
  def __match_alt_ctor__3I_3JD(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match_D__(bfix))
  def _ctor_alt_init__3I_3JD(self,shape,sparsity,bfix):
    self._ctor_init__3I_3JD(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.float64(bfix))
  def _ctor_init__3I_3JD(self,shape,sparsity,bfix):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,shape)
   _0=(mosek.fusion.Set._size__3I(shape) if ((sparsity is None) ) else int((sparsity).shape[0]))
   (self.__bfix) = numpy.array([bfix for _1 in range(0,_0)], dtype=numpy.dtype(numpy.float64))
   (self.__sparsity) = (mosek.fusion.Utils.Tools._arraycopy__3J(sparsity) if ((sparsity is not None) ) else None)
   mosek.fusion.ExprConst.__validate__3I_3D_3J(shape,(self.__bfix),sparsity)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self.getShape()
   _4=int((self.__bfix).shape[0])
   _5=((self.__sparsity is not None) and (int((self.__sparsity).shape[0]) < mosek.fusion.Set._size__3I(_3)))
   _6=_0.alloci32((_4 + 1))
   _0.pushi32((1 if (_5 ) else 0))
   _0.pushi32(0)
   _0.pushi32(_4)
   for _7 in range(0,int((_3).shape[0])):
    _0.pushi32(_3[_7])
   _0.pushi32(int((_3).shape[0]))
   if (self.__sparsity is not None): # src/fusion/ExprConst.monty:58:12-28
    _8=_0.alloci64(int((self.__sparsity).shape[0]))
    _9=(_0.i64)
    for _10 in range(0,int((self.__sparsity).shape[0])):
     _9[(_8 + _10)] = self.__sparsity[_10]
   _11=_0.allocf64(int((self.__bfix).shape[0]))
   _12=(_0.f64)
   for _13 in range(0,int((self.__bfix).shape[0])):
    _12[(_11 + _13)] = self.__bfix[_13]
   _14=(_0.i32)
   for _15 in range(0,(_4 + 1)):
    _14[(_6 + _15)] = 0
  @staticmethod
  def __validate_alt__3I_3D_3J(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_ExprConst.__validate__3I_3D_3J(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate__3I_3D_3J(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=mosek.fusion.Set._size__3I(_0)
   if (_2 is not None): # src/fusion/ExprConst.monty:12:12-28
    if (int((_2).shape[0])!=int((_1).shape[0])): # src/fusion/ExprConst.monty:13:14-40
     raise mosek_fusion_LengthError._ctor_S("Mismatching data lengths")
    _4=False
    for _5 in range(0,int((_2).shape[0])):
     if ((_2[_5] < 0) or (_2[_5] >= _3)): # src/fusion/ExprConst.monty:17:16-52
      _4 = True
    if _4: # src/fusion/ExprConst.monty:19:14-17
     raise mosek_fusion_IndexError._ctor_S("Invalid sparsity index")
   else:
    if (int((_1).shape[0])!=_3): # src/fusion/ExprConst.monty:23:14-29
     raise mosek_fusion_LengthError._ctor_S("Mismatching data length")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprConst()")
 return ExprConst
mosek_fusion_ExprConst=__mk_mosek_fusion_ExprConst()
del __mk_mosek_fusion_ExprConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprPick():
 class ExprPick(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprPick__idxs','_ExprPick__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args): # mosek.fusion.Expression,[,]int32
      self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):# mosek.fusion.Expression,[,]int32
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3J(*args): # mosek.fusion.Expression,[]int64
      self._ctor_init_Lmosek_4fusion_4Expression_2_3J(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3J(*args):# mosek.fusion.Expression,[]int64
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprPick.ctor(mosek.fusion.Expression,array(int32,ndim=2))\n\tmosek.fusion.ExprPick.ctor(mosek.fusion.Expression,array(int64,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprPick._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprPick._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprPick._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprPick._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPick.eval()\n\tmosek.fusion.ExprPick.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprPick._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprPick._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPick.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprPick: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3_5I(expr,idxs):
    o = ExprPick.__new__(ExprPick)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(expr,idxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3_5I__(idxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3_5I__(idxs))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I(self,expr,idxs):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(expr,numpy.array(idxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3_5I(self,expr,idxs):
   assert idxs is None or isinstance(idxs,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([int((idxs).shape[0])], dtype=numpy.dtype(numpy.int32)))
   _0=expr.getShape()
   _1=int((_0).shape[0])
   (self.__expr) = expr
   (self.__idxs) = numpy.zeros((int((idxs).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _2=(self.__idxs)
   if (int((idxs).shape[1])!=_1): # src/fusion/ExprSlice.monty:184:12-29
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and index dimensions")
   _3=False
   for _4 in range(0,int((idxs).shape[0])):
    for _5 in range(0,_1):
     if ((idxs[_4,_5] < 0) or (idxs[_4,_5] >= _0[_5])): # src/fusion/ExprSlice.monty:190:16-54
      _3 = True
   if _3: # src/fusion/ExprSlice.monty:192:12-22
    raise mosek_fusion_IndexError._ctor_S("Pick index out of bounds")
   _6=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
   _6[(_1 - 1)] = 1
   for _7 in range(1,_1):
    _6[((_1 - _7) - 1)] = (_6[(_1 - _7)] * _0[(_1 - _7)])
   for _8 in range(0,int((idxs).shape[0])):
    _9=0
    for _10 in range(0,_1):
     _9 += (_6[_10] * idxs[_8,_10])
    _2[_8] = _9
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3J(expr,idxs):
    o = ExprPick.__new__(ExprPick)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3J(expr,idxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3J(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3J__(idxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3J(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3J__(idxs))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3J(self,expr,idxs):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3J(expr,numpy.array(idxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3J(self,expr,idxs):
   assert idxs is None or isinstance(idxs,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([int((idxs).shape[0])], dtype=numpy.dtype(numpy.int32)))
   (self.__expr) = expr
   _0=expr.getShape()
   _1=mosek.fusion.Set._size__3I(_0)
   _2=False
   for _3 in range(0,int((idxs).shape[0])):
    if ((idxs[_3] < 0) or (idxs[_3] >= _1)): # src/fusion/ExprSlice.monty:165:14-44
     _2 = True
   if _2: # src/fusion/ExprSlice.monty:167:12-22
    raise mosek_fusion_IndexError._ctor_S("Pick index out of bounds")
   (self.__idxs) = mosek.fusion.Utils.Tools._arraycopy__3J(idxs)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_1,_0,_2)
   _1.pop_expr()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.hassp)
   _8=(_1.ptr_base)
   _9=(_1.sp_base)
   _10=(_1.nidxs_base)
   _11=(_1.bfix_base)
   _12=(_1.cof_base)
   _13=(_1.i32)
   _14=(_1.i64)
   _15=(_1.f64)
   _16=(self.__idxs)
   if (not _7): # src/fusion/ExprSlice.monty:227:12-21
    _17=int((_16).shape[0])
    _18=1
    _19=0
    for _20 in range(0,int((_16).shape[0])):
     _19 += (_13[((_8 + _16[_20]) + 1)] - _13[(_8 + _16[_20])])
    _0.alloc_expr(_18,_17,_19,False)
    _21=(_0.cof_base)
    _22=(_0.bfix_base)
    _23=(_0.nidxs_base)
    _24=(_0.ptr_base)
    _25=(_0.shape_base)
    _26=(_0.i32)
    _27=(_0.i64)
    _28=(_0.f64)
    _26[_25] = int((_16).shape[0])
    _29=0
    _26[_24] = 0
    for _30 in range(0,int((_16).shape[0])):
     for _31 in range(_13[(_8 + _16[_30])],_13[((_8 + _16[_30]) + 1)]):
      _27[(_23 + _29)] = _14[(_10 + _31)]
      _28[(_21 + _29)] = _15[(_12 + _31)]
      _29 += 1
     _28[(_22 + _30)] = _15[(_11 + _16[_30])]
     _26[((_24 + _30) + 1)] = _29
   else:
    _32=1
    _33=int((_16).shape[0])
    _34=0
    _35=(self.__idxs)
    _36=_2.alloci32(int((_35).shape[0]))
    _37=(_2.i32)
    for _38 in range(0,int((_35).shape[0])):
     _39=_5
     _40=0
     while (_40 < (_39 - 1)):
      _41=(((_39 + _40) + 1) // 2)
      if (_14[(_9 + _41)] >= _35[_38]): # src/fusion/ExprSlice.monty:287:18-45
       _39 = _41
      else:
       _40 = _41
     _40 += 1
     if ((_40 < _5) and (_14[(_9 + _40)]==_35[_38])): # src/fusion/ExprSlice.monty:292:16-58
      _37[(_36 + _38)] = _40
      _34 += (_13[((_8 + _40) + 1)] - _13[(_8 + _40)])
     else:
      _37[(_36 + _38)] = (- 1)
    _0.alloc_expr(_32,_33,_34,False)
    _42=(_0.ptr_base)
    _43=(_0.nidxs_base)
    _44=(_0.cof_base)
    _45=(_0.bfix_base)
    _46=(_0.shape_base)
    _47=(_0.i32)
    _48=(_0.i64)
    _49=(_0.f64)
    _47[_46] = int((_35).shape[0])
    _47[_42] = 0
    _50=0
    for _51 in range(0,int((_35).shape[0])):
     if (_37[(_36 + _51)] >= 0): # src/fusion/ExprSlice.monty:321:16-34
      _52=_37[(_36 + _51)]
      for _53 in range(_13[(_8 + _52)],_13[((_8 + _52) + 1)]):
       _48[(_43 + _50)] = _14[(_10 + _53)]
       _49[(_44 + _50)] = _15[(_12 + _53)]
       _50 += 1
      _49[(_45 + _51)] = _15[(_11 + _52)]
     else:
      _49[(_45 + _51)] = 0.0
     _47[((_42 + _51) + 1)] = _50
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprPick()")
 return ExprPick
mosek_fusion_ExprPick=__mk_mosek_fusion_ExprPick()
del __mk_mosek_fusion_ExprPick
#BEFORE CLASS
def __mk_mosek_fusion_ExprSlice():
 class ExprSlice(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSlice__last','_ExprSlice__first','_ExprSlice__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args): # mosek.fusion.Expression,[]int32,[]int32
      self._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):# mosek.fusion.Expression,[]int32,[]int32
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSlice.ctor(mosek.fusion.Expression,array(int32,ndim=1),array(int32,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprSlice._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprSlice._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprSlice._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSlice._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSlice.eval()\n\tmosek.fusion.ExprSlice.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprSlice._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprSlice._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSlice.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprSlice: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3I_3I(expr,first,last):
    o = ExprSlice.__new__(ExprSlice)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(expr,first,last)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):
    if len(args) != 3: return False
    expr,first,last, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3I__(first) and __arg_match__3I__(last))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):
    if len(args) != 3: return False
    expr,first,last, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3I__(first) and __arg_alt_match__3I__(last))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3I_3I(self,expr,first,last):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(expr,numpy.array(first,dtype=numpy.dtype(numpy.int32)),numpy.array(last,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(self,expr,first,last):
   assert first is None or isinstance(first,numpy.ndarray)
   assert last is None or isinstance(last,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprSlice.__makeShape__3I_3I_3I(expr.getShape(),first,last))
   (self.__expr) = expr
   (self.__first) = first
   (self.__last) = last
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_1,_0,_2)
   _3=_1.popi32()
   _4=_1.popi32(_3)
   _5=_1.popi32()
   _6=_1.popi32()
   _7=(_1.popi32()!=0)
   _8=_1.popi32((_5 + 1))
   _9=(_1.popi64(_5) if (_7 ) else (- 1))
   _10=_1.popi64(_6)
   _11=_1.popf64(_5)
   _12=_1.popf64(_6)
   _13=(_1.i32)
   _14=(_1.i64)
   _15=(_1.f64)
   _16=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _16[(_3 - 1)] = 1
   for _17 in range(1,_3):
    _16[((_3 - _17) - 1)] = (_16[(_3 - _17)] * _13[((_4 + _3) - _17)])
   _18=0
   _19=0
   if _7: # src/fusion/ExprSlice.monty:58:12-17
    for _20 in range(0,_5):
     _21=True
     for _22 in range(0,_3):
      _23=((_14[(_9 + _20)] // _16[_22]) % _13[(_4 + _22)])
      _21 = (_21 and ((_23 >= self.__first[_22]) and (_23 < self.__last[_22])))
     if _21: # src/fusion/ExprSlice.monty:65:16-25
      _19 += (_13[((_8 + _20) + 1)] - _13[(_8 + _20)])
      _18 += 1
   else:
    _18 = 1
    for _24 in range(0,_3):
     _18 *= (self.__last[_24] - self.__first[_24])
    for _25 in range(0,_5):
     _26=True
     for _27 in range(0,_3):
      _28=((_25 // _16[_27]) % _13[(_4 + _27)])
      _26 = (_26 and ((_28 >= self.__first[_27]) and (_28 < self.__last[_27])))
     if _26: # src/fusion/ExprSlice.monty:78:16-25
      _19 += (_13[((_8 + _25) + 1)] - _13[(_8 + _25)])
   _29=numpy.array([(self.__last[_30] - self.__first[_30]) for _30 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
   _31=_0.allocf64(_19)
   _32=_0.allocf64(_18)
   _33=_0.alloci64(_19)
   _34=(_0.alloci64(_18) if (_7 ) else (- 1))
   _35=_0.alloci32((_18 + 1))
   _0.pushi32((1 if (_7 ) else 0))
   _0.pushi32(_19)
   _0.pushi32(_18)
   for _36 in range(0,_3):
    _0.pushi32(_29[_36])
   _0.pushi32(_3)
   _37=(_0.i32)
   _38=(_0.i64)
   _39=(_0.f64)
   _37[_35] = 0
   _40=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _40[(_3 - 1)] = 1
   for _41 in range(1,_3):
    _40[((_3 - _41) - 1)] = (_40[(_3 - _41)] * _29[(_3 - _41)])
   _42=0
   _43=0
   if _7: # src/fusion/ExprSlice.monty:107:12-17
    _44=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    for _45 in range(0,_5):
     _46=True
     for _47 in range(0,_3):
      _44[_47] = numpy.int32(((_14[(_9 + _45)] // _16[_47]) % _13[(_4 + _47)]))
      _46 = (_46 and ((_44[_47] >= self.__first[_47]) and (_44[_47] < self.__last[_47])))
     if _46: # src/fusion/ExprSlice.monty:115:16-25
      for _48 in range(_13[(_8 + _45)],_13[((_8 + _45) + 1)]):
       _38[(_33 + _43)] = _14[(_10 + _48)]
       _39[(_31 + _43)] = _15[(_12 + _48)]
       _43 += 1
      _49=0
      for _50 in range(0,_3):
       _49 += (_40[_50] * (_44[_50] - self.__first[_50]))
      _38[(_34 + _42)] = _49
      _39[(_32 + _42)] = _15[(_11 + _45)]
      _37[((_35 + _42) + 1)] = _43
      _42 += 1
   else:
    for _51 in range(0,_5):
     _52=True
     for _53 in range(0,_3):
      _54=((_51 // _16[_53]) % _13[(_4 + _53)])
      _52 = (_52 and ((_54 >= self.__first[_53]) and (_54 < self.__last[_53])))
     if _52: # src/fusion/ExprSlice.monty:136:16-25
      for _55 in range(_13[(_8 + _51)],_13[((_8 + _51) + 1)]):
       _38[(_33 + _43)] = _14[(_10 + _55)]
       _39[(_31 + _43)] = _15[(_12 + _55)]
       _43 += 1
      _39[(_32 + _42)] = _15[(_11 + _51)]
      _37[((_35 + _42) + 1)] = _43
      _42 += 1
  @staticmethod
  def __makeShape_alt__3I_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprSlice.__makeShape__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __makeShape__3I_3I_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[0])!=int((_2).shape[0]))): # src/fusion/ExprSlice.monty:18:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid or mismatching index lengths")
   for _3 in range(0,int((_0).shape[0])):
    if ((_1[_3] < 0) or ((_2[_3] < _1[_3]) or (_2[_3] > _0[_3]))): # src/fusion/ExprSlice.monty:21:14-70
     raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   return (numpy.array([(_2[_4] - _1[_4]) for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprSlice([")._a_I(self.__first[0])._a_S(":")._a_I(self.__last[0])
   for _1 in range(1,int((self.__first).shape[0])):
    _0._a_S(",")._a_I(self.__first[_1])._a_S(":")._a_I(self.__last[_1])
   _0._a_S("],")._a_S(self.__expr.toString())._a_S(")")
   return (_0._toString_())
 return ExprSlice
mosek_fusion_ExprSlice=__mk_mosek_fusion_ExprSlice()
del __mk_mosek_fusion_ExprSlice
#BEFORE CLASS
def __mk_mosek_fusion_ExprPermuteDims():
 class ExprPermuteDims(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprPermuteDims__dperm','_ExprPermuteDims__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3ILmosek_4fusion_4Expression_2(*args): # []int32,mosek.fusion.Expression
      self._ctor_init__3ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):# []int32,mosek.fusion.Expression
      self._ctor_alt_init__3ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprPermuteDims.ctor(array(int32,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprPermuteDims._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprPermuteDims._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprPermuteDims._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprPermuteDims._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPermuteDims.eval()\n\tmosek.fusion.ExprPermuteDims.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprPermuteDims'
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2(perm,expr):
    o = ExprPermuteDims.__new__(ExprPermuteDims)
    o._ctor_init__3ILmosek_4fusion_4Expression_2(perm,expr)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    perm,expr, = args
    return (__arg_match__3I__(perm) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    perm,expr, = args
    return (__arg_alt_match__3I__(perm) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2(self,perm,expr):
    self._ctor_init__3ILmosek_4fusion_4Expression_2(numpy.array(perm,dtype=numpy.dtype(numpy.int32)),expr)
  def _ctor_init__3ILmosek_4fusion_4Expression_2(self,perm,expr):
   assert perm is None or isinstance(perm,numpy.ndarray)
   mosek_fusion_ExprPermuteDims._ctor_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,1)
   _0=expr.getShape()
   if (int((perm).shape[0])!=int((_0).shape[0])): # src/fusion/ExprTranspose.monty:148:12-35
    raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation")
   _1=numpy.array([0 for _2 in range(0,int((perm).shape[0]))], dtype=numpy.dtype(numpy.int32))
   for _3 in range(0,int((_1).shape[0])):
    if ((perm[_3] < 0) or (perm[_3] > int((_0).shape[0]))): # src/fusion/ExprTranspose.monty:153:14-49
     raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation")
    _1[perm[_3]] += 1
   for _4 in range(0,int((_1).shape[0])):
    if ((_1[_4] < 1) or (_1[_4] > 1)): # src/fusion/ExprTranspose.monty:159:14-42
     raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation")
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2I(perm,expr,validated):
    o = ExprPermuteDims.__new__(ExprPermuteDims)
    o._ctor_init__3ILmosek_4fusion_4Expression_2I(perm,expr,validated)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 3: return False
    perm,expr,validated, = args
    return (__arg_match__3I__(perm) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 3: return False
    perm,expr,validated, = args
    return (__arg_alt_match__3I__(perm) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,validated):
    self._ctor_init__3ILmosek_4fusion_4Expression_2I(numpy.array(perm,dtype=numpy.dtype(numpy.int32)),expr,numpy.int32(validated))
  def _ctor_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,validated):
   assert perm is None or isinstance(perm,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprPermuteDims.__computeshape__3I_3I(perm,expr.getShape()))
   (self.__expr) = expr
   self.__dperm = mosek.fusion.Utils.Tools._arraycopy__3I(perm)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_1,_0,_2)
   _3=_1.popi32()
   _4=_1.popi32(_3)
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _5[(_3 - 1)] = 1
   for _6 in range(1,_3):
    _5[((_3 - _6) - 1)] = (_5[(_3 - _6)] * (_1.i32)[((_4 + _3) - _6)])
   _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _7[(_3 - 1)] = 1
   for _8 in range(1,_3):
    _7[((_3 - _8) - 1)] = (_7[(_3 - _8)] * (_1.i32)[(_4 + self.__dperm[(_3 - _8)])])
   _9=_1.popi32()
   _10=_1.popi32()
   _11=(_1.popi32()!=0)
   _12=_1.popi32((_9 + 1))
   _13=((- 1) if ((not _11) ) else _1.popi64(_9))
   _14=_1.popi64(_10)
   _15=_1.popf64(_9)
   _16=_1.popf64(_10)
   _17=(_1.i32)
   _18=(_1.i64)
   _19=(_1.f64)
   if _11: # src/fusion/ExprTranspose.monty:184:12-17
    _20=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    for _21 in range(0,_9):
     _22=0
     for _23 in range(0,_3):
      _22 += (((_18[(_13 + _21)] // _5[_23]) % _17[(_4 + _23)]) * _7[self.__dperm[_23]])
     _20[_21] = _22
    _24=numpy.array([_25 for _25 in range(0,_9)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_24,_20,None,0,_9)
    _26=_0.alloci32((_9 + 1))
    _27=_0.alloci64(_10)
    _28=_0.alloci64(_9)
    _29=_0.allocf64(_10)
    _30=_0.allocf64(_9)
    _0.pushi32(1)
    _0.pushi32(_10)
    _0.pushi32(_9)
    for _31 in range(0,_3):
     _0.pushi32(_17[(_4 + self.__dperm[_31])])
    _0.pushi32(_3)
    _32=(_0.i32)
    _33=(_0.i64)
    _34=(_0.f64)
    _32[_26] = 0
    _35=0
    _36=0
    for _37 in range(0,_9):
     _38=_24[_37]
     for _39 in range(_17[(_12 + _38)],_17[((_12 + _38) + 1)]):
      _33[(_27 + _36)] = _18[(_14 + _39)]
      _34[(_29 + _36)] = _19[(_16 + _39)]
      _36 += 1
     _33[(_28 + _37)] = _20[_38]
     _34[(_30 + _37)] = _19[(_15 + _38)]
     _35 += 1
     _32[((_26 + _37) + 1)] = _36
   else:
    _40=_0.alloci32((_9 + 1))
    _41=_0.alloci64(_10)
    _42=_0.allocf64(_10)
    _43=_0.allocf64(_9)
    _0.pushi32(0)
    _0.pushi32(_10)
    _0.pushi32(_9)
    for _44 in range(0,_3):
     _0.pushi32(_17[(_4 + self.__dperm[_44])])
    _0.pushi32(_3)
    _45=(_0.i32)
    _46=(_0.i64)
    _47=(_0.f64)
    _45[_40] = 0
    _48=0
    _49=0
    for _50 in range(0,_9):
     _51=0
     for _52 in range(0,_3):
      _51 += (((_50 // _5[self.__dperm[_52]]) % _17[(_4 + self.__dperm[_52])]) * _7[_52])
     for _53 in range(_17[(_12 + _51)],_17[((_12 + _51) + 1)]):
      _46[(_41 + _49)] = _18[(_14 + _53)]
      _47[(_42 + _49)] = _19[(_16 + _53)]
      _49 += 1
     _47[(_43 + _48)] = _19[(_15 + _51)]
     _48 += 1
     _45[(_40 + _48)] = _49
  @staticmethod
  def __computeshape_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprPermuteDims.__computeshape__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeshape__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (numpy.array([_1[_0[_2]] for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
 return ExprPermuteDims
mosek_fusion_ExprPermuteDims=__mk_mosek_fusion_ExprPermuteDims()
del __mk_mosek_fusion_ExprPermuteDims
#BEFORE CLASS
def __mk_mosek_fusion_ExprTranspose():
 class ExprTranspose(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprTranspose__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprTranspose.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprTranspose._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprTranspose._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprTranspose._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprTranspose._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprTranspose.eval()\n\tmosek.fusion.ExprTranspose.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprTranspose._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprTranspose._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprTranspose.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprTranspose: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprTranspose.__new__(ExprTranspose)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprTranspose.__transposeShape__3I(expr.getShape()))
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_1,_0,_2)
   _1.pop_expr()
   if ((_1.nd)!=2): # src/fusion/ExprTranspose.monty:27:12-22
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   else:
    _3=(_1.shape_base)
    _4=(_1.nelem)
    _5=(_1.nnz)
    _6=(_1.hassp)
    _7=(_1.ptr_base)
    _8=(_1.sp_base)
    _9=(_1.nidxs_base)
    _10=(_1.bfix_base)
    _11=(_1.cof_base)
    _12=(_1.i32)[_3]
    _13=(_1.i32)[(_3 + 1)]
    _14=(_1.i32)
    _15=(_1.i64)
    _16=(_1.f64)
    _0.alloc_expr(2,_4,_5,_6)
    _17=(_0.ptr_base)
    _18=(_0.nidxs_base)
    _19=(_0.sp_base)
    _20=(_0.cof_base)
    _21=(_0.bfix_base)
    _22=(_0.shape_base)
    _23=(_0.i32)
    _24=(_0.i64)
    _25=(_0.f64)
    _23[_22] = _13
    _23[(_22 + 1)] = _12
    if _6: # src/fusion/ExprTranspose.monty:63:14-19
     _26=_2.alloci32(_4)
     _27=_2.alloci32((_13 + 1))
     _28=(_2.i32)
     for _29 in range(0,(_13 + 1)):
      _28[(_27 + _29)] = 0
     for _30 in range(0,_4):
      _28[((_27 + (_15[(_8 + _30)] % _13)) + 1)] += 1
     for _31 in range(0,_13):
      _28[((_27 + _31) + 1)] += _28[(_27 + _31)]
     for _32 in range(0,_4):
      _33=(_15[(_8 + _32)] % _13)
      _28[(_26 + _28[(_27 + _33)])] = _32
      _28[(_27 + _33)] += 1
     _23[_17] = 0
     _34=0
     for _35 in range(0,_4):
      _36=_28[(_26 + _35)]
      for _37 in range(_14[(_7 + _36)],_14[((_7 + _36) + 1)]):
       _24[(_18 + _34)] = _15[(_9 + _37)]
       _25[(_20 + _34)] = _16[(_11 + _37)]
       _34 += 1
      _38=(_15[(_8 + _36)] // _13)
      _39=(_15[(_8 + _36)] % _13)
      _23[((_17 + _35) + 1)] = _34
      _24[(_19 + _35)] = ((_39 * _12) + _38)
      _25[(_21 + _35)] = _16[(_10 + _36)]
    else:
     _23[_17] = 0
     _40=0
     _41=0
     for _42 in range(0,_13):
      for _43 in range(0,_12):
       _44=((_43 * _13) + _42)
       for _45 in range(_14[(_7 + _44)],_14[((_7 + _44) + 1)]):
        _24[(_18 + _40)] = _15[(_9 + _45)]
        _25[(_20 + _40)] = _16[(_11 + _45)]
        _40 += 1
       _25[(_21 + _41)] = _16[(_10 + _44)]
       _23[((_17 + _41) + 1)] = _40
       _41 += 1
    _2.clear()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprTranspose(")._a_S(self.__expr.toString())._a_S(")")._toString_())
  @staticmethod
  def __transposeShape_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprTranspose.__transposeShape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __transposeShape__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])!=2): # src/fusion/ExprTranspose.monty:8:12-27
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   else:
    return (numpy.array([_0[1],_0[0]], dtype=numpy.dtype(numpy.int32)))
 return ExprTranspose
mosek_fusion_ExprTranspose=__mk_mosek_fusion_ExprTranspose()
del __mk_mosek_fusion_ExprTranspose
#BEFORE CLASS
def __mk_mosek_fusion_ExprStack():
 class ExprStack(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprStack__dim','_ExprStack__exprs']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Expression_2I(*args): # []mosek.fusion.Expression,int32
      self._ctor_init__3Lmosek_4fusion_4Expression_2I(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Expression_2I(*args):# []mosek.fusion.Expression,int32
      self._ctor_alt_init__3Lmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprStack.ctor(array(mosek.fusion.Expression,ndim=1),int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprStack._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprStack._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprStack._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprStack._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprStack.eval()\n\tmosek.fusion.ExprStack.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprStack._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprStack._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprStack.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprStack: '+self._toString_()
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Expression_2I(exprs,dim):
    o = ExprStack.__new__(ExprStack)
    o._ctor_init__3Lmosek_4fusion_4Expression_2I(exprs,dim)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    exprs,dim, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(exprs) and __arg_match_I__(dim))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    exprs,dim, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(exprs) and __arg_alt_match_I__(dim))
  def _ctor_alt_init__3Lmosek_4fusion_4Expression_2I(self,exprs,dim):
    self._ctor_init__3Lmosek_4fusion_4Expression_2I(numpy.array(exprs,dtype=numpy.dtype(object)),numpy.int32(dim))
  def _ctor_init__3Lmosek_4fusion_4Expression_2I(self,exprs,dim):
   assert exprs is None or isinstance(exprs,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprStack.__getshape__3Lmosek_4fusion_4Expression_2I(exprs,dim))
   (self.__exprs) = numpy.array([exprs[_0] for _0 in range(0,int((exprs).shape[0]))], dtype=numpy.dtype(object))
   (self.__dim) = dim
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__exprs).shape[0])
   if (_3==1): # src/fusion/ExprStack.monty:77:12-18
    self.__exprs[0].eval(_0,_1,_2)
   else:
    for _4 in range(0,_3):
     self.__exprs[((_3 - _4) - 1)].eval(_1,_0,_2)
    _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _9=numpy.zeros((_3,), dtype=numpy.dtype(numpy.bool))
    _10=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _11=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _12=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _13=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _14=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    for _15 in range(0,_3):
     _1.pop_expr()
     _5[_15] = (_1.nd)
     _6[_15] = (_1.shape_base)
     _7[_15] = (_1.nelem)
     _8[_15] = (_1.nnz)
     _9[_15] = (_1.hassp)
     _10[_15] = (_1.ptr_base)
     _12[_15] = (_1.sp_base)
     _11[_15] = (_1.nidxs_base)
     _14[_15] = (_1.bfix_base)
     _13[_15] = (_1.cof_base)
    _16=(_1.i32)
    _17=(_1.i64)
    _18=(_1.f64)
    _19=_5[0]
    _20=_6[0]
    _21=(not _9[0])
    _22=False
    for _23 in range(1,_3):
     _22 = (_22 or ((self.__dim!=_23) and (_5[_23]!=_19)))
     if (not _22): # src/fusion/ExprStack.monty:129:18-38
      for _24 in range(0,self.__dim):
       _22 = (_22 or (_16[(_20 + _24)]!=_16[(_6[_23] + _24)]))
     if (not _22): # src/fusion/ExprStack.monty:132:18-38
      for _25 in range((self.__dim + 1),_19):
       _22 = (_22 or (_16[(_20 + _25)]!=_16[(_6[_23] + _25)]))
     _21 = (_21 and (not _9[_23]))
    if _22: # src/fusion/ExprStack.monty:138:14-30
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression dimensions")
    _26=0
    if (self.__dim < _19): # src/fusion/ExprStack.monty:142:14-22
     for _27 in range(0,_3):
      _26 += _16[(_6[_27] + self.__dim)]
    else:
     _26 = _3
    _28=(_19 if ((self.__dim < _19) ) else (_19 + 1))
    if (_28!=self.getND()): # src/fusion/ExprStack.monty:147:14-28
     raise mosek_fusion_UnexpectedError._ctor_S("Oops!!")
    _29=0
    _30=0
    for _31 in range(0,_3):
     _30 += _8[_31]
    for _32 in range(0,_3):
     _29 += _7[_32]
    _33=1
    for _34 in range(0,self.__dim):
     _33 *= _16[(_20 + _34)]
    _35=(numpy.array([_16[(_6[_36] + self.__dim)] for _36 in range(0,_3)], dtype=numpy.dtype(numpy.int32)) if ((self.__dim < _19) ) else numpy.array([1 for _37 in range(0,_3)], dtype=numpy.dtype(numpy.int32)))
    _38=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _38[0] = 0
    for _39 in range(1,_3):
     _38[_39] = (_38[(_39 - 1)] + _35[(_39 - 1)])
    _40=0
    for _41 in range(0,_3):
     _40 += _35[_41]
    _42=1
    for _43 in range((self.__dim + 1),_19):
     _42 *= _16[(_20 + _43)]
    if _21: # src/fusion/ExprStack.monty:182:14-19
     _0.alloc_expr(_28,_29,_30,False)
     _44=(_0.ptr_base)
     _45=(_0.shape_base)
     _46=(_0.nidxs_base)
     _47=(_0.cof_base)
     _48=(_0.bfix_base)
     _49=(_0.i32)
     _50=(_0.i64)
     _51=(_0.f64)
     for _52 in range(0,_19):
      _49[(_45 + _52)] = _16[(_20 + _52)]
     _49[(_45 + self.__dim)] = _26
     _49[_44] = 0
     _53=0
     for _54 in range(0,_3):
      _55=_10[_54]
      _56=0
      for _57 in range(0,_33):
       for _58 in range(0,_35[_54]):
        for _59 in range(0,_42):
         _60=((_59 + ((_58 + _53) * _42)) + ((_57 * _40) * _42))
         _61=(_16[((_55 + _56) + 1)] - _16[(_55 + _56)])
         _49[((_44 + _60) + 1)] = _61
         _51[(_48 + _60)] = _18[(_14[_54] + _56)]
         _56 += 1
      _53 += _35[_54]
     for _62 in range(0,_29):
      _49[((_44 + _62) + 1)] += _49[(_44 + _62)]
     _63=0
     for _64 in range(0,_3):
      _65=_10[_64]
      _66=0
      for _67 in range(0,_33):
       for _68 in range(0,_35[_64]):
        for _69 in range(0,_42):
         _70=((_69 + ((_68 + _63) * _42)) + ((_67 * _40) * _42))
         _71=_16[(_65 + _66)]
         _72=(_16[((_65 + _66) + 1)] - _71)
         for _73 in range(0,_72):
          _50[((_46 + _49[(_44 + _70)]) + _73)] = _17[((_11[_64] + _71) + _73)]
         for _74 in range(0,_72):
          _51[((_47 + _49[(_44 + _70)]) + _74)] = _18[((_13[_64] + _71) + _74)]
         _66 += 1
      _63 += _35[_64]
    else:
     _75=1
     for _76 in range(0,self.__dim):
      _75 *= _16[(_20 + _76)]
     _75 *= _26
     for _77 in range((self.__dim + 1),_19):
      _75 *= _16[(_20 + _77)]
     _78=(_29 < _75)
     _0.alloc_expr(_28,_29,_30,_78)
     _79=(_0.ptr_base)
     _80=(_0.nidxs_base)
     _81=((_0.sp_base) if (_78 ) else _0.alloci64(_29))
     _82=(_0.cof_base)
     _83=(_0.bfix_base)
     _84=(_0.shape_base)
     for _85 in range(0,_19):
      (_0.i32)[(_84 + _85)] = _16[(_20 + _85)]
     (_0.i32)[(_84 + self.__dim)] = _26
     _86=_2.alloci32((_29 + 1))
     _87=_2.alloci64(_30)
     _88=_2.alloci64(_29)
     _89=_2.allocf64(_30)
     _90=_2.allocf64(_29)
     _91=(_0.i32)
     _92=(_0.i64)
     _93=(_0.f64)
     _94=(_2.i32)
     _95=(_2.i64)
     _96=(_2.f64)
     _97=0
     _98=0
     for _99 in range(0,_3):
      mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_17,_11[_99],_95,(_87 + _98),_8[_99])
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_18,_13[_99],_96,(_89 + _98),_8[_99])
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_18,_14[_99],_96,(_90 + _97),_7[_99])
      _98 += _8[_99]
      _97 += _7[_99]
     _94[_86] = 0
     _100=0
     _101=0
     for _102 in range(0,_3):
      _103=_35[_102]
      _104=(_103 * _42)
      _105=_42
      if _9[_102]: # src/fusion/ExprStack.monty:316:20-28
       for _106 in range(0,_7[_102]):
        _107=(_17[(_12[_102] + _106)] // _104)
        _108=((_17[(_12[_102] + _106)] // _105) % _103)
        _109=(_17[(_12[_102] + _106)] % _42)
        _95[(_88 + _101)] = (((((_107 * _26) + _108) + _38[_102]) * _42) + _109)
        _94[((_86 + _101) + 1)] = (_100 + _16[((_10[_102] + _106) + 1)])
        _101 += 1
      else:
       _110=0
       for _111 in range(0,_33):
        for _112 in range(0,_103):
         for _113 in range(0,_42):
          _95[(_88 + _101)] = (((((_111 * _26) + _112) + _38[_102]) * _42) + _113)
          _94[((_86 + _101) + 1)] = (_100 + _16[((_10[_102] + _110) + 1)])
          _101 += 1
          _110 += 1
      _100 += _8[_102]
     if (self.__dim > 0): # src/fusion/ExprStack.monty:344:16-23
      _114=0
      for _115 in range(0,_28):
       if (_114 < _91[(_84 + _115)]): # src/fusion/ExprStack.monty:346:55-83
        _114 = _91[(_84 + _115)]
      _116=numpy.zeros((_28,), dtype=numpy.dtype(numpy.int64))
      _116[(_28 - 1)] = 1
      for _117 in range(1,_28):
       _116[((_28 - _117) - 1)] = (_116[(_28 - _117)] * _91[((_84 + _28) - _117)])
      _118=_2.alloci32(_29)
      _119=_2.alloci32(_29)
      _120=_2.alloci32((_114 + 1))
      _121=(_2.i32)
      _122=(_2.i64)
      _123=(_2.f64)
      for _124 in range(0,_29):
       _121[(_118 + _124)] = _124
      for _125 in range(0,_28):
       _126=((_28 - _125) - 1)
       _127=_91[(_84 + _126)]
       for _128 in range(0,(_127 + 1)):
        _121[(_120 + _128)] = 0
       for _129 in range(0,_29):
        _130=_121[(_118 + _129)]
        _131=((_122[(_88 + _130)] // _116[_126]) % _127)
        _121[((_120 + _131) + 1)] += 1
       for _132 in range(0,_127):
        _121[((_120 + _132) + 1)] += _121[(_120 + _132)]
       for _133 in range(0,_29):
        _134=_121[(_118 + _133)]
        _135=((_122[(_88 + _134)] // _116[_126]) % _127)
        _121[(_119 + _121[(_120 + _135)])] = _134
        _121[(_120 + _135)] += 1
       _136=_118
       _118 = _119
       _119 = _136
      _137=0
      _91[_79] = 0
      for _138 in range(0,_29):
       _139=_121[(_118 + _138)]
       _140=_121[(_86 + _139)]
       _141=_121[((_86 + _139) + 1)]
       _142=(_141 - _140)
       _91[((_79 + _138) + 1)] = (_91[(_79 + _138)] + _142)
       _93[(_83 + _138)] = _123[(_90 + _139)]
       _92[(_81 + _138)] = _122[(_88 + _139)]
       for _143 in range(_140,_141):
        _92[(_80 + _137)] = _122[(_87 + _143)]
        _93[(_82 + _137)] = _123[(_89 + _143)]
        _137 += 1
     else:
      _144=0
      _91[_79] = 0
      for _145 in range(0,_29):
       _146=_94[(_86 + _145)]
       _147=_94[((_86 + _145) + 1)]
       _148=(_147 - _146)
       _91[((_79 + _145) + 1)] = (_91[(_79 + _145)] + _148)
       _93[(_83 + _145)] = _96[(_90 + _145)]
       _92[(_81 + _145)] = _95[(_88 + _145)]
       for _149 in range(_146,_147):
        _92[(_80 + _144)] = _95[(_87 + _149)]
        _93[(_82 + _144)] = _96[(_89 + _149)]
        _144 += 1
     if (not _78): # src/fusion/ExprStack.monty:427:16-26
      _0.popi64(_29)
     _2.clear()
  @staticmethod
  def __getshape_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprStack.__getshape__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __getshape__3Lmosek_4fusion_4Expression_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])==0): # src/fusion/ExprStack.monty:17:12-24
    raise mosek_fusion_LengthError._ctor_S("Cannot stack empty list")
   elif (int((_0).shape[0])==1): # src/fusion/ExprStack.monty:19:16-28
    return (_0[0].getShape())
   else:
    _2=_monty.initJaggedArray([_0[_3].getShape() for _3 in range(0,int((_0).shape[0]))], 1)
    _4=_2[0]
    _5=int((_4).shape[0])
    for _6 in range(1,int((_2).shape[0])):
     if (_5!=int((_2[_6]).shape[0])): # src/fusion/ExprStack.monty:26:16-36
      raise mosek_fusion_DimensionError._ctor_S("Mismatching expression dimensions")
     for _7 in range(0,_1):
      if (_4[_7]!=_2[_6][_7]): # src/fusion/ExprStack.monty:29:18-42
       raise mosek_fusion_DimensionError._ctor_S("mismatching expression dimensions")
     for _8 in range((_1 + 1),_5):
      if (_4[_8]!=_2[_6][_8]): # src/fusion/ExprStack.monty:32:18-42
       raise mosek_fusion_DimensionError._ctor_S("mismatching expression dimensions")
    if (_1==_5): # src/fusion/ExprStack.monty:35:14-23
     _9=numpy.zeros(((_5 + 1),), dtype=numpy.dtype(numpy.int32))
     for _10 in range(0,_5):
      _9[_10] = _4[_10]
     _9[_5] = int((_2).shape[0])
     return (_9)
    else:
     _11=_4
     for _12 in range(1,int((_2).shape[0])):
      _11[_1] += _2[_12][_1]
     return (_11)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprStack(dim=")._a_I(self.__dim)._a_S(",[")._a_S(self.__exprs[0].toString())
   for _1 in range(1,int((self.__exprs).shape[0])):
    _0._a_S(",")._a_S(self.__exprs[_1].toString())
   _0._a_S("])")
   return (_0._toString_())
 return ExprStack
mosek_fusion_ExprStack=__mk_mosek_fusion_ExprStack()
del __mk_mosek_fusion_ExprStack
#BEFORE CLASS
def __mk_mosek_fusion_ExprInner():
 class ExprInner(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprInner__vcof','_ExprInner__vsub','_ExprInner__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      self._ctor_init_Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3D(*args):# mosek.fusion.Expression,[]double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args): # mosek.fusion.Expression,[]int64,[]double
      self._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):# mosek.fusion.Expression,[]int64,[]double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3J_3D(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args): # mosek.fusion.Expression,[,]int32,[]double
      self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):# mosek.fusion.Expression,[,]int32,[]double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(int32,ndim=2),array(double,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprInner._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprInner._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprInner._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprInner._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprInner.eval()\n\tmosek.fusion.ExprInner.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprInner._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprInner._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprInner.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprInner: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3J_3D(expr,vsub,vcof):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(expr,vsub,vcof)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):
    if len(args) != 3: return False
    expr,vsub,vcof, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3J__(vsub) and __arg_match__3D__(vcof))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):
    if len(args) != 3: return False
    expr,vsub,vcof, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3J__(vsub) and __arg_alt_match__3D__(vcof))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr,vsub,vcof):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(expr,numpy.array(vsub,dtype=numpy.dtype(numpy.int64)),numpy.array(vcof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr,vsub,vcof):
   assert vsub is None or isinstance(vsub,numpy.ndarray)
   assert vcof is None or isinstance(vcof,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   (self.__expr) = expr
   (self.__vsub) = vsub
   (self.__vcof) = vcof
   if (int((vsub).shape[0])!=int((vcof).shape[0])): # src/fusion/ExprMul.monty:1926:12-34
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of vcof and vsub")
   _0=expr.getShape()
   _1=mosek.fusion.Set._size__3I(_0)
   _2=False
   _3=False
   for _4 in range(1,int((vsub).shape[0])):
    if (vsub[_4] <= vsub[(_4 - 1)]): # src/fusion/ExprMul.monty:1936:16-36
     _2 = True
   if (int((vsub).shape[0]) > 0): # src/fusion/ExprMul.monty:1939:14-27
    if ((vsub[0] < 0) or (vsub[(int((vsub).shape[0]) - 1)] > _1)): # src/fusion/ExprMul.monty:1940:16-55
     _3 = True
   if _2: # src/fusion/ExprMul.monty:1943:12-22
    raise mosek_fusion_IndexError._ctor_S("Unordered coefficcient subscripts")
   if _3: # src/fusion/ExprMul.monty:1945:12-22
    raise mosek_fusion_IndexError._ctor_S("Coefficient subscript out of bounds")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3D(expr,vcof):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3D(expr,vcof)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    expr,vcof, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3D__(vcof))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    expr,vcof, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3D__(vcof))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3D(self,expr,vcof):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3D(expr,numpy.array(vcof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3D(self,expr,vcof):
   assert vcof is None or isinstance(vcof,numpy.ndarray)
   mosek_fusion_ExprInner._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr,mosek.fusion.ExprInner.__range_I(int((vcof).shape[0])),vcof)
   _0=expr.getShape()
   if ((int((_0).shape[0])!=1) or (_0[0]!=int((vcof).shape[0]))): # src/fusion/ExprMul.monty:1914:12-54
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(expr,vsub,vcof):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(expr,vsub,vcof)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):
    if len(args) != 3: return False
    expr,vsub,vcof, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3_5I__(vsub) and __arg_match__3D__(vcof))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):
    if len(args) != 3: return False
    expr,vsub,vcof, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3_5I__(vsub) and __arg_alt_match__3D__(vcof))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I_3D(self,expr,vsub,vcof):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(expr,numpy.array(vsub,dtype=numpy.dtype(numpy.int32)),numpy.array(vcof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(self,expr,vsub,vcof):
   assert vsub is None or isinstance(vsub,numpy.ndarray)
   assert vcof is None or isinstance(vcof,numpy.ndarray)
   mosek_fusion_ExprInner._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr,mosek.fusion.ExprInner.__convert__3I_3_5I(expr.getShape(),vsub),vcof)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_1,_0,_2)
   _3=_1.popi32()
   _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _1.popi32(_3,_4,0)
   _5=_1.popi32()
   _6=_1.popi32()
   _7=(_1.popi32()!=0)
   _8=_1.popi32((_5 + 1))
   _9=(_1.popi64(_5) if (_7 ) else 0)
   _10=_1.popi64(_6)
   _11=_1.popf64(_5)
   _12=_1.popf64(_6)
   _13=(_1.i32)
   _14=(_1.i64)
   _15=(_1.f64)
   _16=0
   if _7: # src/fusion/ExprMul.monty:1970:12-17
    _17=0
    _18=0
    while ((_18 < int((self.__vsub).shape[0])) and (_17 < _5)):
     if (_14[(_9 + _17)] < self.__vsub[_18]): # src/fusion/ExprMul.monty:1973:16-43
      _17 += 1
     elif (_14[(_9 + _17)] > self.__vsub[_18]): # src/fusion/ExprMul.monty:1975:20-47
      _18 += 1
     else:
      _16 += (_13[((_8 + _17) + 1)] - _13[(_8 + _17)])
      _18 += 1
      _17 += 1
   else:
    for _19 in range(0,int((self.__vsub).shape[0])):
     _16 += (_13[((_8 + self.__vsub[_19]) + 1)] - _13[(_8 + self.__vsub[_19])])
   _20=_0.alloci32(2)
   _21=_0.alloci64(_16)
   _22=_0.allocf64(_16)
   _23=_0.allocf64(1)
   _0.pushi32(0)
   _0.pushi32(_16)
   _0.pushi32(1)
   _0.pushi32(0)
   _24=(_0.i32)
   _25=(_0.i64)
   _26=(_0.f64)
   _24[_20] = 0
   _24[(_20 + 1)] = _16
   _27=0
   _28=0.0
   if _7: # src/fusion/ExprMul.monty:2010:12-17
    _29=0
    _30=0
    while ((_30 < int((self.__vsub).shape[0])) and (_29 < _5)):
     if (_14[(_9 + _29)] < self.__vsub[_30]): # src/fusion/ExprMul.monty:2013:16-43
      _29 += 1
     elif (_14[(_9 + _29)] > self.__vsub[_30]): # src/fusion/ExprMul.monty:2015:20-47
      _30 += 1
     else:
      _31=_13[(_8 + _29)]
      _32=_13[((_8 + _29) + 1)]
      for _33 in range(_31,_32):
       _25[(_21 + _27)] = _14[(_10 + _33)]
       _26[(_22 + _27)] = (self.__vcof[_30] * _15[(_12 + _33)])
       _27 += 1
      _28 += (self.__vcof[_30] * _15[(_11 + _29)])
      _30 += 1
      _29 += 1
   else:
    for _34 in range(0,int((self.__vsub).shape[0])):
     _35=_13[(_8 + self.__vsub[_34])]
     _36=_13[((_8 + self.__vsub[_34]) + 1)]
     for _37 in range(_35,_36):
      _25[(_21 + _27)] = _14[(_10 + _37)]
      _26[(_22 + _27)] = (self.__vcof[_34] * _15[(_12 + _37)])
      _27 += 1
     _28 += (self.__vcof[_34] * _15[(_11 + self.__vsub[_34])])
   _26[_23] = _28
  @staticmethod
  def __range_alt_I(_t__0):
    return mosek_fusion_ExprInner.__range_I(numpy.int32(__0))
  @staticmethod
  def __range_I(_0):
   return (numpy.array([_1 for _1 in range(0,_0)], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def __convert_alt__3I_3_5I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprInner.__convert__3I_3_5I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __convert__3I_3_5I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=int((_0).shape[0])
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   _3[(_2 - 1)] = 1
   for _4 in range(1,_2):
    _3[((_2 - _4) - 1)] = (_3[(_2 - _4)] * _0[(_2 - _4)])
   _5=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
   for _6 in range(0,int((_1).shape[0])):
    for _7 in range(0,_2):
     _5[_6] += (_3[_7] * _1[_6,_7])
   return (_5)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprInner()")
 return ExprInner
mosek_fusion_ExprInner=__mk_mosek_fusion_ExprInner()
del __mk_mosek_fusion_ExprInner
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulDiagRight():
 class ExprMulDiagRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulDiagRight__expr','_ExprMulDiagRight__mval','_ExprMulDiagRight__msubj','_ExprMulDiagRight__msubi','_ExprMulDiagRight__mdim1','_ExprMulDiagRight__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulDiagRight.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagRight._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprMulDiagRight._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprMulDiagRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulDiagRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagRight.eval()\n\tmosek.fusion.ExprMulDiagRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagRight._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulDiagRight._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagRight.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprMulDiagRight: '+self._toString_()
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulDiagRight.__new__(ExprMulDiagRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdim1], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulDiagRight.__new__(ExprMulDiagRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_ExprMulDiagRight._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulDiagRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr).eval(_1,_0,_2)
   _3=0
   _4=99999
   _5=0
   _6=(_1.peeki32(5)!=0)
   if _6: # src/fusion/ExprMul.monty:1675:12-18
    _5 = _1.peeki32(2)
    _4 = _1.alloci32((_5 + 1))
    _3 += (_5 + 1)
   _7=int((self.__mval).shape[0])
   _8=_1.alloci32(_7)
   _9=_1.alloci32((self.__mdim1 + 1))
   _3 += ((_7 + self.__mdim1) + 1)
   _10=(_1.i32)
   _11=(self.__msubj)
   for _12 in range(0,(self.__mdim1 + 1)):
    _10[(_9 + _12)] = 0
   for _13 in range(0,_7):
    _10[((_9 + _11[_13]) + 1)] += 1
   for _14 in range(0,self.__mdim1):
    _10[((_9 + _14) + 1)] += _10[(_9 + _14)]
   for _15 in range(0,_7):
    _10[(_8 + _10[(_9 + _11[_15])])] = _15
    _10[(_9 + _11[_15])] += 1
   for _16 in range(0,self.__mdim1):
    _10[((_9 + self.__mdim1) - _16)] = _10[(((_9 + self.__mdim1) - _16) - 1)]
   _10[_9] = 0
   _1.popi32(_3)
   _17=_1.popi32()
   if (_17!=2): # src/fusion/ExprMul.monty:1701:12-22
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _18=_1.popi32()
   _19=_1.popi32()
   _20=_1.popi32()
   _21=_1.popi32()
   _22=(_1.popi32()!=0)
   _23=_1.popi32((_20 + 1))
   _24=(_1.popi64(_20) if (_22 ) else 9999)
   _25=_1.popi64(_21)
   _26=_1.popf64(_20)
   _27=_1.popf64(_21)
   _28=(_1.i32)
   _29=(_1.i64)
   _30=(_1.f64)
   if _22: # src/fusion/ExprMul.monty:1720:12-18
    for _31 in range(0,(_19 + 1)):
     _28[(_4 + _31)] = 0
    for _32 in range(0,_20):
     _28[((_4 + (_29[(_24 + _32)] // _18)) + 1)] += 1
    for _33 in range(0,_19):
     _28[((_4 + _33) + 1)] += _28[(_4 + _33)]
    _34=(self.__msubi)
    _35=(self.__mval)
    _36=0
    _37=0
    for _38 in range(0,_19):
     _39=_28[((_9 + _38) + 1)]
     _40=_28[(_9 + _38)]
     _41=_28[((_4 + _38) + 1)]
     _42=_28[(_4 + _38)]
     _43=False
     while ((_42 < _41) and (_40 < _39)):
      _44=_28[(_8 + _40)]
      _45=(_29[(_24 + _42)] % _18)
      if (_34[_44] < _45): # src/fusion/ExprMul.monty:1739:24-42
       _40 += 1
      elif (_34[_44] > _45): # src/fusion/ExprMul.monty:1741:24-42
       _42 += 1
      else:
       _43 = True
       _36 += (_28[((_23 + _42) + 1)] - _28[(_23 + _42)])
       _42 += 1
       _40 += 1
     if _43: # src/fusion/ExprMul.monty:1749:18-24
      _37 += 1
    _46=(_37 < _19)
    _47=_0.alloci32((_37 + 1))
    _48=_0.alloci64(_36)
    _49=_0.alloci64(_37)
    _50=_0.allocf64(_36)
    _51=_0.allocf64(_37)
    _0.pushi32((1 if (_46 ) else 0))
    _0.pushi32(_36)
    _0.pushi32(_37)
    _0.pushi32(_19)
    _0.pushi32(1)
    _52=(_0.i32)
    _53=(_0.i64)
    _54=(_0.f64)
    _55=0
    _56=0
    _52[_47] = 0
    for _57 in range(0,_19):
     _58=_28[((_9 + _57) + 1)]
     _59=_28[(_9 + _57)]
     _60=_28[((_4 + _57) + 1)]
     _61=_28[(_4 + _57)]
     _62=False
     _63=0.0
     while ((_61 < _60) and (_59 < _58)):
      _64=_28[(_8 + _59)]
      _65=(_29[(_24 + _61)] % _18)
      if (_34[_64] < _65): # src/fusion/ExprMul.monty:1784:24-42
       _59 += 1
      elif (_34[_64] > _65): # src/fusion/ExprMul.monty:1786:24-42
       _61 += 1
      else:
       _62 = True
       for _66 in range(_28[(_23 + _61)],_28[((_23 + _61) + 1)]):
        _53[(_48 + _56)] = _29[(_25 + _66)]
        _54[(_50 + _56)] = (_30[(_27 + _66)] * _35[_64])
        _56 += 1
       _63 += (_30[(_26 + _61)] * _35[_64])
       _61 += 1
       _59 += 1
     if _62: # src/fusion/ExprMul.monty:1799:18-24
      _52[((_47 + _55) + 1)] = _56
      _53[(_49 + _55)] = _57
      _54[(_51 + _55)] = _63
      _55 += 1
    if (not _46): # src/fusion/ExprMul.monty:1807:14-24
     _0.popi64(_37)
   else:
    _67=(self.__msubi)
    _68=(self.__mval)
    _69=0
    _70=0
    for _71 in range(0,_19):
     _72=False
     for _73 in range(_28[(_9 + _71)],_28[((_9 + _71) + 1)]):
      _74=_28[(_8 + _73)]
      _75=((_71 * _18) + _67[_74])
      _70 += (_28[((_23 + _75) + 1)] - _28[(_23 + _75)])
      if (_28[((_23 + _75) + 1)] > _28[(_23 + _75)]): # src/fusion/ExprMul.monty:1824:20-53
       _72 = True
     if _72: # src/fusion/ExprMul.monty:1827:18-24
      _69 += 1
    _76=(_69 < _19)
    _77=_0.alloci32((_69 + 1))
    _78=_0.alloci64(_70)
    _79=_0.alloci64(_69)
    _80=_0.allocf64(_70)
    _81=_0.allocf64(_69)
    _0.pushi32((1 if (_76 ) else 0))
    _0.pushi32(_70)
    _0.pushi32(_69)
    _0.pushi32(_19)
    _0.pushi32(1)
    _82=(_0.i32)
    _83=(_0.i64)
    _84=(_0.f64)
    _85=0
    _86=0
    _82[_77] = 0
    for _87 in range(0,_19):
     _88=False
     _89=0.0
     for _90 in range(_28[(_9 + _87)],_28[((_9 + _87) + 1)]):
      _91=_28[(_8 + _90)]
      _92=((_87 * _18) + _67[_91])
      for _93 in range(_28[(_23 + _92)],_28[((_23 + _92) + 1)]):
       _88 = True
       _83[(_78 + _86)] = _29[(_25 + _93)]
       _84[(_80 + _86)] = (_30[(_27 + _93)] * _68[_91])
       _86 += 1
      _89 += (_30[(_26 + _92)] * _68[_91])
     if _88: # src/fusion/ExprMul.monty:1870:18-24
      _84[(_81 + _85)] = _89
      _83[(_79 + _85)] = _87
      _82[((_77 + _85) + 1)] = _86
      _85 += 1
    if (not _76): # src/fusion/ExprMul.monty:1878:14-24
     _0.popi64(_69)
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulDiagRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=_5.getShape()
   if (int((_6).shape[0]) > 2): # src/fusion/ExprMul.monty:1586:12-27
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _7=_6[0]
   _8=_6[1]
   if ((_0 < 0) or ((_1 < 0) or ((_7 < 0) or (_8 < 0)))): # src/fusion/ExprMul.monty:1592:12-60
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_0!=_8) or (_1!=_7)): # src/fusion/ExprMul.monty:1594:12-44
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:1596:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _9=int((_2).shape[0])
   _10=False
   _11=False
   for _12 in range(0,_9):
    if ((_2[_12] < 0) or ((_2[_12] >= _0) or ((_3[_12] < 0) or (_3[_12] >= _1)))): # src/fusion/ExprMul.monty:1605:17-1606:50
     _10 = True
   for _13 in range(0,(_9 - 1)):
    if ((_2[_13] > _2[(_13 + 1)]) or ((_2[_13]==_2[(_13 + 1)]) and (_3[_13] >= _3[(_13 + 1)]))): # src/fusion/ExprMul.monty:1610:17-1611:68
     _11 = True
   if _10: # src/fusion/ExprMul.monty:1614:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _11: # src/fusion/ExprMul.monty:1616:12-22
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulDiagRight()")
 return ExprMulDiagRight
mosek_fusion_ExprMulDiagRight=__mk_mosek_fusion_ExprMulDiagRight()
del __mk_mosek_fusion_ExprMulDiagRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulDiagLeft():
 class ExprMulDiagLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulDiagLeft__expr','_ExprMulDiagLeft__mval','_ExprMulDiagLeft__msubj','_ExprMulDiagLeft__msubi','_ExprMulDiagLeft__mdim1','_ExprMulDiagLeft__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulDiagLeft.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagLeft._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprMulDiagLeft._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprMulDiagLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulDiagLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagLeft.eval()\n\tmosek.fusion.ExprMulDiagLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagLeft._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulDiagLeft._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagLeft.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprMulDiagLeft: '+self._toString_()
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulDiagLeft.__new__(ExprMulDiagLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdim0], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulDiagLeft.__new__(ExprMulDiagLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_ExprMulDiagLeft._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulDiagLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr).eval(_1,_0,_2)
   if (_1.peeki32()!=2): # src/fusion/ExprMul.monty:1351:12-29
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _3=int((self.__msubi).shape[0])
   _4=9999
   _5=9999
   _6=0
   _7=_1.peeki32(5)
   if (_7!=0): # src/fusion/ExprMul.monty:1362:12-23
    _8=_1.peeki32(1)
    _9=_1.peeki32(3)
    _4 = _1.alloci32((_8 + 1))
    _5 = _1.alloci32(_9)
    _6 += ((_9 + _8) + 1)
   _10=_1.alloci32((self.__mdim0 + 1))
   _6 += (self.__mdim0 + 1)
   _1.popi32(_6)
   _11=(_1.i32)
   _12=(_1.i64)
   _13=(_1.f64)
   for _14 in range(0,(self.__mdim0 + 1)):
    _11[(_10 + _14)] = 0
   for _15 in range(0,_3):
    _11[((_10 + self.__msubi[_15]) + 1)] += 1
   for _16 in range(0,self.__mdim0):
    _11[((_10 + _16) + 1)] += _11[(_10 + _16)]
   _17=_1.popi32()
   _18=_1.popi32()
   _19=_1.popi32()
   _20=_1.popi32()
   _21=_1.popi32()
   _22=(_1.popi32()!=0)
   _23=_1.popi32((_20 + 1))
   _24=(_1.popi64(_20) if (_22 ) else 9999)
   _25=_1.popi64(_21)
   _26=_1.popf64(_20)
   _27=_1.popf64(_21)
   if (not _22): # src/fusion/ExprMul.monty:1397:12-22
    _28=int((self.__msubi).shape[0])
    _29=0
    for _30 in range(0,self.__mdim0):
     if (_11[(_10 + _30)] < _11[((_10 + _30) + 1)]): # src/fusion/ExprMul.monty:1401:16-45
      _29 += 1
    _31=(_29 < self.__mdim0)
    _0.alloc_expr(1,_29,_28,_31)
    _32=(_0.ptr_base)
    _33=(_0.nidxs_base)
    _34=((_0.sp_base) if (_31 ) else _0.alloci64(_29))
    _35=(_0.cof_base)
    _36=(_0.bfix_base)
    (_0.i32)[(_0.shape_base)] = self.__mdim0
    _37=(_0.i32)
    _38=(_0.i64)
    _39=(_0.f64)
    _37[_32] = 0
    _40=0
    _41=0
    for _42 in range(0,self.__mdim0):
     if (_11[(_10 + _42)] < _11[((_10 + _42) + 1)]): # src/fusion/ExprMul.monty:1423:18-47
      _43=0
      for _44 in range(_11[(_10 + _42)],_11[((_10 + _42) + 1)]):
       _45=self.__msubj[_44]
       _46=((_45 * _18) + _42)
       for _47 in range(_11[(_23 + _46)],_11[((_23 + _46) + 1)]):
        _38[(_33 + _41)] = _12[(_25 + _47)]
        _39[(_35 + _41)] = (_13[(_27 + _47)] * self.__mval[_44])
        _41 += 1
      _39[(_36 + _40)] = _43
      _38[(_34 + _40)] = _42
      _37[((_32 + _40) + 1)] = _41
      _40 += 1
    if (not _31): # src/fusion/ExprMul.monty:1444:14-24
     _0.popi64(_29)
   else:
    for _48 in range(0,(_18 + 1)):
     _11[(_4 + _48)] = 0
    for _49 in range(0,_20):
     _11[((_4 + (_12[(_24 + _49)] % _18)) + 1)] += 1
    for _50 in range(0,_18):
     _11[((_4 + _50) + 1)] += _11[(_4 + _50)]
    for _51 in range(0,_20):
     _52=(_12[(_24 + _51)] % _18)
     _11[(_5 + _11[(_4 + _52)])] = _51
     _11[(_4 + _52)] += 1
    for _53 in range(0,_18):
     _11[((_4 + _18) - _53)] = _11[(((_4 + _18) - _53) - 1)]
    _11[_4] = 0
    _54=0
    _55=0
    for _56 in range(0,self.__mdim0):
     _57=_11[((_4 + _56) + 1)]
     _58=_11[(_4 + _56)]
     _59=_11[((_10 + _56) + 1)]
     _60=_11[(_10 + _56)]
     _61=False
     while ((_60 < _59) and (_58 < _57)):
      _62=_11[(_5 + _58)]
      _63=(_12[(_24 + _62)] // _18)
      if (self.__msubj[_60] < _63): # src/fusion/ExprMul.monty:1472:24-41
       _60 += 1
      elif (self.__msubj[_60] > _63): # src/fusion/ExprMul.monty:1474:24-41
       _58 += 1
      else:
       _61 = True
       _55 += (_11[((_23 + _62) + 1)] - _11[(_23 + _62)])
       _60 += 1
       _58 += 1
     if _61: # src/fusion/ExprMul.monty:1482:18-24
      _54 += 1
    _64=_54
    _65=_55
    _66=(_64 < self.__mdim0)
    _67=_0.alloci32((_64 + 1))
    _68=_0.alloci64(_65)
    _69=_0.alloci64(_64)
    _70=_0.allocf64(_65)
    _71=_0.allocf64(_64)
    _0.pushi32((1 if (_66 ) else 0))
    _0.pushi32(_65)
    _0.pushi32(_64)
    _0.pushi32(self.__mdim0)
    _0.pushi32(1)
    _72=(_0.i32)
    _73=(_0.i64)
    _74=(_0.f64)
    _72[_67] = 0
    _75=0
    _76=0
    for _77 in range(0,self.__mdim0):
     _78=_11[((_4 + _77) + 1)]
     _79=_11[(_4 + _77)]
     _80=_11[((_10 + _77) + 1)]
     _81=_11[(_10 + _77)]
     _82=False
     _83=0.0
     while ((_81 < _80) and (_79 < _78)):
      _84=_11[(_5 + _79)]
      _85=(_12[(_24 + _84)] // _18)
      if (self.__msubj[_81] < _85): # src/fusion/ExprMul.monty:1519:20-37
       _81 += 1
      elif (self.__msubj[_81] > _85): # src/fusion/ExprMul.monty:1521:24-41
       _79 += 1
      else:
       _82 = True
       for _86 in range(_11[(_23 + _84)],_11[((_23 + _84) + 1)]):
        _73[(_68 + _76)] = _12[(_25 + _86)]
        _74[(_70 + _76)] = (_13[(_27 + _86)] * self.__mval[_81])
        _76 += 1
       _83 += _13[(_26 + _84)]
       _81 += 1
       _79 += 1
     if _82: # src/fusion/ExprMul.monty:1534:18-24
      _73[(_69 + _75)] = _77
      _74[(_71 + _75)] = (_83 * self.__mval[_81])
      _72[((_67 + _75) + 1)] = _76
      _75 += 1
    if (not _66): # src/fusion/ExprMul.monty:1543:14-24
     _0.popi64(_64)
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulDiagLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=_5.getShape()
   if (int((_6).shape[0])!=2): # src/fusion/ExprMul.monty:1264:12-28
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _7=_6[0]
   _8=_6[1]
   if ((_0 < 0) or (_1 < 0)): # src/fusion/ExprMul.monty:1270:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_1!=_7) or (_0!=_8)): # src/fusion/ExprMul.monty:1272:12-44
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:1274:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _9=int((_2).shape[0])
   _10=False
   _11=False
   for _12 in range(0,_9):
    if ((_2[_12] < 0) or ((_2[_12] >= _0) or ((_3[_12] < 0) or (_3[_12] >= _1)))): # src/fusion/ExprMul.monty:1283:17-1284:50
     _10 = True
   for _13 in range(0,(_9 - 1)):
    if ((_2[_13] > _2[(_13 + 1)]) or ((_2[_13]==_2[(_13 + 1)]) and (_3[_13] >= _3[(_13 + 1)]))): # src/fusion/ExprMul.monty:1288:17-1289:67
     _11 = True
   if _10: # src/fusion/ExprMul.monty:1292:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _11: # src/fusion/ExprMul.monty:1294:12-22
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulDiagLeft()")
 return ExprMulDiagLeft
mosek_fusion_ExprMulDiagLeft=__mk_mosek_fusion_ExprMulDiagLeft()
del __mk_mosek_fusion_ExprMulDiagLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulElement():
 class ExprMulElement(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulElement__expr','_ExprMulElement__msp','_ExprMulElement__mcof']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3D_3JLmosek_4fusion_4Expression_2(*args): # []double,[]int64,mosek.fusion.Expression
      self._ctor_init__3D_3JLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):# []double,[]int64,mosek.fusion.Expression
      self._ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulElement.ctor(array(double,ndim=1),array(int64,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulElement._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprMulElement._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprMulElement._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulElement._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulElement.eval()\n\tmosek.fusion.ExprMulElement.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulElement._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulElement._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulElement.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprMulElement: '+self._toString_()
  @staticmethod
  def _ctor__3D_3JLmosek_4fusion_4Expression_2(mcof,msp,expr):
    o = ExprMulElement.__new__(ExprMulElement)
    o._ctor_init__3D_3JLmosek_4fusion_4Expression_2(mcof,msp,expr)
    return o
  @staticmethod
  def __match_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    mcof,msp,expr, = args
    return (__arg_match__3D__(mcof) and __arg_match__3J__(msp) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    mcof,msp,expr, = args
    return (__arg_alt_match__3D__(mcof) and __arg_alt_match__3J__(msp) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2(self,mcof,msp,expr):
    self._ctor_init__3D_3JLmosek_4fusion_4Expression_2(numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),numpy.array(msp,dtype=numpy.dtype(numpy.int64)),expr)
  def _ctor_init__3D_3JLmosek_4fusion_4Expression_2(self,mcof,msp,expr):
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   assert msp is None or isinstance(msp,numpy.ndarray)
   mosek_fusion_ExprMulElement._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(self,mcof,msp,expr,1)
   _0=expr.getShape()
   if (int((mcof).shape[0])!=int((msp).shape[0])): # src/fusion/ExprMul.monty:1090:12-33
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix specification")
   _1=mosek.fusion.Set._size__3I(_0)
   _2=False
   _3=False
   for _4 in range(0,int((msp).shape[0])):
    if ((msp[_4] < 0) or (msp[_4] >= _1)): # src/fusion/ExprMul.monty:1098:16-42
     _2 = True
   for _5 in range(0,(int((msp).shape[0]) - 1)):
    if (msp[_5] >= msp[(_5 + 1)]): # src/fusion/ExprMul.monty:1102:16-34
     _3 = True
   if _2: # src/fusion/ExprMul.monty:1105:12-20
    raise mosek_fusion_IndexError._ctor_S("Invalid matrix data")
   if _3: # src/fusion/ExprMul.monty:1108:12-22
    raise mosek_fusion_IndexError._ctor_S("Matrix data not sorted")
  @staticmethod
  def _ctor__3D_3JLmosek_4fusion_4Expression_2I(mcof,msp,expr,validated):
    o = ExprMulElement.__new__(ExprMulElement)
    o._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(mcof,msp,expr,validated)
    return o
  @staticmethod
  def __match_ctor__3D_3JLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    mcof,msp,expr,validated, = args
    return (__arg_match__3D__(mcof) and __arg_match__3J__(msp) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    mcof,msp,expr,validated, = args
    return (__arg_alt_match__3D__(mcof) and __arg_alt_match__3J__(msp) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2I(self,mcof,msp,expr,validated):
    self._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),numpy.array(msp,dtype=numpy.dtype(numpy.int64)),expr,numpy.int32(validated))
  def _ctor_init__3D_3JLmosek_4fusion_4Expression_2I(self,mcof,msp,expr,validated):
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   assert msp is None or isinstance(msp,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr.getShape())
   (self.__expr) = expr
   (self.__mcof) = mcof
   (self.__msp) = msp
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_1,_0,_2)
   _3=_1.popi32()
   _4=_1.popi32(_3)
   _5=_1.popi32()
   _6=_1.popi32()
   _7=(_1.popi32()!=0)
   _8=_1.popi32((_5 + 1))
   _9=(_1.popi64(_5) if (_7 ) else (- 1))
   _10=_1.popi64(_6)
   _11=_1.popf64(_5)
   _12=_1.popf64(_6)
   _13=(_1.i32)
   _14=(_1.i64)
   _15=(_1.f64)
   _16=0
   _17=0
   if (not _7): # src/fusion/ExprMul.monty:1134:12-21
    _17 = int((self.__msp).shape[0])
    for _18 in range(0,int((self.__msp).shape[0])):
     _16 += (_13[((_8 + self.__msp[_18]) + 1)] - _13[(_8 + self.__msp[_18])])
   else:
    _19=int((self.__msp).shape[0])
    _20=0
    _21=_5
    _22=0
    while ((_20 < _19) and (_22 < _21)):
     if (self.__msp[_20] < _14[(_9 + _22)]): # src/fusion/ExprMul.monty:1143:16-42
      _20 += 1
     elif (self.__msp[_20] > _14[(_9 + _22)]): # src/fusion/ExprMul.monty:1145:20-46
      _22 += 1
     else:
      _16 += (_13[((_8 + _22) + 1)] - _13[(_8 + _22)])
      _20 += 1
      _22 += 1
      _17 += 1
   _23=_0.alloci32((_17 + 1))
   _24=_0.alloci64(_16)
   _25=_0.alloci64(_17)
   _26=_0.allocf64(_16)
   _27=_0.allocf64(_17)
   _28=1
   for _29 in range(0,_3):
    _28 *= _13[(_4 + _29)]
   _30=(_17 < _28)
   _0.pushi32((1 if (_30 ) else 0))
   _0.pushi32(_16)
   _0.pushi32(_17)
   _31=_0.alloci32(_3)
   _0.pushi32(_3)
   _32=(_0.i32)
   _33=(_0.i64)
   _34=(_0.f64)
   _35=0
   _36=0
   _32[_23] = 0
   for _37 in range(0,_3):
    _32[(_31 + _37)] = _13[(_4 + _37)]
   if (not _7): # src/fusion/ExprMul.monty:1179:14-23
    for _38 in range(0,int((self.__msp).shape[0])):
     _39=_13[(_8 + self.__msp[_38])]
     _40=_13[((_8 + self.__msp[_38]) + 1)]
     for _41 in range(_39,_40):
      _33[(_24 + _36)] = _14[(_10 + _41)]
      _34[(_26 + _36)] = (_15[(_12 + _41)] * self.__mcof[_38])
      _36 += 1
     _32[((_23 + _38) + 1)] = _36
     _34[(_27 + _38)] = (_15[(_11 + self.__msp[_38])] * self.__mcof[_38])
     _33[(_25 + _38)] = self.__msp[_38]
   else:
    _42=int((self.__msp).shape[0])
    _43=0
    _44=_5
    _45=0
    while ((_43 < _42) and (_45 < _44)):
     if (self.__msp[_43] < _14[(_9 + _45)]): # src/fusion/ExprMul.monty:1199:18-44
      _43 += 1
     elif (self.__msp[_43] > _14[(_9 + _45)]): # src/fusion/ExprMul.monty:1201:22-48
      _45 += 1
     else:
      _46=_13[(_8 + _45)]
      _47=_13[((_8 + _45) + 1)]
      for _48 in range(_46,_47):
       _33[(_24 + _36)] = _14[(_10 + _48)]
       _34[(_24 + _36)] = (_15[(_10 + _48)] * self.__mcof[_43])
       _36 += 1
      _32[((_23 + _35) + 1)] = _36
      _34[(_27 + _35)] = (_15[(_11 + _45)] * self.__mcof[_43])
      _33[(_25 + _35)] = self.__msp[_43]
      _35 += 1
      _43 += 1
      _45 += 1
   if (not _30): # src/fusion/ExprMul.monty:1222:12-22
    _0.popi64(_17)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulElement()")
 return ExprMulElement
mosek_fusion_ExprMulElement=__mk_mosek_fusion_ExprMulElement()
del __mk_mosek_fusion_ExprMulElement
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulScalarConst():
 class ExprMulScalarConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulScalarConst__expr','_ExprMulScalarConst__c']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      self._ctor_init_DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_DLmosek_4fusion_4Expression_2(*args):# double,mosek.fusion.Expression
      self._ctor_alt_init_DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulScalarConst.ctor(double,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarConst._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprMulScalarConst._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprMulScalarConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulScalarConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarConst.eval()\n\tmosek.fusion.ExprMulScalarConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarConst._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulScalarConst._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarConst.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprMulScalarConst: '+self._toString_()
  @staticmethod
  def _ctor_DLmosek_4fusion_4Expression_2(c,expr):
    o = ExprMulScalarConst.__new__(ExprMulScalarConst)
    o._ctor_init_DLmosek_4fusion_4Expression_2(c,expr)
    return o
  @staticmethod
  def __match_ctor_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    c,expr, = args
    return (__arg_match_D__(c) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    c,expr, = args
    return (__arg_alt_match_D__(c) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_DLmosek_4fusion_4Expression_2(self,c,expr):
    self._ctor_init_DLmosek_4fusion_4Expression_2(numpy.float64(c),expr)
  def _ctor_init_DLmosek_4fusion_4Expression_2(self,c,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr.getShape())
   (self.__c) = c
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_0,_1,_2)
   _3=_0.peeki32(0)
   _4=_0.peeki32((_3 + 1))
   _5=_0.peeki32((_3 + 2))
   _6=((_0.pf64) - _4)
   _7=(_6 - _5)
   _8=(_0.f64)
   for _9 in range(0,(_5 + _4)):
    _8[(_7 + _9)] *= self.__c
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulScalarConst()")
 return ExprMulScalarConst
mosek_fusion_ExprMulScalarConst=__mk_mosek_fusion_ExprMulScalarConst()
del __mk_mosek_fusion_ExprMulScalarConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprScalarMul():
 class ExprScalarMul(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprScalarMul__expr','_ExprScalarMul__mval','_ExprScalarMul__msubj','_ExprScalarMul__msubi','_ExprScalarMul__mdim1','_ExprScalarMul__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprScalarMul.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprScalarMul._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprScalarMul._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprScalarMul._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprScalarMul._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprScalarMul.eval()\n\tmosek.fusion.ExprScalarMul.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprScalarMul._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprScalarMul._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprScalarMul.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprScalarMul: '+self._toString_()
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprScalarMul.__new__(ExprScalarMul)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdim0,mdim1], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprScalarMul.__new__(ExprScalarMul)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_ExprScalarMul._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprScalarMul.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr).eval(_1,_0,_2)
   _1.pop_expr()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.hassp)
   _7=(_1.ptr_base)
   _8=(_1.sp_base)
   _9=(_1.nidxs_base)
   _10=(_1.bfix_base)
   _11=(_1.cof_base)
   _12=(_1.i64)
   _13=(_1.f64)
   _14=int((self.__mval).shape[0])
   if (_3!=0): # src/fusion/ExprMul.monty:978:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid expression shape")
   if (_4==0): # src/fusion/ExprMul.monty:981:12-22
    _0.alloc_expr(2,0,0,True)
    (_0.i32)[(_0.shape_base)] = self.__mdim0
    (_0.i32)[((_0.shape_base) + 1)] = self.__mdim1
   else:
    _0.alloc_expr(2,_14,(_14 * _5),True)
    _15=(_0.ptr_base)
    _16=(_0.nidxs_base)
    _17=(_0.sp_base)
    _18=(_0.cof_base)
    _19=(_0.bfix_base)
    _20=(_0.shape_base)
    _21=(_0.i32)
    _22=(_0.i64)
    _23=(_0.f64)
    _21[_20] = self.__mdim0
    _21[(_20 + 1)] = self.__mdim1
    _24=0
    _21[_15] = 0
    for _25 in range(0,_14):
     for _26 in range(0,_5):
      _22[(_16 + _24)] = _12[(_9 + _26)]
      _23[(_18 + _24)] = (_13[(_11 + _26)] * self.__mval[_25])
      _24 += 1
     _22[(_17 + _25)] = ((self.__msubi[_25] * self.__mdim1) + self.__msubj[_25])
     _23[(_19 + _25)] = (self.__mval[_25] * _13[_10])
     _21[((_15 + _25) + 1)] = _24
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprScalarMul.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=_5.getND()
   if (_6!=0): # src/fusion/ExprMul.monty:882:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_0 < 0) or (_1 < 0)): # src/fusion/ExprMul.monty:884:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:886:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _7=int((_2).shape[0])
   _8=False
   _9=False
   for _10 in range(0,_7):
    if ((_2[_10] < 0) or ((_2[_10] >= _0) or ((_3[_10] < 0) or (_3[_10] >= _1)))): # src/fusion/ExprMul.monty:895:17-896:50
     _8 = True
   for _11 in range(0,(_7 - 1)):
    if ((_2[_11] > _2[(_11 + 1)]) or ((_2[_11]==_2[(_11 + 1)]) and (_3[_11] >= _3[(_11 + 1)]))): # src/fusion/ExprMul.monty:900:17-901:68
     _9 = True
   if _8: # src/fusion/ExprMul.monty:904:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _9: # src/fusion/ExprMul.monty:906:12-22
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprScalarMul(M,")._a_S(self.__expr.toString())._a_S(")")._toString_())
 return ExprScalarMul
mosek_fusion_ExprScalarMul=__mk_mosek_fusion_ExprScalarMul()
del __mk_mosek_fusion_ExprScalarMul
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulRight():
 class ExprMulRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulRight__expr','_ExprMulRight__mval','_ExprMulRight__msubj','_ExprMulRight__msubi','_ExprMulRight__mdim1','_ExprMulRight__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulRight.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulRight._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprMulRight._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprMulRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulRight.eval()\n\tmosek.fusion.ExprMulRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulRight._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulRight._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulRight.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprMulRight: '+self._toString_()
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulRight.__new__(ExprMulRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprMulRight.__computeshape_I_3I(mdim1,expr.getShape()))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulRight.__new__(ExprMulRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_ExprMulRight._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr).eval(_1,_0,_2)
   _1.peek_expr()
   _3=(_1.nd)
   _4=(_1.hassp)
   _5=int((self.__mval).shape[0])
   _6=(_5 < (numpy.int64(self.__mdim0) * numpy.int64(self.__mdim1)))
   _7=(_1.i32)[(_1.shape_base)]
   if _6: # src/fusion/ExprMul.monty:530:12-15
    _8=_2.alloci32((self.__mdim1 + 1))
    _9=_2.alloci32(_5)
    _10=_2.alloci32((_7 + 1))
    _11=(_2.i32)
    for _12 in range(0,(self.__mdim1 + 1)):
     _11[(_8 + _12)] = 0
    for _13 in range(0,_5):
     _11[((_8 + self.__msubj[_13]) + 1)] += 1
    for _14 in range(0,self.__mdim1):
     _11[((_8 + _14) + 1)] += _11[(_8 + _14)]
    for _15 in range(0,_5):
     _11[(_9 + _15)] = _11[(_8 + self.__msubj[_15])]
     _11[(_8 + self.__msubj[_15])] += 1
    for _16 in range(0,self.__mdim1):
     _11[((_8 + self.__mdim1) - _16)] = _11[(((_8 + self.__mdim1) - _16) - 1)]
    _11[_8] = 0
    for _17 in range(0,(_7 + 1)):
     _11[(_10 + _17)] = 0
    _1.pop_expr()
    _18=(_1.i32)
    _19=(_1.i64)
    _20=(_1.f64)
    _21=(_1.nd)
    if (_21!=2): # src/fusion/ExprMul.monty:558:14-21
     raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
    _22=(_1.i32)[(_1.shape_base)]
    _23=(_1.i32)[((_1.shape_base) + 1)]
    _24=(_1.nelem)
    _25=(_1.nnz)
    _26=(_1.ptr_base)
    _27=(_1.sp_base)
    _28=(_1.nidxs_base)
    _29=(_1.bfix_base)
    _30=(_1.cof_base)
    if _4: # src/fusion/ExprMul.monty:573:14-19
     for _31 in range(0,_24):
      _11[((_10 + (_19[(_27 + _31)] // _23)) + 1)] += 1
     for _32 in range(0,_22):
      _11[((_10 + _32) + 1)] += _11[(_10 + _32)]
     _33=0
     _34=0
     for _35 in range(0,_22):
      for _36 in range(0,self.__mdim1):
       _37=False
       _38=_11[((_10 + _35) + 1)]
       _39=_11[(_10 + _35)]
       _40=_11[((_8 + _36) + 1)]
       _41=_11[(_8 + _36)]
       while ((_39 < _38) and (_41 < _40)):
        _42=_11[(_9 + _41)]
        if ((_19[(_27 + _39)] % _23) < self.__msubi[_42]): # src/fusion/ExprMul.monty:588:26-64
         _39 += 1
        elif ((_19[(_27 + _39)] % _23) > self.__msubi[_42]): # src/fusion/ExprMul.monty:590:26-64
         _41 += 1
        else:
         _34 += (_18[((_26 + _39) + 1)] - _18[(_26 + _39)])
         _39 += 1
         _41 += 1
         _37 = True
       if _37: # src/fusion/ExprMul.monty:597:20-25
        _33 += 1
     _43=(_33 < (_22 * self.__mdim1))
     _0.alloc_expr(2,_33,numpy.int32(_34),_43)
     _44=(_0.ptr_base)
     _45=(_0.nidxs_base)
     _46=((_0.sp_base) if (_43 ) else _0.alloci64(_33))
     _47=(_0.cof_base)
     _48=(_0.bfix_base)
     _49=(_0.shape_base)
     _50=(_0.i32)
     _51=(_0.i64)
     _52=(_0.f64)
     _50[_49] = _22
     _50[(_49 + 1)] = self.__mdim1
     _53=0
     _54=0
     _50[_44] = 0
     for _55 in range(0,_22):
      for _56 in range(0,self.__mdim1):
       _57=0.0
       _58=0
       _59=_11[((_10 + _55) + 1)]
       _60=_11[(_10 + _55)]
       _61=_11[((_8 + _56) + 1)]
       _62=_11[(_8 + _56)]
       while ((_60 < _59) and (_62 < _61)):
        _63=_11[(_9 + _62)]
        if ((_19[(_27 + _60)] % _23) < self.__msubi[_63]): # src/fusion/ExprMul.monty:630:26-64
         _60 += 1
        elif ((_19[(_27 + _60)] % _23) > self.__msubi[_63]): # src/fusion/ExprMul.monty:632:26-64
         _62 += 1
        else:
         _64=(_18[((_26 + _60) + 1)] - _18[(_26 + _60)])
         _57 += (self.__mval[_63] * _20[(_29 + _60)])
         for _65 in range(0,_64):
          _51[((_45 + _54) + _65)] = _19[((_28 + _18[(_26 + _60)]) + _65)]
         for _66 in range(0,_64):
          _52[((_47 + _54) + _66)] = (_20[((_30 + _18[(_26 + _60)]) + _66)] * self.__mval[_63])
         _58 += _64
         _60 += 1
         _62 += 1
       if (_58 > 0): # src/fusion/ExprMul.monty:647:20-29
        _54 += _58
        _50[((_44 + _53) + 1)] = _54
        _52[(_48 + _53)] = _57
        _51[(_46 + _53)] = ((_55 * self.__mdim1) + _56)
        _53 += 1
     if (not _43): # src/fusion/ExprMul.monty:657:16-26
      _0.popi64(_33)
    else:
     _67=(_22 * self.__mdim1)
     _68=0
     for _69 in range(0,_22):
      for _70 in range(0,self.__mdim1):
       for _71 in range(_11[(_8 + _70)],_11[((_8 + _70) + 1)]):
        _72=_11[(_9 + _71)]
        _73=((_69 * _23) + self.__msubi[_72])
        _68 += (_18[((_26 + _73) + 1)] - _18[(_26 + _73)])
     _74=(_67 < (_22 * self.__mdim1))
     if (not (_68 <= 0x7ffffff)): # src/fusion/ExprMul.monty:675:16-40
      raise mosek_fusion_LengthError._ctor_S("Maximum number of nonzeros exceede in multiplication")
     _0.alloc_expr(2,_67,numpy.int32(_68),_74)
     _75=(_0.ptr_base)
     _76=(_0.nidxs_base)
     _77=((_0.sp_base) if (_74 ) else _0.alloci64(_67))
     _78=(_0.cof_base)
     _79=(_0.bfix_base)
     _80=(_0.i32)
     _81=(_0.i64)
     _82=(_0.f64)
     _83=0
     _84=0
     _80[_75] = 0
     for _85 in range(0,_22):
      for _86 in range(0,self.__mdim1):
       _87=(_85 * _23)
       _88=0.0
       for _89 in range(_11[(_8 + _86)],_11[((_8 + _86) + 1)]):
        _90=_11[(_9 + _89)]
        _91=(_87 + self.__msubi[_90])
        _92=_18[(_26 + _91)]
        _93=(_18[((_26 + _91) + 1)] - _18[(_26 + _91)])
        for _94 in range(0,_93):
         _81[((_76 + _84) + _94)] = _19[((_28 + _92) + _94)]
        for _95 in range(0,_93):
         _82[((_78 + _84) + _95)] = (_20[((_30 + _92) + _95)] * self.__mval[_90])
        _88 += (_20[((_29 + _87) + self.__msubi[_90])] * self.__mval[_90])
        _84 += _93
       _80[((_75 + _83) + 1)] = _84
       _82[(_79 + _83)] = _88
       _81[(_77 + _83)] = ((_85 * self.__mdim1) + _86)
       _83 += 1
     if (not _74): # src/fusion/ExprMul.monty:720:16-26
      _0.popi64(_67)
    _2.clear()
   else:
    _96=_2.alloci32((_7 + 1))
    _97=(_2.i32)
    for _98 in range(0,(_7 + 1)):
     _97[(_96 + _98)] = 0
    _1.pop_expr()
    _99=(_1.i32)
    _100=(_1.i64)
    _101=(_1.f64)
    _102=(_1.nd)
    _103=(_1.nelem)
    _104=(_1.nnz)
    _105=(_1.hassp)
    _106=_104
    _107=_103
    _108=(_1.shape_base)
    _109=(_1.ptr_base)
    _110=(_1.sp_base)
    _111=(_1.nidxs_base)
    _112=(_1.bfix_base)
    _113=(_1.cof_base)
    _114=_99[_108]
    _115=_99[(_108 + 1)]
    if (_102!=2): # src/fusion/ExprMul.monty:754:14-21
     raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
    _116=(_1.i32)
    _117=(_1.i64)
    _118=(_1.f64)
    _119=(_114 * self.__mdim1)
    _120=(numpy.int64(_104) * self.__mdim1)
    _121=False
    _122=2
    if (not (_120 <= 0x7ffffff)): # src/fusion/ExprMul.monty:765:14-38
     raise mosek_fusion_LengthError._ctor_S("Maximum number of nonzeros exceede in multiplication")
    _0.alloc_expr(_122,_119,numpy.int32(_120),_121)
    _123=(_0.i32)
    _124=(_0.i64)
    _125=(_0.f64)
    _126=(_0.shape_base)
    _127=(_0.ptr_base)
    _128=(_0.nidxs_base)
    _129=(_0.sp_base)
    _130=(_0.cof_base)
    _131=(_0.bfix_base)
    _123[_126] = _114
    _123[(_126 + 1)] = self.__mdim1
    _132=0
    _133=0
    _123[_127] = 0
    if _105: # src/fusion/ExprMul.monty:785:14-20
     for _134 in range(0,_103):
      _97[((_96 + (_117[(_110 + _134)] // _115)) + 1)] += 1
     for _135 in range(0,_114):
      _97[((_96 + _135) + 1)] += _97[(_96 + _135)]
     for _136 in range(0,_114):
      for _137 in range(0,self.__mdim1):
       _138=0.0
       _139=0
       for _140 in range(_97[(_96 + _136)],_97[((_96 + _136) + 1)]):
        _141=(_137 + ((_117[(_110 + _140)] % _115) * self.__mdim1))
        _138 += (_118[(_112 + _140)] * self.__mval[_141])
        for _142 in range(_116[(_109 + _140)],_116[((_109 + _140) + 1)]):
         _124[((_128 + _132) + _139)] = _117[(_111 + _142)]
         _125[((_130 + _132) + _139)] = (_118[(_113 + _142)] * self.__mval[_141])
         _139 += 1
       _132 += _139
       _123[((_127 + _133) + 1)] = _132
       _125[(_131 + _133)] = _138
       _133 += 1
    else:
     for _143 in range(0,_114):
      for _144 in range(0,self.__mdim1):
       _145=0.0
       _146=0
       for _147 in range(0,_115):
        _148=((_143 * _115) + _147)
        _149=(_144 + (_147 * self.__mdim1))
        _145 += (_118[(_112 + _148)] * self.__mval[_149])
        for _150 in range(_116[(_109 + _148)],_116[((_109 + _148) + 1)]):
         _124[((_128 + _132) + _146)] = _117[(_111 + _150)]
         _125[((_130 + _132) + _146)] = (_118[(_113 + _150)] * self.__mval[_149])
         _146 += 1
       _132 += _146
       _123[((_127 + _133) + 1)] = _132
       _125[(_131 + _133)] = _145
       _133 += 1
    _2.clear()
  @staticmethod
  def __computeshape_alt_I_3I(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprMulRight.__computeshape_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeshape_I_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_1).shape[0])==1): # src/fusion/ExprMul.monty:493:12-24
    return (numpy.array([1,_0], dtype=numpy.dtype(numpy.int32)))
   else:
    return (numpy.array([_1[0],_0], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=_5.getShape()
   if (int((_6).shape[0])!=2): # src/fusion/ExprMul.monty:431:12-28
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _7=_6[0]
   _8=_6[1]
   if ((_0 < 0) or ((_1 < 0) or ((_7 < 0) or (_8 < 0)))): # src/fusion/ExprMul.monty:438:12-60
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if (_0!=_8): # src/fusion/ExprMul.monty:440:12-26
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:442:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _9=int((_2).shape[0])
   _10=False
   for _11 in range(0,_9):
    _10 = (_10 or ((_2[_11] < 0) or ((_2[_11] >= _0) or ((_3[_11] < 0) or (_3[_11] >= _1)))))
   if _10: # src/fusion/ExprMul.monty:452:14-17
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _12=False
   for _13 in range(0,(_9 - 1)):
    _12 = (_12 or ((_2[_13] > _2[(_13 + 1)]) or ((_2[_13]==_2[(_13 + 1)]) and (_3[_13] >= _3[(_13 + 1)]))))
   if _12: # src/fusion/ExprMul.monty:460:14-17
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulRight(M,")._a_S(self.__expr.toString())._a_S(")")._toString_())
 return ExprMulRight
mosek_fusion_ExprMulRight=__mk_mosek_fusion_ExprMulRight()
del __mk_mosek_fusion_ExprMulRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulLeft():
 class ExprMulLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulLeft__expr','_ExprMulLeft__mval','_ExprMulLeft__msubj','_ExprMulLeft__msubi','_ExprMulLeft__mdim1','_ExprMulLeft__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulLeft.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulLeft._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprMulLeft._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprMulLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulLeft.eval()\n\tmosek.fusion.ExprMulLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulLeft._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulLeft._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulLeft.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprMulLeft: '+self._toString_()
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulLeft.__new__(ExprMulLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprMulLeft.__computeshape_II_3I(mdim0,mdim1,expr.getShape()))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulLeft.__new__(ExprMulLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_ExprMulLeft._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr).eval(_1,_0,_2)
   _1.pop_expr()
   _3=(_1.nd)
   _4=(_1.nnz)
   _5=(_1.nelem)
   _6=(_1.hassp)
   _7=(_1.shape_base)
   _8=(_1.ptr_base)
   _9=(_1.sp_base)
   _10=(_1.nidxs_base)
   _11=(_1.bfix_base)
   _12=(_1.cof_base)
   _13=(_1.i32)
   _14=(_1.i64)
   _15=(_1.f64)
   if (_3!=2): # src/fusion/ExprMul.monty:163:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _16=9999
   _17=9999
   _18=9999
   _19=_13[_7]
   _20=_13[(_7 + 1)]
   _21=int((self.__msubi).shape[0])
   _22=(_21 < (numpy.int64(self.__mdim0) * numpy.int64(self.__mdim1)))
   _23=False
   _24=0
   _25=0
   if _6: # src/fusion/ExprMul.monty:178:12-17
    _16 = _2.alloci32(_5)
    _17 = _2.alloci32(_5)
    _18 = _2.alloci32((_20 + 1))
    _26=(_2.i32)
    for _27 in range(0,(_20 + 1)):
     _26[(_18 + _27)] = 0
    for _28 in range(0,_5):
     _26[((_18 + (_14[(_9 + _28)] % _20)) + 1)] += 1
    for _29 in range(0,_20):
     _26[((_18 + _29) + 1)] += _26[(_18 + _29)]
    for _30 in range(0,_5):
     _31=(_14[(_9 + _30)] % _20)
     _26[(_16 + _26[(_18 + _31)])] = _30
     _26[(_18 + _31)] += 1
    for _32 in range(0,_20):
     _26[((_18 + _20) - _32)] = _26[(((_18 + _20) - _32) - 1)]
    _26[_18] = 0
    if _22: # src/fusion/ExprMul.monty:200:14-19
     _33=0
     while (_33 < _21):
      _34=self.__msubi[_33]
      _35=(_33 + 1)
      while ((_35 < _21) and (self.__msubi[_35]==self.__msubi[_33])):
       _35 += 1
      for _36 in range(0,_20):
       _37=False
       _38=_35
       _39=_33
       _40=_26[((_18 + _36) + 1)]
       _41=_26[(_18 + _36)]
       while ((_39 < _38) and (_41 < _40)):
        _42=_26[(_16 + _41)]
        if (self.__msubj[_39] < (_14[(_9 + _42)] // _20)): # src/fusion/ExprMul.monty:215:26-60
         _39 += 1
        elif (self.__msubj[_39] > (_14[(_9 + _42)] // _20)): # src/fusion/ExprMul.monty:216:26-60
         _41 += 1
        else:
         _37 = True
         _25 += (_13[((_8 + _42) + 1)] - _13[(_8 + _42)])
         _41 += 1
         _39 += 1
       if _37: # src/fusion/ExprMul.monty:223:20-25
        _24 += 1
      _33 = _35
    else:
     _24 = (self.__mdim0 * _20)
     _25 = (numpy.int64(_4) * self.__mdim0)
   else:
    if _22: # src/fusion/ExprMul.monty:234:14-19
     _43=0
     while (_43 < _21):
      _44=(_43 + 1)
      while ((_44 < _21) and (self.__msubi[_43]==self.__msubi[_44])):
       _44 += 1
      _45=self.__msubi[_43]
      for _46 in range(0,_20):
       _47=False
       for _48 in range(_43,_44):
        _49=((self.__msubj[_48] * _20) + _46)
        _25 += (_13[((_8 + _49) + 1)] - _13[(_8 + _49)])
        _47 = True
       if _47: # src/fusion/ExprMul.monty:247:20-25
        _24 += 1
      _43 = _44
    else:
     _25 = (numpy.int64(_4) * self.__mdim0)
     _24 = (self.__mdim0 * _20)
   if (not (_25 <= 0x7ffffff)): # src/fusion/ExprMul.monty:261:12-36
    raise mosek_fusion_LengthError._ctor_S("Maximum number of nonzeros exceede in multiplication")
   _23 = (_24 < (self.__mdim0 * _20))
   _50=2
   _0.alloc_expr(_50,_24,numpy.int32(_25),_23)
   _51=(_0.ptr_base)
   _52=(_0.nidxs_base)
   _53=((_0.sp_base) if (_23 ) else _0.alloci64(_24))
   _54=(_0.cof_base)
   _55=(_0.bfix_base)
   _56=(_0.shape_base)
   _57=(_0.i64)
   _58=(_0.f64)
   _59=(_0.i32)
   _60=(_2.i32)
   _59[_56] = self.__mdim0
   _59[(_56 + 1)] = _20
   if _6: # src/fusion/ExprMul.monty:287:12-17
    _59[_51] = 0
    if _22: # src/fusion/ExprMul.monty:289:14-19
     _61=0
     _62=0
     _63=0
     while (_63 < _21):
      _64=self.__msubi[_63]
      _65=(_63 + 1)
      while ((_65 < _21) and (self.__msubi[_65]==self.__msubi[_63])):
       _65 += 1
      for _66 in range(0,_20):
       _67=False
       _68=0.0
       _69=_65
       _70=_63
       _71=_60[((_18 + _66) + 1)]
       _72=_60[(_18 + _66)]
       while ((_70 < _69) and (_72 < _71)):
        _73=_60[(_16 + _72)]
        if (self.__msubj[_70] < (_14[(_9 + _73)] // _20)): # src/fusion/ExprMul.monty:305:26-60
         _70 += 1
        elif (self.__msubj[_70] > (_14[(_9 + _73)] // _20)): # src/fusion/ExprMul.monty:306:26-60
         _72 += 1
        else:
         _67 = True
         _68 += (_15[(_11 + _73)] * self.__mval[_70])
         _74=(_13[((_8 + _73) + 1)] - _13[(_8 + _73)])
         for _75 in range(0,_74):
          _57[((_52 + _62) + _75)] = _14[((_10 + _13[(_8 + _73)]) + _75)]
         for _76 in range(0,_74):
          _58[((_54 + _62) + _76)] = (_15[((_12 + _13[(_8 + _73)]) + _76)] * self.__mval[_70])
         _70 += 1
         _72 += 1
         _62 += _74
       if _67: # src/fusion/ExprMul.monty:319:20-25
        _59[((_51 + _61) + 1)] = _62
        _57[(_53 + _61)] = ((_64 * _20) + _66)
        _58[(_55 + _61)] = _68
        _61 += 1
      _63 = _65
    else:
     _77=0
     _78=0
     for _79 in range(0,self.__mdim0):
      for _80 in range(0,_20):
       _81=0.0
       for _82 in range(_60[(_18 + _80)],_60[((_18 + _80) + 1)]):
        _83=_60[(_16 + _82)]
        _84=((_79 * self.__mdim1) + (_14[(_9 + _83)] // _20))
        _81 += (_15[(_11 + _83)] * self.__mval[_84])
        _85=(_13[((_8 + _83) + 1)] - _13[(_8 + _83)])
        for _86 in range(0,_85):
         _57[((_52 + _78) + _86)] = _14[((_10 + _13[(_8 + _83)]) + _86)]
         _58[((_54 + _78) + _86)] = (_15[((_12 + _13[(_8 + _83)]) + _86)] * self.__mval[_84])
        _78 += _85
       _59[((_51 + _77) + 1)] = _78
       _58[(_55 + _77)] = _81
       _77 += 1
   else:
    _59[_51] = 0
    _87=0
    _88=0
    _89=0
    while (_87 < _21):
     _90=(_87 + 1)
     while ((_90 < _21) and (self.__msubi[_87]==self.__msubi[_90])):
      _90 += 1
     _91=self.__msubi[_87]
     for _92 in range(0,_20):
      _93=0.0
      _94=False
      for _95 in range(_87,_90):
       _96=((self.__msubj[_95] * _20) + _92)
       _97=(_13[((_8 + _96) + 1)] - _13[(_8 + _96)])
       for _98 in range(0,_97):
        _57[((_52 + _89) + _98)] = _14[((_10 + _13[(_8 + _96)]) + _98)]
       for _99 in range(0,_97):
        _58[((_54 + _89) + _99)] = (_15[((_12 + _13[(_8 + _96)]) + _99)] * self.__mval[_95])
       _93 += (_15[(_11 + _96)] * self.__mval[_95])
       _94 = True
       _89 += _97
      if _94: # src/fusion/ExprMul.monty:376:18-23
       _57[(_53 + _88)] = ((_91 * _20) + _92)
       _58[(_55 + _88)] = _93
       _59[((_51 + _88) + 1)] = _89
       _88 += 1
     _87 = _90
   if (not _23): # src/fusion/ExprMul.monty:389:12-22
    _0.popi64(_24)
   _2.clear()
  @staticmethod
  def __computeshape_alt_II_3I(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprMulLeft.__computeshape_II_3I(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeshape_II_3I(_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (int((_2).shape[0])!=2): # src/fusion/ExprMul.monty:98:12-24
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   elif (_1!=_2[0]): # src/fusion/ExprMul.monty:100:16-27
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   return (numpy.array([_0,_2[1]], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if (_5.getND()!=2): # src/fusion/ExprMul.monty:37:12-29
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _6=_5.getDim(0)
   _7=_5.getDim(0)
   if ((_0 < 0) or (_1 < 0)): # src/fusion/ExprMul.monty:43:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if (_1!=_6): # src/fusion/ExprMul.monty:45:12-26
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:47:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _8=int((_2).shape[0])
   _9=False
   _10=False
   for _11 in range(0,_8):
    _9 = (_9 or ((_2[_11] < 0) or ((_2[_11] >= _0) or ((_3[_11] < 0) or (_3[_11] >= _1)))))
   if (not _9): # src/fusion/ExprMul.monty:58:14-26
    for _12 in range(0,(_8 - 1)):
     _10 = (_10 or ((_2[_12] > _2[(_12 + 1)]) or ((_2[_12]==_2[(_12 + 1)]) and (_3[_12] >= _3[(_12 + 1)]))))
   if _9: # src/fusion/ExprMul.monty:63:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _10: # src/fusion/ExprMul.monty:65:12-24
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulLeft(M(")._a_I(self.__mdim0)._a_S(",")._a_I(self.__mdim1)._a_S("),")._a_S(self.__expr.toString())._a_S(")")._toString_())
 return ExprMulLeft
mosek_fusion_ExprMulLeft=__mk_mosek_fusion_ExprMulLeft()
del __mk_mosek_fusion_ExprMulLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulVar():
 class ExprMulVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulVar__left','_ExprMulVar__x','_ExprMulVar__mcof','_ExprMulVar__msubj','_ExprMulVar__msubi','_ExprMulVar__mdimj','_ExprMulVar__mdimi']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args): # bool,int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):# bool,int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulVar.ctor(bool,int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Variable)')
  def eval_right(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1right_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval_right('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval_right(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def eval_left(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1left_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval_left('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval_left(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprMulVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval()\n\tmosek.fusion.ExprMulVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulVar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprMulVar: '+self._toString_()
  @staticmethod
  def _ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,mdimi,mdimj,msubi,msubj,mcof,x):
    o = ExprMulVar.__new__(ExprMulVar)
    o._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,mdimi,mdimj,msubi,msubj,mcof,x)
    return o
  @staticmethod
  def __match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 7: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_match_Z__(left) and __arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 7: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_alt_match_Z__(left) and __arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(self,left,mdimi,mdimj,msubi,msubj,mcof,x):
    self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x)
  def _ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(self,left,mdimi,mdimj,msubi,msubj,mcof,x):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   mosek_fusion_ExprMulVar._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,1)
   _0=x.getShape()
   _1=int((_0).shape[0])
   if (_1!=2): # src/fusion/ExprMulVar.monty:270:12-19
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   elif (left and (_0[0]!=mdimj)): # src/fusion/ExprMulVar.monty:272:16-43
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   elif ((not left) and (_0[1]!=mdimi)): # src/fusion/ExprMulVar.monty:274:16-47
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((msubi).shape[0])!=int((msubj).shape[0])) or (int((msubi).shape[0])!=int((mcof).shape[0]))): # src/fusion/ExprMulVar.monty:277:12-63
    raise mosek_fusion_LengthError._ctor_S("Mismatching matrix data lengths")
   self.__validate_II_3I_3I_3D(mdimi,mdimj,msubi,msubj,mcof)
  @staticmethod
  def _ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    o = ExprMulVar.__new__(ExprMulVar)
    o._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_)
    return o
  @staticmethod
  def __match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 8: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_match_Z__(left) and __arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 8: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_alt_match_Z__(left) and __arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x,numpy.int32(unchecked_))
  def _ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprMulVar.__resshape_II_3IZ(mdimi,mdimj,x.getShape(),left))
   (self.__left) = left
   (self.__x) = x
   (self.__mdimi) = mdimi
   (self.__mdimj) = mdimj
   (self.__msubi) = mosek.fusion.Utils.Tools._arraycopy__3I(msubi)
   (self.__msubj) = mosek.fusion.Utils.Tools._arraycopy__3I(msubj)
   (self.__mcof) = mosek.fusion.Utils.Tools._arraycopy__3D(mcof)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   if self.__left: # src/fusion/ExprMulVar.monty:770:12-16
    self.eval_left(_0,_1,_2)
   else:
    self.eval_right(_0,_1,_2)
  @staticmethod
  def _match_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_1right_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=(_1.pi32)
   _4=(_1.pi64)
   _5=self.__x.numInst()
   _6=_1.alloci64(_5)
   _7=_1.alloci64(_5)
   _8=_1.alloci32(_5)
   _9=_1.alloci32(_5)
   _10=self.__x.getShape()
   _11=int((_10).shape[0])
   _12=(_10[0] * _10[1])
   _13=_10[1]
   _14=_10[0]
   _15=_1.alloci32((_14 + 1))
   _16=int(((self.__msubi)).shape[0])
   _17=(self.__msubi)
   _18=(self.__msubj)
   _19=(self.__mcof)
   _20=(self.__mdimi)
   _21=(self.__mdimj)
   _22=((_16 // _20)==_21)
   _23=_1.alloci32(_16)
   _24=_1.alloci32((self.__mdimj + 1))
   _25=(_1.i32)
   _26=(_1.i64)
   _27=0
   _28=0
   self.__x.inst(_7,_26,_6,_26)
   if _22: # src/fusion/ExprMulVar.monty:507:12-22
    _29=0
    if (_5 > 0): # src/fusion/ExprMulVar.monty:511:14-20
     _29 = 1
     if (_14 > 1): # src/fusion/ExprMulVar.monty:513:16-25
      if (_13==1): # src/fusion/ExprMulVar.monty:514:18-28
       for _30 in range(1,_5):
        if (_26[(_7 + _30)] > _26[((_7 + _30) - 1)]): # src/fusion/ExprMulVar.monty:516:22-47
         _29 += 1
      else:
       for _31 in range(1,_5):
        if ((_26[(_7 + _31)] // _13) > (_26[((_7 + _31) - 1)] // _13)): # src/fusion/ExprMulVar.monty:520:22-63
         _29 += 1
    _28 = (_29 * _21)
    _27 = (_5 * _21)
    _32=(_29 < _14)
    _33=_0.alloci32((_28 + 1))
    _0.pushi32((1 if (_32 ) else 0))
    _0.pushi32(_27)
    _0.pushi32(_28)
    _0.pushi32(_14)
    _0.pushi32(_21)
    _0.pushi32(2)
    _34=_0.alloci64(_27)
    _35=_0.alloci64(_28)
    _36=_0.allocf64(_27)
    _37=_0.allocf64(_28)
    _38=(_0.i32)
    _39=(_0.i64)
    _40=(_0.f64)
    _41=0
    _42=0
    _43=0
    _38[_33] = 0
    while (_41 < _5):
     _44=_41
     _41 += 1
     while ((_41 < _5) and ((_26[(_7 + _41)] // _13)==(_26[(_7 + _44)] // _13))):
      _41 += 1
     _45=(_26[(_7 + _44)] // _13)
     for _46 in range(0,_21):
      for _47 in range(_44,_41):
       _48=(_26[(_7 + _47)] % _13)
       _39[(_34 + _43)] = _26[(_6 + _47)]
       _40[(_36 + _43)] = _19[((_48 * _21) + _46)]
       _43 += 1
      _38[((_33 + _42) + 1)] = _43
      _40[(_37 + _42)] = 0.0
      _39[(_35 + _42)] = ((_45 * _21) + _46)
      _42 += 1
    if (not _32): # src/fusion/ExprMulVar.monty:571:14-23
     _0.popi64(_28)
   else:
    if (_21==1): # src/fusion/ExprMulVar.monty:578:16-26
     for _49 in range(0,_16):
      _25[(_23 + _49)] = _49
     _25[_24] = 0
     _25[(_24 + 1)] = _16
    else:
     _25[_24] = 0
     for _50 in range(0,(_21 + 1)):
      _25[(_24 + _50)] = 0
     for _51 in range(0,_16):
      _25[((_24 + _18[_51]) + 1)] += 1
     for _52 in range(0,self.__mdimj):
      _25[((_24 + _52) + 1)] += _25[(_24 + _52)]
     for _53 in range(0,_16):
      _25[(_23 + _25[(_24 + _18[_53])])] = _53
      _25[(_24 + _18[_53])] += 1
     for _54 in range(0,_21):
      _25[((_24 + _21) - _54)] = _25[(((_24 + _21) - _54) - 1)]
     _25[_24] = 0
    if ((_5 // _14)==_13): # src/fusion/ExprMulVar.monty:597:14-33
     _55=0
     _56=0
     while (_56 < _16):
      _56 += 1
      while ((_56 < _16) and (_18[_25[((_23 + _56) - 1)]]==_18[_25[(_23 + _56)]])):
       _56 += 1
      _55 += 1
     _28 = (_55 * _14)
     _27 = (_16 * _14)
     _57=(_55 < _21)
     _58=_0.alloci32((_28 + 1))
     _0.pushi32((1 if (_57 ) else 0))
     _0.pushi32(_27)
     _0.pushi32(_28)
     _0.pushi32(_14)
     _0.pushi32(_21)
     _0.pushi32(2)
     _59=_0.alloci64(_27)
     _60=_0.alloci64(_28)
     _61=_0.allocf64(_27)
     _62=_0.allocf64(_28)
     _63=(_0.i32)
     _64=(_0.i64)
     _65=(_0.f64)
     _63[_58] = 0
     _66=0
     _67=0
     for _68 in range(0,_14):
      _69=0
      while (_69 < _16):
       _70=_69
       _69 += 1
       while ((_69 < _16) and (_18[_25[(_23 + _70)]]==_18[_25[(_23 + _69)]])):
        _69 += 1
       _71=_18[_25[(_23 + _70)]]
       for _72 in range(_70,_69):
        _73=_17[_25[(_23 + _72)]]
        _64[(_59 + _67)] = _26[((_6 + (_68 * _13)) + _73)]
        _65[(_61 + _67)] = _19[_25[(_23 + _72)]]
        _67 += 1
       _65[(_62 + _66)] = 0.0
       _64[(_60 + _66)] = ((_68 * _21) + _71)
       _63[((_58 + _66) + 1)] = _67
       _66 += 1
     if (not _57): # src/fusion/ExprMulVar.monty:664:16-26
      _0.popi64(_28)
    else:
     for _74 in range(0,(_14 + 1)):
      _25[(_15 + _74)] = 0
     if (_11==1): # src/fusion/ExprMulVar.monty:671:16-23
      for _75 in range(0,_5):
       _25[(_8 + _75)] = 0
      for _76 in range(0,_5):
       _25[(_9 + _76)] = numpy.int32(_26[(_7 + _76)])
      _25[_15] = 0
      _25[(_15 + 1)] = _5
     else:
      for _77 in range(0,_5):
       _25[(_8 + _77)] = numpy.int32((_26[(_7 + _77)] // _10[1]))
      for _78 in range(0,_5):
       _25[(_9 + _78)] = numpy.int32((_26[(_7 + _78)] % _10[1]))
      _25[_15] = 0
      for _79 in range(0,_5):
       _25[((_15 + _25[(_8 + _79)]) + 1)] += 1
      for _80 in range(0,_14):
       _25[((_15 + _80) + 1)] += _25[(_15 + _80)]
     for _81 in range(0,_14):
      for _82 in range(0,self.__mdimj):
       _83=0
       _84=_25[((_15 + _81) + 1)]
       _85=_25[((_24 + _82) + 1)]
       _86=_25[(_15 + _81)]
       _87=_25[(_24 + _82)]
       while ((_87 < _85) and (_86 < _84)):
        if (_17[_25[(_23 + _87)]] < _25[(_9 + _86)]): # src/fusion/ExprMulVar.monty:694:26-63
         _87 += 1
        elif (_17[_25[(_23 + _87)]] > _25[(_9 + _86)]): # src/fusion/ExprMulVar.monty:696:26-63
         _86 += 1
        else:
         _83 += 1
         _87 += 1
         _86 += 1
       if (_83 > 0): # src/fusion/ExprMulVar.monty:702:20-26
        _27 += _83
        _28 += 1
     _88=_0.alloci32((_28 + 1))
     _89=(True if ((_28 < (_13 * self.__mdimi)) ) else False)
     _0.pushi32((1 if (_89 ) else 0))
     _0.pushi32(_27)
     _0.pushi32(_28)
     _0.pushi32(_14)
     _0.pushi32(self.__mdimj)
     _0.pushi32(2)
     _90=_0.alloci64(_27)
     _91=_0.alloci64(_28)
     _92=_0.allocf64(_27)
     _93=_0.allocf64(_28)
     _94=(_0.i32)
     _95=(_0.i64)
     _96=(_0.f64)
     _97=0
     _98=0
     _99=0
     _94[_88] = 0
     for _100 in range(0,_28):
      _96[(_93 + _100)] = 0.0
     for _101 in range(0,_14):
      for _102 in range(0,self.__mdimj):
       _103=0
       _104=_25[((_15 + _101) + 1)]
       _105=_25[((_24 + _102) + 1)]
       _106=_25[(_15 + _101)]
       _107=_25[(_24 + _102)]
       while ((_107 < _105) and (_106 < _104)):
        if (_17[_25[(_23 + _107)]] < _25[(_9 + _106)]): # src/fusion/ExprMulVar.monty:740:24-61
         _107 += 1
        elif (_17[_25[(_23 + _107)]] > _25[(_9 + _106)]): # src/fusion/ExprMulVar.monty:742:28-65
         _106 += 1
        else:
         _95[(_90 + _99)] = _26[(_6 + _106)]
         _96[(_92 + _99)] = _19[_25[(_23 + _107)]]
         _103 += 1
         _99 += 1
         _107 += 1
         _106 += 1
       if (_103 > 0): # src/fusion/ExprMulVar.monty:751:22-28
        _94[((_88 + _98) + 1)] = _99
        _95[(_91 + _98)] = _97
        _98 += 1
       _97 += 1
     if (not _89): # src/fusion/ExprMulVar.monty:759:16-26
      _0.popi64(_28)
   (_1.pi32) = _3
   (_1.pi64) = _4
  @staticmethod
  def _match_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_1left_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self.__x.numInst()
   _4=self.__x.getShape()
   _5=int((_4).shape[0])
   _6=_2.alloci64(_3)
   _7=_2.alloci64(_3)
   _8=_2.alloci32(_3)
   _9=_2.alloci32(_3)
   _10=_2.alloci32(_3)
   _11=_2.alloci32((self.__mdimi + 1))
   _12=self.__x.getShape()
   _13=int((_12).shape[0])
   _14=(1 if ((_13==1) ) else _12[1])
   _15=_12[0]
   _16=_2.alloci32((_14 + 1))
   _17=(self.__msubi)
   _18=(self.__msubj)
   _19=(self.__mcof)
   _20=(self.__mdimi)
   _21=(self.__mdimj)
   _22=0
   _23=0
   _24=(_2.i32)
   _25=(_2.i64)
   _26=int((_19).shape[0])
   self.__x.inst(_7,_25,_6,_25)
   if (self.__x.numInst() < self.__x.getSize()): # src/fusion/ExprMulVar.monty:317:12-37
    for _27 in range(0,(_20 + 1)):
     _24[(_11 + _27)] = 0
    for _28 in range(0,int((_17).shape[0])):
     _24[((_11 + _17[_28]) + 1)] += 1
    for _29 in range(0,_20):
     _24[((_11 + _29) + 1)] += _24[(_11 + _29)]
    if (_13==1): # src/fusion/ExprMulVar.monty:324:16-23
     for _30 in range(0,_3):
      _24[(_8 + _30)] = numpy.int32(_25[(_7 + _30)])
     for _31 in range(0,_3):
      _24[(_9 + _31)] = 0
    else:
     for _32 in range(0,_3):
      _24[(_8 + _32)] = numpy.int32((_25[(_7 + _32)] // _14))
     for _33 in range(0,_3):
      _24[(_9 + _33)] = numpy.int32((_25[(_7 + _33)] % _14))
    if (_13 > 1): # src/fusion/ExprMulVar.monty:333:16-22
     for _34 in range(0,(_14 + 1)):
      _24[(_16 + _34)] = 0
     for _35 in range(0,_3):
      _24[((_16 + _24[(_9 + _35)]) + 1)] += 1
     for _36 in range(0,_14):
      _24[((_16 + _36) + 1)] += _24[(_16 + _36)]
     for _37 in range(0,_3):
      _24[(_10 + _24[(_16 + _24[(_9 + _37)])])] = _37
      _24[(_16 + _24[(_9 + _37)])] += 1
     for _38 in range(0,_14):
      _24[((_16 + _14) - _38)] = _24[(((_16 + _14) - _38) - 1)]
     _24[_16] = 0
    else:
     _24[_16] = 0
     _24[(_16 + 1)] = _3
     for _39 in range(0,_3):
      _24[(_10 + _39)] = _39
    for _40 in range(0,_20):
     for _41 in range(0,_14):
      _42=0
      _43=_24[((_16 + _41) + 1)]
      _44=_24[((_11 + _40) + 1)]
      _45=_24[(_16 + _41)]
      _46=_24[(_11 + _40)]
      while ((_46 < _44) and (_45 < _43)):
       if (_18[_46] < _24[(_8 + _24[(_10 + _45)])]): # src/fusion/ExprMulVar.monty:359:26-63
        _46 += 1
       elif (_18[_46] > _24[(_8 + _24[(_10 + _45)])]): # src/fusion/ExprMulVar.monty:361:24-61
        _45 += 1
       else:
        _42 += 1
        _46 += 1
        _45 += 1
      if (_42 > 0): # src/fusion/ExprMulVar.monty:367:20-26
       _22 += _42
       _23 += 1
   else:
    _22 = (_26 * _14)
    _47=0
    while (_47 < _26):
     _48=(_47 + 1)
     while ((_48 < _26) and (_17[_47]==_17[_48])):
      _48 += 1
     _23 += 1
     _47 = _48
    _23 *= _14
   _49=(True if ((_23 < (_14 * _20)) ) else False)
   _50=_13
   _0.alloc_expr(_50,_23,_22,_49)
   _51=(_0.ptr_base)
   _52=(_0.shape_base)
   _53=(_0.nidxs_base)
   _54=((_0.sp_base) if (_49 ) else _0.alloci64(_23))
   _55=(_0.cof_base)
   _56=(_0.bfix_base)
   _57=(_0.i32)
   _58=(_0.i64)
   _59=(_0.f64)
   _57[_52] = _20
   if (_13 > 1): # src/fusion/ExprMulVar.monty:402:12-18
    _57[(_52 + 1)] = _14
   if (self.__x.numInst() < self.__x.getSize()): # src/fusion/ExprMulVar.monty:406:12-37
    _60=0
    _61=0
    _62=0
    _57[_51] = 0
    for _63 in range(0,_23):
     _59[(_56 + _63)] = 0.0
    for _64 in range(0,_20):
     for _65 in range(0,_14):
      _66=0
      _67=_24[((_16 + _65) + 1)]
      _68=_24[((_11 + _64) + 1)]
      _69=_24[(_16 + _65)]
      _70=_24[(_11 + _64)]
      while ((_70 < _68) and (_69 < _67)):
       if (_18[_70] < _24[(_8 + _24[(_10 + _69)])]): # src/fusion/ExprMulVar.monty:421:20-57
        _70 += 1
       elif (_18[_70] > _24[(_8 + _24[(_10 + _69)])]): # src/fusion/ExprMulVar.monty:423:24-61
        _69 += 1
       else:
        _58[(_53 + _62)] = _25[(_6 + _24[(_10 + _69)])]
        _59[(_55 + _62)] = _19[_70]
        _66 += 1
        _62 += 1
        _70 += 1
        _69 += 1
      if (_66 > 0): # src/fusion/ExprMulVar.monty:432:18-24
       _57[((_51 + _61) + 1)] = _62
       _58[(_54 + _61)] = _60
       _61 += 1
      _60 += 1
   else:
    _71=0
    _72=0
    _57[_51] = 0
    _73=0
    while (_73 < _26):
     _74=(_73 + 1)
     while ((_74 < _26) and (_17[_74]==_17[_73])):
      _74 += 1
     for _75 in range(0,_14):
      for _76 in range(_73,_74):
       _58[(_53 + _71)] = _25[((_6 + (_18[_76] * _14)) + _75)]
       _59[(_55 + _71)] = _19[_76]
       _71 += 1
      _57[((_51 + _72) + 1)] = _71
      _58[(_54 + _72)] = ((_17[_73] * _14) + _75)
      _59[(_56 + _72)] = 0
      _72 += 1
     _73 = _74
   if (not _49): # src/fusion/ExprMulVar.monty:462:12-22
    _0.popi64(_23)
   _2.clear()
  def __validate_alt_II_3I_3I_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__validate_II_3I_3I_3D(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __validate_II_3I_3I_3D(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=True
   for _6 in range(0,int((_2).shape[0])):
    if ((_2[_6] < 0) or ((_2[_6] >= _0) or ((_3[_6] < 0) or (_3[_6] >= _1)))): # src/fusion/ExprMulVar.monty:238:16-239:49
     _5 = False
   for _7 in range(1,int((_2).shape[0])):
    if ((_2[(_7 - 1)] > _2[_7]) or ((_2[(_7 - 1)]==_2[_7]) and (_3[(_7 - 1)] >= _3[_7]))): # src/fusion/ExprMulVar.monty:243:16-92
     _5 = False
   if (not _5): # src/fusion/ExprMulVar.monty:247:12-18
    raise mosek_fusion_IndexError._ctor_S("Invalid matrix data")
  @staticmethod
  def __resshape_alt_II_3IZ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=_t__3
   _1 = mosek_fusion_ExprMulVar.__resshape_II_3IZ(_0,_1,_2,_3)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __resshape_II_3IZ(_0,_1,_2,_3):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if _3: # src/fusion/ExprMulVar.monty:195:12-16
    return (numpy.array([_0,_2[1]], dtype=numpy.dtype(numpy.int32)))
   else:
    return (numpy.array([_2[0],_1], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   if self.__left: # src/fusion/ExprMulVar.monty:188:12-16
    return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulVar(M,")._a_S(self.__x.toString())._a_S(")")._toString_())
   else:
    return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulVar(")._a_S(self.__x.toString())._a_S(",M)")._toString_())
 return ExprMulVar
mosek_fusion_ExprMulVar=__mk_mosek_fusion_ExprMulVar()
del __mk_mosek_fusion_ExprMulVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulScalarVar():
 class ExprMulScalarVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulScalarVar__x','_ExprMulScalarVar__mcof','_ExprMulScalarVar__msubj','_ExprMulScalarVar__msubi','_ExprMulScalarVar__mdimj','_ExprMulScalarVar__mdimi']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulScalarVar.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Variable)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarVar._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprMulScalarVar._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprMulScalarVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulScalarVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarVar.eval()\n\tmosek.fusion.ExprMulScalarVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarVar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulScalarVar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarVar.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprMulScalarVar: '+self._toString_()
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(mdimi,mdimj,msubi,msubj,mcof,x):
    o = ExprMulScalarVar.__new__(ExprMulScalarVar)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(mdimi,mdimj,msubi,msubj,mcof,x)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 6: return False
    mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 6: return False
    mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(self,mdimi,mdimj,msubi,msubj,mcof,x):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(self,mdimi,mdimj,msubi,msubj,mcof,x):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   mosek_fusion_ExprMulScalarVar._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,mosek.fusion.Utils.Tools._arraycopy__3I(msubi),mosek.fusion.Utils.Tools._arraycopy__3I(msubj),mosek.fusion.Utils.Tools._arraycopy__3D(mcof),x,1)
   if (x.getND()!=0): # src/fusion/ExprMulVar.monty:108:12-26
    raise mosek_fusion_DimensionError._ctor_S("Invalid Variable size")
   if ((mdimi < 0) or ((mdimj < 0) or ((int((msubi).shape[0])!=int((msubj).shape[0])) or (int((msubi).shape[0])!=int((mcof).shape[0]))))): # src/fusion/ExprMulVar.monty:111:12-89
    raise mosek_fusion_LengthError._ctor_S("Invalid Matrix data")
   _0=False
   for _1 in range(0,int((msubi).shape[0])):
    if ((msubi[_1] < 0) or ((msubi[_1] >= mdimi) or ((msubj[_1] < 0) or (msubj[_1] >= mdimj)))): # src/fusion/ExprMulVar.monty:116:14-117:47
     _0 = True
   if _0: # src/fusion/ExprMulVar.monty:119:12-20
    raise mosek_fusion_IndexError._ctor_S("Invalid Matrix data")
   _2=False
   for _3 in range(1,int((msubi).shape[0])):
    if ((msubi[_3] < msubi[(_3 - 1)]) or ((msubi[_3]==msubi[(_3 - 1)]) and (msubj[_3] <= msubj[(_3 - 1)]))): # src/fusion/ExprMulVar.monty:124:14-125:65
     _2 = True
   if _2: # src/fusion/ExprMulVar.monty:127:12-22
    raise mosek_fusion_IndexError._ctor_S("Matrix data not correctly sorted")
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    o = ExprMulScalarVar.__new__(ExprMulScalarVar)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(mdimi,mdimj,msubi,msubj,mcof,x,unchecked_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 7: return False
    mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 7: return False
    mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x,numpy.int32(unchecked_))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdimi,mdimj], dtype=numpy.dtype(numpy.int32)))
   (self.__mdimi) = mdimi
   (self.__mdimj) = mdimj
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mcof) = mcof
   (self.__x) = x
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   if (self.__x.numInst()==0): # src/fusion/ExprMulVar.monty:132:12-28
    _0.alloc_expr(2,0,0,False)
    (_0.i32)[(_0.shape_base)] = self.__mdimi
    (_0.i32)[((_0.shape_base) + 1)] = self.__mdimj
   else:
    _3=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
    self.__x.inst(0,_3)
    _4=_3[0]
    _5=int((self.__msubi).shape[0])
    _6=_5
    _7=(_5 < (self.__mdimi * self.__mdimj))
    _0.alloc_expr(2,_5,_6,_7)
    _8=(_0.ptr_base)
    (_0.i32)[(_0.shape_base)] = self.__mdimi
    (_0.i32)[((_0.shape_base) + 1)] = self.__mdimj
    _9=(_0.nidxs_base)
    _10=(_0.sp_base)
    _11=(_0.cof_base)
    _12=(_0.bfix_base)
    _13=(_0.i32)
    _14=(_0.i64)
    _15=(_0.f64)
    for _16 in range(0,_5):
     _15[(_12 + _16)] = 0
    for _17 in range(0,_6):
     _15[(_11 + _17)] = self.__mcof[_17]
    for _18 in range(0,_6):
     _14[(_9 + _18)] = _4
    if _7: # src/fusion/ExprMulVar.monty:165:16-21
     for _19 in range(0,_5):
      _14[(_10 + _19)] = ((self.__msubi[_19] * self.__mdimj) + self.__msubj[_19])
    for _20 in range(0,(_5 + 1)):
     _13[(_8 + _20)] = _20
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulScalarVar(M(")._a_I(self.__mdimi)._a_S(",")._a_I(self.__mdimj)._a_S("), ")._a_S(self.__x.toString())._a_S(")")._toString_())
 return ExprMulScalarVar
mosek_fusion_ExprMulScalarVar=__mk_mosek_fusion_ExprMulScalarVar()
del __mk_mosek_fusion_ExprMulScalarVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulVarScalarConst():
 class ExprMulVarScalarConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulVarScalarConst__c','_ExprMulVarScalarConst__x']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      self._ctor_init_Lmosek_4fusion_4Variable_2D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Variable_2D(*args):# mosek.fusion.Variable,double
      self._ctor_alt_init_Lmosek_4fusion_4Variable_2D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulVarScalarConst.ctor(mosek.fusion.Variable,double)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVarScalarConst._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprMulVarScalarConst._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprMulVarScalarConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVarScalarConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVarScalarConst.eval()\n\tmosek.fusion.ExprMulVarScalarConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVarScalarConst._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulVarScalarConst._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVarScalarConst.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprMulVarScalarConst: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2D(x,c):
    o = ExprMulVarScalarConst.__new__(ExprMulVarScalarConst)
    o._ctor_init_Lmosek_4fusion_4Variable_2D(x,c)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    x,c, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_D__(c))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    x,c, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_D__(c))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2D(self,x,c):
    self._ctor_init_Lmosek_4fusion_4Variable_2D(x,numpy.float64(c))
  def _ctor_init_Lmosek_4fusion_4Variable_2D(self,x,c):
   mosek_fusion_BaseExpression._ctor_init__3I(self,x.getShape())
   (self.__x) = x
   (self.__c) = c
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self.__x.numInst()
   _4=_3
   _5=self.__x.getShape()
   _6=int((_5).shape[0])
   _7=_0.alloci32((_4 + 1))
   _8=_0.alloci64(_3)
   _9=(mosek.fusion.Set._size__3I(_5) > _4)
   _10=(_0.alloci64(_4) if (_9 ) else 0)
   _11=_0.allocf64(_3)
   _12=_0.allocf64(_4)
   if _9: # src/fusion/ExprMulVar.monty:29:12-17
    self.__x.inst(_10,(_0.i64),_8,(_0.i64))
   else:
    self.__x.inst(_8,(_0.i64))
   _0.pushi32((1 if (_9 ) else 0))
   _0.pushi32(_4)
   _0.pushi32(_3)
   for _13 in range(0,_6):
    _0.pushi32(_5[_13])
   _0.pushi32(_6)
   _14=(_0.i32)
   _15=(_0.i64)
   _16=(_0.f64)
   for _17 in range(0,(_4 + 1)):
    _14[(_7 + _17)] = _17
   for _18 in range(0,_3):
    _16[(_11 + _18)] = 1.0
   for _19 in range(0,_4):
    _16[(_12 + _19)] = 0.0
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulVarScalarConst()")
 return ExprMulVarScalarConst
mosek_fusion_ExprMulVarScalarConst=__mk_mosek_fusion_ExprMulVarScalarConst()
del __mk_mosek_fusion_ExprMulVarScalarConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprAdd():
 class ExprAdd(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprAdd__m2','_ExprAdd__m1','_ExprAdd__e2','_ExprAdd__e1']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double,double
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):# mosek.fusion.Expression,mosek.fusion.Expression,double,double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprAdd.ctor(mosek.fusion.Expression,mosek.fusion.Expression,double,double)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprAdd._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprAdd._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprAdd._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprAdd._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprAdd.eval()\n\tmosek.fusion.ExprAdd.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprAdd._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprAdd._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprAdd.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprAdd: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,m1,m2):
    o = ExprAdd.__new__(ExprAdd)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,m1,m2)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    e1,e2,m1,m2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e1) and __arg_match_Lmosek_4fusion_4Expression_2__(e2) and __arg_match_D__(m1) and __arg_match_D__(m2))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    e1,e2,m1,m2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e2) and __arg_alt_match_D__(m1) and __arg_alt_match_D__(m2))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(self,e1,e2,m1,m2):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,numpy.float64(m1),numpy.float64(m2))
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(self,e1,e2,m1,m2):
   mosek_fusion_BaseExpression._ctor_init__3I(self,e1.getShape())
   (self.__e1) = e1
   (self.__e2) = e2
   (self.__m1) = m1
   (self.__m2) = m2
   if (e1.getND()!=e2.getND()): # src/fusion/ExprAdd.monty:453:12-36
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   for _0 in range(0,e1.getND()):
    if (e1.getDim(_0)!=e2.getDim(_0)): # src/fusion/ExprAdd.monty:456:14-42
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e1.eval(_1,_0,_2)
   self.__e2.eval(_1,_0,_2)
   _1.pop_expr()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.hassp)
   _8=(_1.ptr_base)
   _9=(_1.sp_base)
   _10=(_1.nidxs_base)
   _11=(_1.bfix_base)
   _12=(_1.cof_base)
   _1.pop_expr()
   _13=(_1.nd)
   _14=(_1.shape_base)
   _15=(_1.nelem)
   _16=(_1.nnz)
   _17=(_1.hassp)
   _18=(_1.ptr_base)
   _19=(_1.sp_base)
   _20=(_1.nidxs_base)
   _21=(_1.bfix_base)
   _22=(_1.cof_base)
   _23=(_1.i32)
   _24=(_1.i64)
   _25=(_1.f64)
   if (_13!=_3): # src/fusion/ExprAdd.monty:515:12-22
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   for _26 in range(0,_13):
    if (_23[(_14 + _26)]!=_23[(_4 + _26)]): # src/fusion/ExprAdd.monty:518:14-46
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   if ((not _17) and (not _7)): # src/fusion/ExprAdd.monty:536:12-37
    _27=_15
    _28=(_16 + _6)
    _29=_13
    _0.alloc_expr(_29,_27,_28,False)
    _30=(_0.shape_base)
    _31=(_0.ptr_base)
    _32=(_0.sp_base)
    _33=(_0.nidxs_base)
    _34=(_0.bfix_base)
    _35=(_0.cof_base)
    _36=(_0.i32)
    _37=(_0.i64)
    _38=(_0.f64)
    for _39 in range(0,_29):
     _36[(_30 + _39)] = _23[(_14 + _39)]
    _40=0
    _36[_31] = 0
    for _41 in range(0,_27):
     for _42 in range(_23[(_18 + _41)],_23[((_18 + _41) + 1)]):
      _37[(_33 + _40)] = _24[(_20 + _42)]
      _38[(_35 + _40)] = (_25[(_22 + _42)] * self.__m1)
      _40 += 1
     for _43 in range(_23[(_8 + _41)],_23[((_8 + _41) + 1)]):
      _37[(_33 + _40)] = _24[(_10 + _43)]
      _38[(_35 + _40)] = (_25[(_12 + _43)] * self.__m2)
      _40 += 1
     _36[((_31 + _41) + 1)] = _40
     _38[(_34 + _41)] = ((_25[(_21 + _41)] * self.__m1) + (_25[(_11 + _41)] * self.__m2))
   elif ((not _17) or (not _7)): # src/fusion/ExprAdd.monty:576:16-577:26
    if (not _7): # src/fusion/ExprAdd.monty:578:14-24
     _44=_5
     _45=_6
     _46=_8
     _47=_9
     _48=_10
     _49=_11
     _50=_12
     _5 = _15
     _6 = _16
     _8 = _18
     _9 = _19
     _10 = _20
     _11 = _21
     _12 = _22
     _15 = _44
     _16 = _45
     _18 = _46
     _19 = _47
     _20 = _48
     _21 = _49
     _22 = _50
    _51=((self.__m1) if ((not _17) ) else (self.__m2))
    _52=((self.__m2) if ((not _17) ) else (self.__m1))
    _53=_15
    _54=(_16 + _6)
    _55=_13
    _0.alloc_expr(_55,_53,_54,False)
    _56=(_0.shape_base)
    _57=(_0.ptr_base)
    _58=(_0.sp_base)
    _59=(_0.nidxs_base)
    _60=(_0.bfix_base)
    _61=(_0.cof_base)
    _62=(_0.i32)
    _63=(_0.i64)
    _64=(_0.f64)
    _65=0
    for _66 in range(0,_55):
     _62[(_56 + _66)] = _23[(_14 + _66)]
    for _67 in range(0,(_53 + 1)):
     _62[(_57 + _67)] = 0
    for _68 in range(0,_15):
     _62[((_57 + _68) + 1)] += (_23[((_18 + _68) + 1)] - _23[(_18 + _68)])
    for _69 in range(0,_5):
     _70=_24[(_9 + _69)]
     _62[((_57 + _70) + 1)] += (_23[((_8 + _69) + 1)] - _23[(_8 + _69)])
    for _71 in range(0,_53):
     _62[((_57 + _71) + 1)] += _62[(_57 + _71)]
    for _72 in range(0,_15):
     _73=_62[(_57 + _72)]
     _74=_23[(_18 + _72)]
     _75=(_23[((_18 + _72) + 1)] - _23[(_18 + _72)])
     for _76 in range(0,_75):
      _63[((_59 + _73) + _76)] = _24[((_20 + _74) + _76)]
      _64[((_61 + _73) + _76)] = (_25[((_22 + _74) + _76)] * _51)
     _62[(_57 + _72)] += _75
     _64[(_60 + _72)] = (_25[(_21 + _72)] * _51)
    for _77 in range(0,_5):
     _78=_24[(_9 + _77)]
     _79=_62[(_57 + _78)]
     _80=_23[(_8 + _77)]
     _81=(_23[((_8 + _77) + 1)] - _23[(_8 + _77)])
     for _82 in range(0,_81):
      _63[((_59 + _79) + _82)] = _24[((_10 + _80) + _82)]
      _64[((_61 + _79) + _82)] = (_25[((_12 + _80) + _82)] * _52)
     _62[(_57 + _78)] += _81
     _64[(_60 + _78)] += (_25[(_11 + _77)] * _52)
    for _83 in range(0,_53):
     _62[((_57 + _53) - _83)] = _62[(((_57 + _53) - _83) - 1)]
    _62[_57] = 0
   else:
    _84=(_16 + _6)
    _85=0
    _86=_13
    _87=1
    for _88 in range(0,_86):
     _87 *= _23[(_14 + _88)]
    _89=0
    _90=0
    while ((_90 < _15) and (_89 < _5)):
     if (_24[(_19 + _90)] < _24[(_9 + _89)]): # src/fusion/ExprAdd.monty:704:22-49
      _85 += 1
      _90 += 1
     elif (_24[(_19 + _90)] > _24[(_9 + _89)]): # src/fusion/ExprAdd.monty:705:22-49
      _85 += 1
      _89 += 1
     else:
      _85 += 1
      _90 += 1
      _89 += 1
    _85 += (((_15 - _90) + _5) - _89)
    _91=(_85 < _87)
    _0.alloc_expr(_86,_85,_84,_91)
    _92=(_0.shape_base)
    _93=(_0.ptr_base)
    _94=((_0.sp_base) if (_91 ) else _0.alloci64(_85))
    _95=(_0.nidxs_base)
    _96=(_0.bfix_base)
    _97=(_0.cof_base)
    _98=(_0.i32)
    _99=(_0.i64)
    _100=(_0.f64)
    for _101 in range(0,_86):
     _98[(_92 + _101)] = _23[(_14 + _101)]
    _98[_93] = 0
    _102=0
    _103=0
    _104=0
    _105=0
    while ((_105 < _15) and (_104 < _5)):
     if (_24[(_19 + _105)] < _24[(_9 + _104)]): # src/fusion/ExprAdd.monty:736:18-45
      for _106 in range(_23[(_18 + _105)],_23[((_18 + _105) + 1)]):
       _99[(_95 + _103)] = _24[(_20 + _106)]
       _100[(_97 + _103)] = (self.__m1 * _25[(_22 + _106)])
       _103 += 1
      _100[(_96 + _102)] = (self.__m1 * _25[(_21 + _105)])
      _99[(_94 + _102)] = _24[(_19 + _105)]
      _98[((_93 + _102) + 1)] = _103
      _102 += 1
      _105 += 1
     elif (_24[(_9 + _104)] < _24[(_19 + _105)]): # src/fusion/ExprAdd.monty:748:22-49
      for _107 in range(_23[(_8 + _104)],_23[((_8 + _104) + 1)]):
       _99[(_95 + _103)] = _24[(_10 + _107)]
       _100[(_97 + _103)] = (self.__m2 * _25[(_12 + _107)])
       _103 += 1
      _100[(_96 + _102)] = (self.__m1 * _25[(_11 + _105)])
      _99[(_94 + _102)] = _24[(_9 + _104)]
      _98[((_93 + _102) + 1)] = _103
      _102 += 1
      _104 += 1
     else:
      for _108 in range(_23[(_18 + _105)],_23[((_18 + _105) + 1)]):
       _99[(_95 + _103)] = _24[(_20 + _108)]
       _100[(_97 + _103)] = (self.__m1 * _25[(_22 + _108)])
       _103 += 1
      for _109 in range(_23[(_8 + _104)],_23[((_8 + _104) + 1)]):
       _99[(_95 + _103)] = _24[(_10 + _109)]
       _100[(_97 + _103)] = (self.__m2 * _25[(_12 + _109)])
       _103 += 1
      _100[(_96 + _102)] = ((self.__m1 * _25[(_21 + _105)]) + (self.__m2 * _25[(_11 + _104)]))
      _99[(_94 + _102)] = _24[(_19 + _105)]
      _98[((_93 + _102) + 1)] = _103
      _102 += 1
      _105 += 1
      _104 += 1
    while (_105 < _15):
     for _110 in range(_23[(_18 + _105)],_23[((_18 + _105) + 1)]):
      _99[(_95 + _103)] = _24[(_20 + _110)]
      _100[(_97 + _103)] = (self.__m1 * _25[(_22 + _110)])
      _103 += 1
     _100[(_96 + _102)] = (self.__m1 * _25[(_21 + _105)])
     _99[(_94 + _102)] = _24[(_19 + _105)]
     _98[((_93 + _102) + 1)] = _103
     _102 += 1
     _105 += 1
    while (_104 < _5):
     for _111 in range(_23[(_8 + _104)],_23[((_8 + _104) + 1)]):
      _99[(_95 + _103)] = _24[(_10 + _111)]
      _100[(_97 + _103)] = (self.__m2 * _25[(_12 + _111)])
      _103 += 1
     _100[(_96 + _102)] = (self.__m1 * _25[(_11 + _104)])
     _99[(_94 + _102)] = _24[(_9 + _104)]
     _98[((_93 + _102) + 1)] = _103
     _102 += 1
     _104 += 1
    if (not _91): # src/fusion/ExprAdd.monty:806:14-24
     _0.popi64(_85)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprAdd(")._a_S(self.__e1.toString())._a_S(",")._a_S(self.__e2.toString())._a_S(")")._toString_())
 return ExprAdd
mosek_fusion_ExprAdd=__mk_mosek_fusion_ExprAdd()
del __mk_mosek_fusion_ExprAdd
#BEFORE CLASS
def __mk_mosek_fusion_ExprWSum():
 class ExprWSum(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprWSum__w','_ExprWSum__es']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Expression_2_3D(*args): # []mosek.fusion.Expression,[]double
      self._ctor_init__3Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):# []mosek.fusion.Expression,[]double
      self._ctor_alt_init__3Lmosek_4fusion_4Expression_2_3D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprWSum.ctor(array(mosek.fusion.Expression,ndim=1),array(double,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprWSum._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprWSum._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprWSum._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprWSum._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprWSum.eval()\n\tmosek.fusion.ExprWSum.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprWSum._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprWSum._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprWSum.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprWSum: '+self._toString_()
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Expression_2_3D(es,w):
    o = ExprWSum.__new__(ExprWSum)
    o._ctor_init__3Lmosek_4fusion_4Expression_2_3D(es,w)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    es,w, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(es) and __arg_match__3D__(w))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    es,w, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(es) and __arg_alt_match__3D__(w))
  def _ctor_alt_init__3Lmosek_4fusion_4Expression_2_3D(self,es,w):
    self._ctor_init__3Lmosek_4fusion_4Expression_2_3D(numpy.array(es,dtype=numpy.dtype(object)),numpy.array(w,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3Lmosek_4fusion_4Expression_2_3D(self,es,w):
   assert es is None or isinstance(es,numpy.ndarray)
   assert w is None or isinstance(w,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,es[0].getShape())
   if (int((w).shape[0])!=int((es).shape[0])): # src/fusion/ExprAdd.monty:227:12-29
    raise mosek_fusion_LengthError._ctor_S("Mismatching weights and expressions array lengths")
   (self.__w) = mosek.fusion.Utils.Tools._arraycopy__3D(w)
   _0=es[0].getShape()
   _1=int((_0).shape[0])
   for _2 in range(1,int((es).shape[0])):
    _3=es[_2].getShape()
    if (_1!=int((_3).shape[0])): # src/fusion/ExprAdd.monty:236:14-31
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression shapes")
    else:
     for _4 in range(0,_1):
      if (_0[_4]!=_3[_4]): # src/fusion/ExprAdd.monty:240:18-39
       raise mosek_fusion_DimensionError._ctor_S("Mismatching expression shapes")
   (self.__es) = numpy.array([es[_5] for _5 in range(0,int((es).shape[0]))], dtype=numpy.dtype(object))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__es).shape[0])
   for _4 in range(0,_3):
    self.__es[_4].eval(_1,_0,_2)
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _12=_1.popi32()
   _13=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
   _1.popi32(_12,_13,0)
   _5[(_3 - 1)] = _1.popi32()
   _6[(_3 - 1)] = _1.popi32()
   _14=(_1.popi32()!=0)
   _7[(_3 - 1)] = _1.popi32((_5[(_3 - 1)] + 1))
   _9[(_3 - 1)] = (_1.popi64(_5[(_3 - 1)]) if (_14 ) else (- 1))
   _8[(_3 - 1)] = _1.popi64(_6[(_3 - 1)])
   _11[(_3 - 1)] = _1.popf64(_5[(_3 - 1)])
   _10[(_3 - 1)] = _1.popf64(_6[(_3 - 1)])
   for _15 in range(1,_3):
    _16=((_3 - _15) - 1)
    _1.popi32()
    _1.popi32(_12)
    _5[_16] = _1.popi32()
    _6[_16] = _1.popi32()
    _17=(_1.popi32()!=0)
    _7[_16] = _1.popi32((_5[_16] + 1))
    _9[_16] = (_1.popi64(_5[_16]) if (_17 ) else (- 1))
    _8[_16] = _1.popi64(_6[_16])
    _11[_16] = _1.popf64(_5[_16])
    _10[_16] = _1.popf64(_6[_16])
   _18=(_1.i32)
   _19=(_1.i64)
   _20=(_1.f64)
   _21=False
   for _22 in range(0,_3):
    if (_9[_22] < 0): # src/fusion/ExprAdd.monty:293:53-67
     _21 = True
   _23=0
   _24=0
   if _21: # src/fusion/ExprAdd.monty:297:12-20
    _23 = numpy.int32(mosek.fusion.Set._size__3I(_13))
    for _25 in range(0,_3):
     _24 += _6[_25]
   else:
    _26=False
    _27=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    for _28 in range(0,_3):
     _24 += _6[_28]
    while (not _26):
     _29=(- 1)
     for _30 in range(0,_3):
      if ((_27[_30] < _5[_30]) and ((_29 < 0) or (_19[(_9[_30] + _27[_30])] < _29))): # src/fusion/ExprAdd.monty:310:18-84
       _29 = _19[(_9[_30] + _27[_30])]
     if (_29 < 0): # src/fusion/ExprAdd.monty:312:16-25
      _26 = True
     else:
      for _31 in range(0,_3):
       if ((_27[_31] < _5[_31]) and (_29==_19[(_9[_31] + _27[_31])])): # src/fusion/ExprAdd.monty:316:20-72
        _27[_31] += 1
      _23 += 1
   _32=_0.alloci32((_23 + 1))
   _33=_0.alloci64(_24)
   _34=(_0.alloci64(_23) if ((not _21) ) else (- 1))
   _35=_0.allocf64(_24)
   _36=_0.allocf64(_23)
   _0.pushi32((0 if (_21 ) else 1))
   _0.pushi32(_24)
   _0.pushi32(_23)
   for _37 in range(0,_12):
    _0.pushi32(_13[_37])
   _0.pushi32(_12)
   _38=(_0.i32)
   _39=(_0.i64)
   _40=(_0.f64)
   _38[_32] = 0
   for _41 in range(0,_23):
    _40[(_36 + _41)] = 0.0
   for _42 in range(0,(_23 + 1)):
    _38[(_32 + _42)] = 0
   if _21: # src/fusion/ExprAdd.monty:350:12-20
    for _43 in range(0,_3):
     if (_9[_43] >= 0): # src/fusion/ExprAdd.monty:353:16-31
      for _44 in range(0,_5[_43]):
       _38[((_32 + _19[(_9[_43] + _44)]) + 1)] += (_18[((_7[_43] + _44) + 1)] - _18[(_7[_43] + _44)])
     else:
      for _45 in range(0,_5[_43]):
       _38[((_32 + _45) + 1)] += (_18[((_7[_43] + _45) + 1)] - _18[(_7[_43] + _45)])
    for _46 in range(0,_23):
     _38[((_32 + _46) + 1)] += _38[(_32 + _46)]
    for _47 in range(0,_3):
     if (_9[_47] >= 0): # src/fusion/ExprAdd.monty:369:16-31
      for _48 in range(0,_5[_47]):
       _49=_18[(_7[_47] + _48)]
       _50=_18[((_7[_47] + _48) + 1)]
       _51=_19[(_9[_47] + _48)]
       _52=_38[(_32 + _51)]
       for _53 in range(_49,_50):
        _39[(_33 + _52)] = _19[(_8[_47] + _53)]
        _40[(_35 + _52)] = (self.__w[_47] * _20[(_10[_47] + _53)])
        _52 += 1
       _40[(_36 + _51)] += (self.__w[_47] * _20[(_11[_47] + _48)])
       _38[(_32 + _51)] += (_50 - _49)
     else:
      for _54 in range(0,_5[_47]):
       _55=_18[(_7[_47] + _54)]
       _56=_18[((_7[_47] + _54) + 1)]
       _57=_54
       _58=_38[(_32 + _57)]
       for _59 in range(_55,_56):
        _39[(_33 + _58)] = _19[(_8[_47] + _59)]
        _40[(_35 + _58)] = (self.__w[_47] * _20[(_10[_47] + _59)])
        _58 += 1
       _40[(_36 + _57)] += (self.__w[_47] * _20[(_11[_47] + _54)])
       _38[(_32 + _57)] += (_56 - _55)
    for _60 in range(0,_23):
     _38[((_32 + _23) - _60)] = _38[(((_32 + _23) - _60) - 1)]
    _38[_32] = 0
   else:
    _61=False
    _62=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _63=0
    _64=0
    while (not _61):
     _65=(- 1)
     for _66 in range(0,_3):
      if ((_62[_66] < _5[_66]) and ((_65 < 0) or (_19[(_9[_66] + _62[_66])] < _65))): # src/fusion/ExprAdd.monty:409:35-97
       _65 = _19[(_9[_66] + _62[_66])]
     if (_65 < 0): # src/fusion/ExprAdd.monty:410:16-23
      _61 = True
     else:
      for _67 in range(0,_3):
       if ((_62[_67] < _5[_67]) and (_65==_19[(_9[_67] + _62[_67])])): # src/fusion/ExprAdd.monty:414:20-70
        for _68 in range(_18[(_7[_67] + _62[_67])],_18[((_7[_67] + _62[_67]) + 1)]):
         _39[(_33 + _64)] = _19[(_8[_67] + _68)]
         _40[(_35 + _64)] = (self.__w[_67] * _20[(_10[_67] + _68)])
         _64 += 1
        _40[(_36 + _63)] += (self.__w[_67] * _20[(_11[_67] + _62[_67])])
        _62[_67] += 1
      _38[((_32 + _63) + 1)] = _64
      _39[(_34 + _63)] = _65
     _63 += 1
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprWSum()")
 return ExprWSum
mosek_fusion_ExprWSum=__mk_mosek_fusion_ExprWSum()
del __mk_mosek_fusion_ExprWSum
#BEFORE CLASS
def __mk_mosek_fusion_ExprSumReduce():
 class ExprSumReduce(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSumReduce__dim','_ExprSumReduce__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_ILmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression
      self._ctor_init_ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_ILmosek_4fusion_4Expression_2(*args):# int32,mosek.fusion.Expression
      self._ctor_alt_init_ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSumReduce.ctor(int32,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprSumReduce._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprSumReduce._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprSumReduce._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSumReduce._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSumReduce.eval()\n\tmosek.fusion.ExprSumReduce.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprSumReduce._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprSumReduce._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSumReduce.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprSumReduce: '+self._toString_()
  @staticmethod
  def _ctor_ILmosek_4fusion_4Expression_2(dim,expr):
    o = ExprSumReduce.__new__(ExprSumReduce)
    o._ctor_init_ILmosek_4fusion_4Expression_2(dim,expr)
    return o
  @staticmethod
  def __match_ctor_ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    dim,expr, = args
    return (__arg_match_I__(dim) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    dim,expr, = args
    return (__arg_alt_match_I__(dim) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_ILmosek_4fusion_4Expression_2(self,dim,expr):
    self._ctor_init_ILmosek_4fusion_4Expression_2(numpy.int32(dim),expr)
  def _ctor_init_ILmosek_4fusion_4Expression_2(self,dim,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprSumReduce.__computeShape_I_3I(dim,expr.getShape()))
   (self.__expr) = expr
   (self.__dim) = dim
   _0=expr.getShape()
   if (int((_0).shape[0]) <= dim): # src/fusion/ExprAdd.monty:23:12-29
    raise mosek_fusion_DimensionError._ctor_S("Invalid summing dimension")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_1,_0,_2)
   _1.pop_expr()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.hassp)
   _8=(_1.ptr_base)
   _9=(_1.sp_base)
   _10=(_1.nidxs_base)
   _11=(_1.bfix_base)
   _12=(_1.cof_base)
   _13=(_1.i32)
   _14=(_1.i64)
   _15=(_1.f64)
   _16=99999
   _17=99999
   _18=99999
   if _7: # src/fusion/ExprAdd.monty:50:12-17
    _19=0
    for _20 in range(0,_3):
     if (_19 < _13[(_4 + _20)]): # src/fusion/ExprAdd.monty:52:34-61
      _19 = _13[(_4 + _20)]
    _16 = _2.alloci32((_19 + 1))
    _17 = _2.alloci32(_5)
    _18 = _2.alloci32(_5)
   _21=(_2.i32)
   if _7: # src/fusion/ExprAdd.monty:61:12-17
    _22=_17
    _23=_18
    for _24 in range(0,_5):
     _21[(_22 + _24)] = _24
    if (self.__dim < (_3 - 1)): # src/fusion/ExprAdd.monty:67:14-24
     _25=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
     _25[(_3 - 1)] = 1
     for _26 in range(1,_3):
      _25[((_3 - _26) - 1)] = (_25[(_3 - _26)] * _13[((_4 + _3) - _26)])
     _27=numpy.zeros(((_3 - 1),), dtype=numpy.dtype(numpy.int32))
     for _28 in range(0,self.__dim):
      _27[((_3 - _28) - 2)] = _28
     for _29 in range((self.__dim + 1),_3):
      _27[((_3 - _29) - 1)] = _29
     for _30 in range(0,(_3 - 1)):
      _31=_27[_30]
      _32=_13[(_4 + _31)]
      for _33 in range(0,(_32 + 1)):
       _21[(_16 + _33)] = 0
      for _34 in range(0,_5):
       _21[((_16 + 1) + ((_14[(_9 + _34)] // _25[_31]) % _32))] += 1
      for _35 in range(0,_32):
       _21[((_16 + _35) + 1)] += _21[(_16 + _35)]
      for _36 in range(0,_5):
       _37=_21[(_22 + _36)]
       _38=((_14[(_9 + _37)] // _25[_31]) % _32)
       _21[(_23 + _21[(_16 + _38)])] = _37
       _21[(_16 + _38)] += 1
      _39=_23
      _23 = _22
      _22 = _39
    _40=1
    for _41 in range(0,self.__dim):
     _40 *= _13[(_4 + _41)]
    _42=_13[(_4 + self.__dim)]
    _43=1
    for _44 in range((self.__dim + 1),_3):
     _43 *= _13[(_4 + _44)]
    _45=(_43 * _42)
    _46=_43
    _47=1
    _48=0
    _49=(- 1)
    _50=(- 1)
    for _51 in range(0,_5):
     _52=_21[(_22 + _51)]
     _53=((_14[(_9 + _52)] // _45) % _40)
     _54=(_14[(_9 + _52)] % _43)
     if ((_50!=_53) or (_49!=_54)): # src/fusion/ExprAdd.monty:101:16-36
      _50 = _53
      _49 = _54
      _48 += 1
    _55=(_3 - 1)
    _56=(_48 < (_40 * _43))
    _57=_6
    _0.alloc_expr(_55,_48,_57,_56)
    _58=(_0.ptr_base)
    _59=(_0.nidxs_base)
    _60=((_0.sp_base) if (_56 ) else _0.alloci64(_48))
    _61=(_0.cof_base)
    _62=(_0.bfix_base)
    _63=(_0.shape_base)
    _64=(_0.i32)
    _65=(_0.i64)
    _66=(_0.f64)
    for _67 in range(0,self.__dim):
     _64[(_63 + _67)] = _13[(_4 + _67)]
    for _68 in range((self.__dim + 1),_3):
     _64[((_63 + _68) - 1)] = _13[(_4 + _68)]
    _64[_58] = 0
    _69=0
    _70=0
    _71=0
    while (_71 < _5):
     _72=_71
     _73=((_14[(_9 + _21[(_22 + _72)])] // _45) % _40)
     _74=(_14[(_9 + _21[(_22 + _72)])] % _43)
     _71 += 1
     while ((_71 < _5) and ((_73==((_14[(_9 + _21[(_22 + _71)])] // _45) % _40)) and (_74==(_14[(_9 + _21[(_22 + _71)])] % _43)))):
      _71 += 1
     _75=0.0
     for _76 in range(_72,_71):
      _77=_21[(_22 + _76)]
      for _78 in range(_13[(_8 + _77)],_13[((_8 + _77) + 1)]):
       _65[(_59 + _70)] = _14[(_10 + _78)]
       _66[(_61 + _70)] = _15[(_12 + _78)]
       _70 += 1
      _75 += _15[(_11 + _77)]
     _65[(_60 + _69)] = ((_73 * _43) + _74)
     _64[((_58 + _69) + 1)] = _70
     _66[(_62 + _69)] = _75
     _69 += 1
    if (not _56): # src/fusion/ExprAdd.monty:157:14-24
     _0.popi64(_48)
   else:
    _79=1
    for _80 in range(0,self.__dim):
     _79 *= _13[(_4 + _80)]
    _81=_13[(_4 + self.__dim)]
    _82=1
    for _83 in range((self.__dim + 1),_3):
     _82 *= _13[(_4 + _83)]
    _84=(_82 * _81)
    _85=_82
    _86=1
    _87=(_79 * _82)
    _88=_0.alloci32((_87 + 1))
    _89=_0.alloci64(_6)
    _90=_0.allocf64(_6)
    _91=_0.allocf64(_87)
    _0.pushi32(0)
    _0.pushi32(_6)
    _0.pushi32(_87)
    _92=_0.alloci32((_3 - 1))
    _0.pushi32((_3 - 1))
    _93=(_0.i32)
    _94=(_0.i64)
    _95=(_0.f64)
    for _96 in range(0,self.__dim):
     _93[(_92 + _96)] = _13[(_4 + _96)]
    for _97 in range((self.__dim + 1),_3):
     _93[((_92 + _97) - 1)] = _13[(_4 + _97)]
    _98=0
    _99=0
    _93[_88] = 0
    for _100 in range(0,_79):
     for _101 in range(0,_82):
      _102=0.0
      for _103 in range(0,_81):
       _104=(((_100 * _84) + (_103 * _85)) + _101)
       for _105 in range(_13[(_8 + _104)],_13[((_8 + _104) + 1)]):
        _94[(_89 + _99)] = _14[(_10 + _105)]
        _95[(_90 + _99)] = _15[(_12 + _105)]
        _99 += 1
       _102 += _15[(_11 + _104)]
      _93[((_88 + _98) + 1)] = _99
      _95[(_91 + _98)] = _102
      _98 += 1
   _2.clear()
  @staticmethod
  def __computeShape_alt_I_3I(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprSumReduce.__computeShape_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeShape_I_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.zeros(((int((_1).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
   for _3 in range(0,_0):
    _2[_3] = _1[_3]
   for _4 in range((_0 + 1),int((_1).shape[0])):
    _2[(_4 - 1)] = _1[_4]
   return (_2)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprSumReduce()")
 return ExprSumReduce
mosek_fusion_ExprSumReduce=__mk_mosek_fusion_ExprSumReduce()
del __mk_mosek_fusion_ExprSumReduce
#BEFORE CLASS
def __mk_mosek_fusion_ExprDenseTril():
 class ExprDenseTril(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDenseTril__dim1','_ExprDenseTril__dim0','_ExprDenseTril__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2(*args): # int32,int32,mosek.fusion.Expression
      self._ctor_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):# int32,int32,mosek.fusion.Expression
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2I(*args): # int32,int32,mosek.fusion.Expression,int32
      self._ctor_init_IILmosek_4fusion_4Expression_2I(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):# int32,int32,mosek.fusion.Expression,int32
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDenseTril.ctor(int32,int32,mosek.fusion.Expression)\n\tmosek.fusion.ExprDenseTril.ctor(int32,int32,mosek.fusion.Expression,int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprDenseTril._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprDenseTril._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprDenseTril._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDenseTril._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDenseTril.eval()\n\tmosek.fusion.ExprDenseTril.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprDenseTril'
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_):
    o = ExprDenseTril.__new__(ExprDenseTril)
    o._ctor_init_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
    self._ctor_init_IILmosek_4fusion_4Expression_2I(numpy.int32(dim0),numpy.int32(dim1),expr,numpy.int32(unchecked_))
  def _ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr.getShape())
   (self.__expr) = expr
   (self.__dim0) = dim0
   (self.__dim1) = dim1
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr):
    o = ExprDenseTril.__new__(ExprDenseTril)
    o._ctor_init_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_match_I__(dim0_) and __arg_match_I__(dim1_) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_alt_match_I__(dim0_) and __arg_alt_match_I__(dim1_) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
    self._ctor_init_IILmosek_4fusion_4Expression_2(numpy.int32(dim0_),numpy.int32(dim1_),expr)
  def _ctor_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
   mosek_fusion_ExprDenseTril._ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0_,dim1_,expr,1)
   _0=expr.getShape()
   if ((self.__dim0==self.__dim1) or ((self.__dim0 < 0) or ((self.__dim0 >= int((_0).shape[0])) or ((self.__dim1 < 0) or ((self.__dim1 >= int((_0).shape[0])) or (_0[self.__dim0]!=_0[self.__dim1])))))): # src/fusion/ExprShape.monty:1012:12-1017:38
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension definitions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_1,_0,_2)
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(self.__dim0 if ((self.__dim0 < self.__dim1) ) else self.__dim1)
   _7=(self.__dim0 if ((self.__dim0 > self.__dim1) ) else self.__dim1)
   _8=(self.__dim0 < self.__dim1)
   _9=_1.popi32()
   _10=_1.popi32(_9)
   _11=_1.popi32()
   _12=_1.popi32()
   _13=(_1.popi32()!=0)
   _14=_1.popi32((_11 + 1))
   _15=(_1.popi64(_11) if (_13 ) else (- 1))
   _16=_1.popi64(_12)
   _17=_1.popf64(_11)
   _18=_1.popf64(_12)
   _19=numpy.array([1 for _20 in range(0,5)], dtype=numpy.dtype(numpy.int32))
   for _21 in range(0,_6):
    _19[0] *= _3[(_10 + _21)]
   _19[1] = _3[(_10 + _6)]
   for _22 in range((_6 + 1),_7):
    _19[2] *= _3[(_10 + _22)]
   _19[3] = _3[(_10 + _7)]
   for _23 in range((_7 + 1),_9):
    _19[4] *= _3[(_10 + _23)]
   _24=numpy.zeros((5,), dtype=numpy.dtype(numpy.int32))
   _24[4] = 1
   for _25 in range(1,5):
    _24[((5 - _25) - 1)] = (_24[(5 - _25)] * _19[(5 - _25)])
   _26=0
   _27=0
   if _13: # src/fusion/ExprShape.monty:1067:14-19
    if _8: # src/fusion/ExprShape.monty:1068:16-20
     for _28 in range(0,_11):
      _29=((_4[(_15 + _28)] // _24[1]) % _19[1])
      _30=((_4[(_15 + _28)] // _24[3]) % _19[3])
      if (_29 >= _30): # src/fusion/ExprShape.monty:1072:20-32
       _26 += (_3[((_14 + _28) + 1)] - _3[(_14 + _28)])
       _27 += 1
    else:
     for _31 in range(0,_11):
      _32=((_4[(_15 + _31)] // _24[1]) % _19[1])
      _33=((_4[(_15 + _31)] // _24[3]) % _19[3])
      if (_32 <= _33): # src/fusion/ExprShape.monty:1081:20-32
       _26 += (_3[((_14 + _31) + 1)] - _3[(_14 + _31)])
       _27 += 1
   else:
    _27 = (((_19[0] * _19[2]) * _19[4]) * ((_19[1] * (_19[1] + 1)) // 2))
    if _8: # src/fusion/ExprShape.monty:1089:16-20
     for _34 in range(0,_19[0]):
      for _35 in range(0,_19[1]):
       for _36 in range(0,_19[2]):
        for _37 in range(0,(_35 + 1)):
         for _38 in range(0,_19[4]):
          _39=(((((_34 * _24[0]) + (_35 * _24[1])) + (_36 * _24[2])) + (_37 * _24[3])) + (_38 * _24[4]))
          _26 += (_3[((_14 + _39) + 1)] - _3[(_14 + _39)])
    else:
     for _40 in range(0,_19[0]):
      for _41 in range(0,_19[1]):
       for _42 in range(0,_19[2]):
        for _43 in range(_41,_19[3]):
         for _44 in range(0,_19[4]):
          _45=(((((_40 * _24[0]) + (_41 * _24[1])) + (_42 * _24[2])) + (_43 * _24[3])) + (_44 * _24[4]))
          _26 += (_3[((_14 + _45) + 1)] - _3[(_14 + _45)])
   _46=(((((_19[0] * _19[2]) * _19[4]) * _19[1]) * (_19[1] + 1)) // 2)
   _47=_0.alloci32((_46 + 1))
   _0.pushi32(1)
   _0.pushi32(_26)
   _0.pushi32(_46)
   for _48 in range(0,_9):
    _0.pushi32(_3[(_10 + _48)])
   _0.pushi32(_9)
   _49=_0.alloci64(_26)
   _50=_0.alloci64(_46)
   _51=_0.allocf64(_26)
   _52=_0.allocf64(_46)
   _53=(_0.i32)
   _54=(_0.i64)
   _55=(_0.f64)
   _53[_47] = 0
   if _8: # src/fusion/ExprShape.monty:1131:12-16
    _56=0
    for _57 in range(0,_19[0]):
     for _58 in range(0,_19[1]):
      for _59 in range(0,_19[2]):
       for _60 in range(0,(_58 + 1)):
        for _61 in range(0,_19[4]):
         _54[(_50 + _56)] = (((((_57 * _24[0]) + (_58 * _24[1])) + (_59 * _24[2])) + (_60 * _24[3])) + (_61 * _24[4]))
         _56 += 1
   else:
    _62=0
    for _63 in range(0,_19[0]):
     for _64 in range(0,_19[1]):
      for _65 in range(0,_19[2]):
       for _66 in range(_64,_19[3]):
        for _67 in range(0,_19[4]):
         _54[(_50 + _62)] = (((((_63 * _24[0]) + (_64 * _24[1])) + (_65 * _24[2])) + (_66 * _24[3])) + (_67 * _24[4]))
         _62 += 1
   _68=0
   if _13: # src/fusion/ExprShape.monty:1157:14-19
    _69=0
    _70=0
    while ((_70 < _11) and (_69 < _46)):
     if (_4[(_15 + _70)] < _54[(_50 + _69)]): # src/fusion/ExprShape.monty:1161:22-58
      _70 += 1
     elif (_4[(_15 + _70)] > _54[(_50 + _69)]): # src/fusion/ExprShape.monty:1163:22-58
      _55[(_52 + _69)] = 0.0
      _53[((_47 + _69) + 1)] = _68
      _69 += 1
     else:
      for _71 in range(_3[(_14 + _70)],_3[((_14 + _70) + 1)]):
       _54[(_49 + _68)] = _4[(_16 + _71)]
       _55[(_51 + _68)] = _5[(_18 + _71)]
       _68 += 1
      _55[(_52 + _69)] = _5[(_17 + _70)]
      _53[((_47 + _69) + 1)] = _68
      _70 += 1
      _69 += 1
    while (_69 < _46):
     _53[((_47 + _69) + 1)] = _68
     _55[(_52 + _69)] = 0.0
     _69 += 1
   else:
    for _72 in range(0,_46):
     _73=_54[(_50 + _72)]
     _55[(_52 + _72)] = _5[(_17 + _73)]
     for _74 in range(_3[(_14 + _73)],_3[((_14 + _73) + 1)]):
      _54[(_49 + _68)] = _4[(_16 + _74)]
      _55[(_51 + _68)] = _5[(_18 + _74)]
      _68 += 1
     _53[((_47 + _72) + 1)] = _68
 return ExprDenseTril
mosek_fusion_ExprDenseTril=__mk_mosek_fusion_ExprDenseTril()
del __mk_mosek_fusion_ExprDenseTril
#BEFORE CLASS
def __mk_mosek_fusion_ExprDense():
 class ExprDense(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDense__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDense.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprDense._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprDense._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprDense._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDense._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDense.eval()\n\tmosek.fusion.ExprDense.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprDense._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprDense._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDense.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprDense: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprDense.__new__(ExprDense)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr.getShape())
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_0,_1,_2)
   _0.peek_expr()
   if (_0.hassp): # src/fusion/ExprShape.monty:896:12-20
    _3=(_0.nd)
    _4=(_0.nnz)
    _5=(_0.nelem)
    _6=(_0.sp_base)
    _7=numpy.array([(_0.i32)[((_0.shape_base) + _8)] for _8 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
    _9=numpy.int32(mosek.fusion.Set._size__3I(_7))
    _0.popi32((4 + _3))
    if (_9==_5): # src/fusion/ExprShape.monty:906:14-29
     _0.popi64(_5)
     _0.pushi32(0)
     _0.pushi32(_4)
     _0.pushi32(_5)
     _10=_0.alloci32(_3)
     for _11 in range(0,_3):
      (_0.i32)[(_10 + _11)] = _7[_11]
     _0.pushi32(_3)
     _0.peek_expr()
    else:
     _12=_2.alloci32((_9 + 1))
     _13=_2.allocf64(_9)
     _14=(_2.i32)
     _15=(_2.f64)
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.f64),(_0.bfix_base),_15,_13,_5)
     mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.i32),(_0.ptr_base),_14,_12,(_5 + 1))
     _0.popi32((_5 + 1))
     _0.popf64(_5)
     _16=_0.alloci32((_9 + 1))
     _17=_0.allocf64(_9)
     _18=(_0.i32)
     _19=(_0.i64)
     _20=(_0.f64)
     _18[_16] = 0
     _21=0
     if (_5 > 0): # src/fusion/ExprShape.monty:948:18-27
      for _22 in range(0,_9):
       if ((_21 < _5) and (_19[(_6 + _21)]==_22)): # src/fusion/ExprShape.monty:950:22-51
        _20[(_17 + _22)] = _15[(_13 + _21)]
        _21 += 1
       else:
        _20[(_17 + _22)] = 0
       _18[((_16 + _22) + 1)] = _14[(_12 + _21)]
     else:
      for _23 in range(0,_9):
       _20[(_17 + _23)] = 0
       _18[((_16 + _23) + 1)] = 0
     _0.popi64(_5)
     _0.pushi32(0)
     _0.pushi32(_4)
     _0.pushi32(_9)
     for _24 in range(0,_3):
      _0.pushi32(_7[_24])
     _0.pushi32(_3)
     if ((_0.i32)[(_16 + _9)]!=_4): # src/fusion/ExprShape.monty:976:16-41
      raise mosek_fusion_FatalError._ctor_S("Internal: Mismatching ptr and nnz")
    _0.peek_expr()
   _2.clear()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprDense(")._a_S(self.__expr.toString())._a_S(")")._toString_())
 return ExprDense
mosek_fusion_ExprDense=__mk_mosek_fusion_ExprDense()
del __mk_mosek_fusion_ExprDense
#BEFORE CLASS
def __mk_mosek_fusion_ExprSymmetrize():
 class ExprSymmetrize(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSymmetrize__dim1','_ExprSymmetrize__dim0','_ExprSymmetrize__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2(*args): # int32,int32,mosek.fusion.Expression
      self._ctor_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):# int32,int32,mosek.fusion.Expression
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2I(*args): # int32,int32,mosek.fusion.Expression,int32
      self._ctor_init_IILmosek_4fusion_4Expression_2I(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):# int32,int32,mosek.fusion.Expression,int32
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSymmetrize.ctor(int32,int32,mosek.fusion.Expression)\n\tmosek.fusion.ExprSymmetrize.ctor(int32,int32,mosek.fusion.Expression,int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprSymmetrize._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprSymmetrize._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprSymmetrize._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSymmetrize._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSymmetrize.eval()\n\tmosek.fusion.ExprSymmetrize.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprSymmetrize'
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_):
    o = ExprSymmetrize.__new__(ExprSymmetrize)
    o._ctor_init_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
    self._ctor_init_IILmosek_4fusion_4Expression_2I(numpy.int32(dim0),numpy.int32(dim1),expr,numpy.int32(unchecked_))
  def _ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr.getShape())
   (self.__expr) = expr
   if (dim0 < dim1): # src/fusion/ExprShape.monty:549:12-23
    (self.__dim0) = dim0
    (self.__dim1) = dim1
   else:
    (self.__dim0) = dim1
    (self.__dim1) = dim0
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr):
    o = ExprSymmetrize.__new__(ExprSymmetrize)
    o._ctor_init_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_match_I__(dim0_) and __arg_match_I__(dim1_) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_alt_match_I__(dim0_) and __arg_alt_match_I__(dim1_) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
    self._ctor_init_IILmosek_4fusion_4Expression_2(numpy.int32(dim0_),numpy.int32(dim1_),expr)
  def _ctor_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
   mosek_fusion_ExprSymmetrize._ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0_,dim1_,expr,1)
   _0=expr.getShape()
   if ((self.__dim0 < 0) or ((self.__dim0==self.__dim1) or ((self.__dim1 >= int((_0).shape[0])) or (_0[self.__dim0]!=_0[self.__dim1])))): # src/fusion/ExprShape.monty:540:12-88
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension definitions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_1,_0,_2)
   _3=0
   _4=_1.peeki32()
   _5=_1.peeki32((_4 + 3))
   _6=_1.peeki32((_4 + 2))
   for _7 in range(0,_4):
    _8=_1.peeki32((_7 + 1))
    if (_8 > _3): # src/fusion/ExprShape.monty:568:14-24
     _8 = _3
   _9=_1.alloci32(_6)
   _10=_1.alloci32(_6)
   _11=_1.alloci32((_3 + 1))
   _12=_1.alloci64(_6)
   _1.popi32((((2 * _6) + _3) + 1))
   _1.popi64(_6)
   _13=_1.popi32()
   _14=_1.popi32(_13)
   _15=_1.popi32()
   _16=_1.popi32()
   _17=(_1.popi32()!=0)
   _18=_1.popi32((_15 + 1))
   _19=(_1.popi64(_15) if (_17 ) else (- 1))
   _20=_1.popi64(_16)
   _21=_1.popf64(_15)
   _22=_1.popf64(_16)
   _23=0
   _24=0
   _25=numpy.array([1 for _26 in range(0,5)], dtype=numpy.dtype(numpy.int32))
   _27=numpy.zeros((5,), dtype=numpy.dtype(numpy.int64))
   _28=(_1.i32)
   _29=(_1.i64)
   _30=(_1.f64)
   for _31 in range(0,self.__dim0):
    _25[0] *= _28[(_14 + _31)]
   _25[1] = _28[(_14 + self.__dim0)]
   for _32 in range((self.__dim0 + 1),self.__dim1):
    _25[2] *= _28[(_14 + _32)]
   _25[3] = _28[(_14 + self.__dim1)]
   for _33 in range((self.__dim1 + 1),_13):
    _25[4] *= _28[(_14 + _33)]
   _27[4] = 1
   for _34 in range(1,5):
    _27[((5 - _34) - 1)] = (_27[(5 - _34)] * _25[(5 - _34)])
   if _17: # src/fusion/ExprShape.monty:611:12-17
    _35=_9
    for _36 in range(0,_15):
     _28[(_35 + _36)] = _36
    _37=_10
    _38=numpy.array([1,2,3,0], dtype=numpy.dtype(numpy.int32))
    for _39 in range(0,4):
     _40=_27[_38[_39]]
     _41=_25[_38[_39]]
     if (_41 > 1): # src/fusion/ExprShape.monty:620:16-21
      for _42 in range(0,(_41 + 1)):
       _28[(_11 + _42)] = 0
      for _43 in range(0,_15):
       _28[((_11 + ((_29[(_19 + _28[(_35 + _43)])] // _40) % _41)) + 1)] += 1
      for _44 in range(0,_25[3]):
       _28[((_11 + _44) + 1)] += _28[(_11 + _44)]
      for _45 in range(0,_15):
       _46=_28[(_35 + _45)]
       _47=((_29[(_19 + _46)] // _40) % _41)
       _28[(_37 + _28[(_11 + _47)])] = _46
       _28[(_11 + _47)] += 1
      _48=_35
      _35 = _37
      _37 = _48
    for _49 in range(0,_15):
     _29[(_12 + _49)] = (((((((_29[(_19 + _49)] // _27[0]) % _25[0]) * _27[0]) + (((_29[(_19 + _49)] // _27[1]) % _25[1]) * _27[3])) + (((_29[(_19 + _49)] // _27[2]) % _25[2]) * _27[2])) + (((_29[(_19 + _49)] // _27[3]) % _25[3]) * _27[1])) + (((_29[(_19 + _49)] // _27[4]) % _25[4]) * _27[4]))
    _50=0
    _51=0
    while ((_51 < _15) and (_50 < _15)):
     _52=_28[(_35 + _50)]
     if (_29[(_19 + _51)] < _29[(_12 + _52)]): # src/fusion/ExprShape.monty:653:22-53
      _24 += (_28[((_18 + _51) + 1)] - _28[(_18 + _51)])
      _23 += 1
      _51 += 1
     elif (_29[(_19 + _51)] > _29[(_12 + _52)]): # src/fusion/ExprShape.monty:658:22-53
      _24 += (_28[((_18 + _52) + 1)] - _28[(_18 + _52)])
      _23 += 1
      _50 += 1
     elif (_29[(_19 + _51)]!=_29[(_19 + _52)]): # src/fusion/ExprShape.monty:663:22-58
      _24 += (_28[((_18 + _51) + 1)] - _28[(_18 + _51)])
      _24 += (_28[((_18 + _52) + 1)] - _28[(_18 + _52)])
      _23 += 1
      _50 += 1
      _51 += 1
     else:
      _24 += (_28[((_18 + _51) + 1)] - _28[(_18 + _51)])
      _23 += 1
      _50 += 1
      _51 += 1
    while (_51 < _15):
     _24 += (_28[((_18 + _51) + 1)] - _28[(_18 + _51)])
     _23 += 1
     _51 += 1
    while (_50 < _15):
     _53=_28[(_35 + _50)]
     _24 += (_28[((_18 + _53) + 1)] - _28[(_18 + _53)])
     _23 += 1
     _50 += 1
    _54=_0.alloci32((_23 + 1))
    _0.pushi32(1)
    _0.pushi32(_24)
    _0.pushi32(_23)
    for _55 in range(0,_13):
     _0.pushi32(_28[(_14 + _55)])
    _0.pushi32(_13)
    _56=_0.alloci64(_24)
    _57=_0.alloci64(_23)
    _58=_0.allocf64(_24)
    _59=_0.allocf64(_23)
    _60=(_0.i32)
    _61=(_0.i64)
    _62=(_0.f64)
    _60[_54] = 0
    _63=0
    _64=0
    _65=0
    _66=0
    _28[_54] = 0
    while ((_66 < _15) and (_65 < _15)):
     _67=_28[(_35 + _65)]
     if (_29[(_19 + _66)] < _29[(_12 + _67)]): # src/fusion/ExprShape.monty:712:22-53
      for _68 in range(_28[(_18 + _66)],_28[((_18 + _66) + 1)]):
       _61[(_56 + _63)] = _29[(_20 + _68)]
       _62[(_58 + _63)] = (_30[(_22 + _68)] * 0.5)
       _63 += 1
      _62[(_59 + _64)] = (_30[(_21 + _66)] * 0.5)
      _61[(_57 + _64)] = _29[(_19 + _66)]
      _60[((_54 + _64) + 1)] = _63
      _64 += 1
      _66 += 1
     elif (_29[(_19 + _66)] > _29[(_12 + _67)]): # src/fusion/ExprShape.monty:725:22-53
      for _69 in range(_28[(_18 + _67)],_28[((_18 + _67) + 1)]):
       _61[(_56 + _63)] = _29[(_20 + _69)]
       _62[(_58 + _63)] = (_30[(_22 + _69)] * 0.5)
       _63 += 1
      _62[(_59 + _64)] = (_30[(_21 + _67)] * 0.5)
      _61[(_57 + _64)] = _29[(_12 + _67)]
      _60[((_54 + _64) + 1)] = _63
      _64 += 1
      _65 += 1
     elif (_29[(_19 + _66)]!=_29[(_19 + _67)]): # src/fusion/ExprShape.monty:738:22-58
      for _70 in range(_28[(_18 + _66)],_28[((_18 + _66) + 1)]):
       _61[(_56 + _63)] = _29[(_20 + _70)]
       _62[(_58 + _63)] = (_30[(_22 + _70)] * 0.5)
       _63 += 1
      for _71 in range(_28[(_18 + _67)],_28[((_18 + _67) + 1)]):
       _61[(_56 + _63)] = _29[(_20 + _71)]
       _62[(_58 + _63)] = (_30[(_22 + _71)] * 0.5)
       _63 += 1
      _62[(_59 + _64)] = (0.5 * (_30[(_21 + _66)] + _30[(_21 + _67)]))
      _61[(_57 + _64)] = _29[(_19 + _66)]
      _60[((_54 + _64) + 1)] = _63
      _64 += 1
      _65 += 1
      _66 += 1
     else:
      for _72 in range(_28[(_18 + _66)],_28[((_18 + _66) + 1)]):
       _61[(_56 + _63)] = _29[(_20 + _72)]
       _62[(_58 + _63)] = _30[(_22 + _72)]
       _63 += 1
      _62[(_59 + _64)] = _30[(_21 + _66)]
      _61[(_57 + _64)] = _29[(_19 + _66)]
      _60[((_54 + _64) + 1)] = _63
      _64 += 1
      _65 += 1
      _66 += 1
    while (_66 < _15):
     for _73 in range(_28[(_18 + _66)],_28[((_18 + _66) + 1)]):
      _61[(_56 + _63)] = _29[(_20 + _73)]
      _62[(_58 + _63)] = (_30[(_22 + _73)] * 0.5)
      _63 += 1
     _62[(_59 + _64)] = (_30[(_21 + _66)] * 0.5)
     _61[(_57 + _64)] = _29[(_19 + _66)]
     _60[((_54 + _64) + 1)] = _63
     _64 += 1
     _66 += 1
    while (_65 < _15):
     _74=_28[(_35 + _65)]
     for _75 in range(_28[(_18 + _74)],_28[((_18 + _74) + 1)]):
      _61[(_56 + _63)] = _29[(_20 + _75)]
      _62[(_58 + _63)] = (_30[(_22 + _75)] * 0.5)
      _63 += 1
     _62[(_59 + _64)] = (_30[(_21 + _74)] * 0.5)
     _61[(_57 + _64)] = _29[(_12 + _74)]
     _60[((_54 + _64) + 1)] = _63
     _64 += 1
     _65 += 1
   else:
    _23 = _15
    _24 = (_16 * 2)
    for _76 in range(0,_25[0]):
     for _77 in range(0,_25[2]):
      for _78 in range(0,_25[4]):
       for _79 in range(0,_25[1]):
        _80=(((((_27[0] * _76) + (_27[1] * _79)) + (_27[2] * _77)) + (_27[3] * _79)) + (_27[4] * _78))
        _24 -= (_28[((_18 + _80) + 1)] - _28[(_18 + _80)])
    _81=_0.alloci32((_23 + 1))
    _0.pushi32(0)
    _0.pushi32(_24)
    _0.pushi32(_23)
    for _82 in range(0,_13):
     _0.pushi32(_28[(_14 + _82)])
    _0.pushi32(_13)
    _83=_0.alloci64(_24)
    _84=_0.allocf64(_24)
    _85=_0.allocf64(_23)
    _86=(_0.i32)
    _87=(_0.i64)
    _88=(_0.f64)
    _89=0
    _90=0
    _86[_81] = 0
    _91=0
    for _92 in range(0,_25[0]):
     for _93 in range(0,_25[1]):
      for _94 in range(0,_25[2]):
       for _95 in range(0,_25[3]):
        for _96 in range(0,_25[4]):
         if (_93==_95): # src/fusion/ExprShape.monty:838:24-32
          for _97 in range(_28[(_18 + _91)],_28[((_18 + _91) + 1)]):
           _87[(_83 + _89)] = _29[(_20 + _97)]
           _88[(_84 + _89)] = _30[(_22 + _97)]
           _89 += 1
          _88[(_85 + _90)] = _30[(_21 + _92)]
          _86[((_81 + _90) + 1)] = _89
          _91 += 1
         else:
          _98=(((((_92 * _27[0]) + (_95 * _27[1])) + (_94 * _27[2])) + (_93 * _27[3])) + _96)
          for _99 in range(_28[(_18 + _91)],_28[((_18 + _91) + 1)]):
           _87[(_83 + _89)] = _29[(_20 + _99)]
           _88[(_84 + _89)] = (_30[(_22 + _99)] * 0.5)
           _89 += 1
          for _100 in range(_28[(_18 + _98)],_28[((_18 + _98) + 1)]):
           _87[(_83 + _89)] = _29[(_20 + _100)]
           _88[(_84 + _89)] = (_30[(_22 + _100)] * 0.5)
           _89 += 1
          _88[(_85 + _90)] = (0.5 * (_30[(_21 + _91)] + _30[(_21 + _98)]))
          _86[((_81 + _90) + 1)] = _89
          _91 += 1
         _90 += 1
 return ExprSymmetrize
mosek_fusion_ExprSymmetrize=__mk_mosek_fusion_ExprSymmetrize()
del __mk_mosek_fusion_ExprSymmetrize
#BEFORE CLASS
def __mk_mosek_fusion_ExprCompress():
 class ExprCompress(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprCompress__eps','_ExprCompress__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      self._ctor_init_Lmosek_4fusion_4Expression_2D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2D(*args):# mosek.fusion.Expression,double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprCompress.ctor(mosek.fusion.Expression)\n\tmosek.fusion.ExprCompress.ctor(mosek.fusion.Expression,double)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprCompress._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprCompress._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCompress._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.eval()\n\tmosek.fusion.ExprCompress.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  @staticmethod
  def arg_sort(*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32
      return mosek_fusion_ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args)
    elif mosek_fusion_ExprCompress._match_alt_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32
      return mosek_fusion_ExprCompress._arg_1sort_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args)
    else:
      raise ValueError('Invalid argument list arg_sort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.arg_sort(mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32)')
  @staticmethod
  def merge_sort(*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_merge_1sort_IIIIII_3I_3J(*args): # int32,int32,int32,int32,int32,int32,[]int32,[]int64
      return mosek_fusion_ExprCompress._merge_1sort_IIIIII_3I_3J(*args)
    elif mosek_fusion_ExprCompress._match_alt_merge_1sort_IIIIII_3I_3J(*args): # int32,int32,int32,int32,int32,int32,[]int32,[]int64
      return mosek_fusion_ExprCompress._merge_1sort_alt_IIIIII_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list merge_sort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.merge_sort(int32,int32,int32,int32,int32,int32,array(int32,ndim=1),array(int64,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprCompress._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprCompress: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprCompress.__new__(ExprCompress)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr.getShape())
   self.__eps = 0.0
   (self.__expr) = expr
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2D(expr,epsilon):
    o = ExprCompress.__new__(ExprCompress)
    o._ctor_init_Lmosek_4fusion_4Expression_2D(expr,epsilon)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    expr,epsilon, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_D__(epsilon))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    expr,epsilon, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_D__(epsilon))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2D(self,expr,epsilon):
    self._ctor_init_Lmosek_4fusion_4Expression_2D(expr,numpy.float64(epsilon))
  def _ctor_init_Lmosek_4fusion_4Expression_2D(self,expr,epsilon):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr.getShape())
   self.__eps = epsilon
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_1,_0,_2)
   _1.pop_expr()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.hassp)
   _8=(_1.ptr_base)
   _9=(_1.sp_base)
   _10=(_1.nidxs_base)
   _11=(_1.bfix_base)
   _12=(_1.cof_base)
   _13=(_1.i32)
   _14=(_1.i64)
   _15=(_1.f64)
   _16=numpy.array([_13[(_4 + _17)] for _17 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
   _18=True
   for _19 in range(0,_5):
    for _20 in range((_13[(_8 + _19)] + 1),_13[((_8 + _19) + 1)]):
     _18 = (_18 and (_14[((_10 + _20) - 1)] < _14[(_10 + _20)]))
   if _18: # src/fusion/ExprShape.monty:398:14-23
    for _21 in range(0,_6):
     _18 = (_18 and ((_15[(_12 + _21)] <= (0.0 - self.__eps)) or ((0.0 + self.__eps) <= _15[(_12 + _21)])))
   if _18: # src/fusion/ExprShape.monty:403:12-21
    _0.alloc_expr(_3,_5,_6,_7)
    _22=(_0.ptr_base)
    _23=(_0.nidxs_base)
    _24=(_0.sp_base)
    _25=(_0.cof_base)
    _26=(_0.bfix_base)
    _27=(_0.shape_base)
    _28=(_0.i32)
    _29=(_0.i64)
    _30=(_0.f64)
    for _31 in range(0,_3):
     _28[(_27 + _31)] = _16[_31]
    for _32 in range(0,(_5 + 1)):
     _28[(_22 + _32)] = _13[(_8 + _32)]
    if _7: # src/fusion/ExprShape.monty:423:16-21
     for _33 in range(0,_5):
      _29[(_24 + _33)] = _14[(_9 + _33)]
    for _34 in range(0,_5):
     _30[(_26 + _34)] = _15[(_11 + _34)]
    for _35 in range(0,_6):
     _29[(_23 + _35)] = _14[(_10 + _35)]
    for _36 in range(0,_6):
     _30[(_25 + _36)] = _15[(_12 + _36)]
   else:
    _37=_2.alloci32(_6)
    mosek.fusion.ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_1,_2,_37,_5,_6,_8,_10)
    _38=(_2.i32)
    _39=0
    _40=(_0.i32)
    for _41 in range(0,_5):
     _42=_13[((_8 + _41) + 1)]
     _43=_13[(_8 + _41)]
     if (_43 < _42): # src/fusion/ExprShape.monty:452:20-27
      _44=_43
      while (_44 < _42):
       _45=0.0
       _46=_14[(_10 + _38[(_37 + _44)])]
       while ((_44 < _42) and (_14[(_10 + _38[(_37 + _44)])]==_46)):
        _45 += _15[(_12 + _38[(_37 + _44)])]
        _44 += 1
       pass
       if ((_46!=0) and ((_45 < (- self.__eps)) or (self.__eps < _45))): # src/fusion/ExprShape.monty:459:24-61
        _39 += 1
    _0.alloc_expr(_3,_5,_39,_7)
    _47=(_0.nidxs_base)
    _48=(_0.shape_base)
    _49=(_0.sp_base)
    _50=(_0.cof_base)
    _51=(_0.bfix_base)
    _52=(_0.ptr_base)
    _53=(_0.i32)
    _54=(_0.i64)
    _55=(_0.f64)
    for _56 in range(0,_3):
     _53[(_48 + _56)] = _16[_56]
    for _57 in range(0,_5):
     _55[(_50 + _57)] = 0.0
    for _58 in range(0,_5):
     _55[(_51 + _58)] = _15[(_11 + _58)]
    if _7: # src/fusion/ExprShape.monty:485:16-21
     for _59 in range(0,_5):
      _54[(_49 + _59)] = _14[(_49 + _59)]
    _60=0
    _61=(_50 - _47)
    _53[_52] = 0
    for _62 in range(0,_5):
     _63=_13[((_8 + _62) + 1)]
     _64=_13[(_8 + _62)]
     if (_64 < _63): # src/fusion/ExprShape.monty:494:20-27
      _65=_64
      while (_65 < _63):
       _66=0.0
       _67=_14[(_10 + _38[(_37 + _65)])]
       while ((_65 < _63) and (_14[(_10 + _38[(_37 + _65)])]==_67)):
        _66 += _15[(_12 + _38[(_37 + _65)])]
        _65 += 1
       pass
       if ((_67!=0) and ((_66 < (- self.__eps)) or (self.__eps < _66))): # src/fusion/ExprShape.monty:501:24-61
        _54[(_47 + _60)] = _67
        _55[(_50 + _60)] = _66
        _60 += 1
     _53[((_52 + _62) + 1)] = _60
   _2.clear()
  @staticmethod
  def _match_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5) and __arg_match_I__(_6))
  @staticmethod
  def _match_alt_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5) and __arg_alt_match_I__(_6))
  @staticmethod
  def _arg_1sort_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
    return mosek_fusion_ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_0,_1,numpy.int32(__2),numpy.int32(__3),numpy.int32(__4),numpy.int32(__5),numpy.int32(__6))
  @staticmethod
  def _arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_0,_1,_2,_3,_4,_5,_6):
   _7=0
   _8=(_0.i32)
   for _9 in range(0,_3):
    if ((_8[((_5 + _9) + 1)] - _8[(_5 + _9)]) > _7): # src/fusion/ExprShape.monty:234:14-50
     _7 = (_8[((_5 + _9) + 1)] - _8[(_5 + _9)])
   _10=(_1.alloci32((_7 * 2)) if ((_7 > 2) ) else 99999)
   _11=(_1.i32)
   _8 = (_0.i32)
   _12=(_0.i64)
   for _13 in range(0,_3):
    _14=_8[(_5 + _13)]
    _15=_8[((_5 + _13) + 1)]
    _16=(_15 - _14)
    if (_16==0): # src/fusion/ExprShape.monty:246:14-20
     pass
    elif (_16==1): # src/fusion/ExprShape.monty:249:18-24
     _11[(_2 + _14)] = _14
    elif (_16==2): # src/fusion/ExprShape.monty:252:18-24
     if (_12[(_6 + _14)] <= _12[((_6 + _14) + 1)]): # src/fusion/ExprShape.monty:253:16-50
      _11[(_2 + _14)] = _14
      _11[((_2 + _14) + 1)] = (_14 + 1)
     else:
      _11[(_2 + _14)] = (_14 + 1)
      _11[((_2 + _14) + 1)] = _14
    else:
     _17=_12[(_6 + _14)]
     _18=_12[(_6 + _14)]
     _19=False
     for _20 in range((_14 + 1),_15):
      _19 = (_19 and (_12[((_6 + _20) - 1)] <= _12[(_6 + _20)]))
      if (_17 > _12[(_6 + _20)]): # src/fusion/ExprShape.monty:268:18-38
       _17 = _12[(_6 + _20)]
      if (_18 < _12[(_6 + _20)]): # src/fusion/ExprShape.monty:269:18-38
       _18 = _12[(_6 + _20)]
     if _19: # src/fusion/ExprShape.monty:272:16-22
      for _21 in range(_14,_15):
       _11[(_2 + _21)] = _21
     elif (((_18 - _17) + 1) <= _16): # src/fusion/ExprShape.monty:276:20-40
      _22=((_18 - _17) + 1)
      for _23 in range(0,(_22 + 1)):
       _11[(_10 + _23)] = 0
      for _24 in range(_14,_15):
       _11[(((_10 + _12[(_6 + _24)]) - _17) + 1)] += 1
      for _25 in range(0,_22):
       _11[((_10 + _25) + 1)] += _11[(_10 + _25)]
      for _26 in range(_14,_15):
       _11[((_2 + _14) + _11[((_10 + _12[(_6 + _26)]) - _17)])] = _26
       _11[((_10 + _12[(_6 + _26)]) - _17)] += 1
     else:
      _27=1
      _28=_10
      _29=(_10 + _16)
      for _30 in range(0,_16):
       _11[(_28 + _30)] = _30
      while (_27 < _16):
       _31=(_27 * 2)
       _32=(_16 // _31)
       if (((_32 * _31) + _27) < _16): # src/fusion/ExprShape.monty:299:20-57
        _32 += 1
       _33=0
       for _34 in range(0,_32):
        _35=(_34 * _31)
        _36=(_35 + _27)
        _37=_36
        _38=(_37 + _27)
        if (_38 > _16): # src/fusion/ExprShape.monty:306:47-53
         _38 = _16
        while ((_35 < _36) and (_37 < _38)):
         if (_12[((_6 + _11[(_28 + _35)]) + _14)] <= _12[((_6 + _11[(_28 + _37)]) + _14)]): # src/fusion/ExprShape.monty:309:24-88
          _11[(_29 + _33)] = _11[(_28 + _35)]
          _33 += 1
          _35 += 1
         else:
          _11[(_29 + _33)] = _11[(_28 + _37)]
          _33 += 1
          _37 += 1
        while (_35 < _36):
         _11[(_29 + _33)] = _11[(_28 + _35)]
         _33 += 1
         _35 += 1
        while (_37 < _38):
         _11[(_29 + _33)] = _11[(_28 + _37)]
         _33 += 1
         _37 += 1
       if ((_32 * _31) < _16): # src/fusion/ExprShape.monty:333:20-45
        _39=(_32 * _31)
        while (_39 < _16):
         _11[(_29 + _33)] = _11[(_28 + _39)]
         _39 += 1
         _33 += 1
       _40=_28
       _28 = _29
       _29 = _40
       _27 *= 2
      for _41 in range(0,_16):
       _11[((_2 + _14) + _41)] = (_11[(_28 + _41)] + _14)
  @staticmethod
  def _match_merge_1sort_IIIIII_3I_3J(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5) and __arg_match__3I__(_6) and __arg_match__3J__(_7))
  @staticmethod
  def _match_alt_merge_1sort_IIIIII_3I_3J(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3J__(_7))
  @staticmethod
  def _merge_1sort_alt_IIIIII_3I_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_ExprCompress._merge_1sort_IIIIII_3I_3J(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _merge_1sort_IIIIII_3I_3J(_0,_1,_2,_3,_4,_5,_6,_7):
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   _8=_0
   _9=_1
   for _10 in range(0,_3):
    _6[(_8 + _10)] = _10
   for _11 in range(0,_2):
    _8 = _0
    _9 = _1
    _12=_6[((_4 + _11) + 1)]
    _13=_6[(_4 + _11)]
    if ((_13 + 1) < _12): # src/fusion/ExprShape.monty:176:14-25
     _14=(_12 - _13)
     _15=0
     while (_14 > 1):
      _15 += 1
      _14 /= 2
     _14 = (_12 - _13)
     _16=1
     for _17 in range(0,(_15 + 1)):
      _18=(((_14 + _16) - 1) // _16)
      _19=(_18 // 2)
      _20=_13
      for _21 in range(0,_19):
       _22=((_21 * _16) * 2)
       _23=(((_13 + _22) + (2 * _16)) if ((((_13 + _22) + (2 * _16)) < _12) ) else _12)
       _24=((_13 + _22) + _16)
       _25=((_13 + _22) + _16)
       _26=(_13 + _22)
       while ((_26 < _25) and (_24 < _23)):
        if (_7[(_5 + _6[(_8 + _26)])] <= _7[(_5 + _6[(_8 + _24)])]): # src/fusion/ExprShape.monty:190:26-94
         _6[(_9 + _20)] = _6[(_8 + _26)]
         _20 += 1
         _26 += 1
        else:
         _6[(_9 + _20)] = _6[(_8 + _24)]
         _20 += 1
         _24 += 1
       while (_26 < _25):
        _6[(_9 + _20)] = _6[(_8 + _26)]
        _20 += 1
        _26 += 1
       while (_24 < _23):
        _6[(_9 + _20)] = _6[(_8 + _24)]
        _20 += 1
        _24 += 1
      for _27 in range(_20,_12):
       _6[(_9 + _27)] = _6[(_8 + _27)]
      _28=_8
      _8 = _9
      _9 = _28
      _16 *= 2
    for _29 in range(_13,_12):
     _6[(_0 + _29)] = _6[(_8 + _29)]
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprCompress(")._a_S(self.__expr.toString())._a_S(")")._toString_())
 return ExprCompress
mosek_fusion_ExprCompress=__mk_mosek_fusion_ExprCompress()
del __mk_mosek_fusion_ExprCompress
#BEFORE CLASS
def __mk_mosek_fusion_ExprCondense():
 class ExprCondense(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprCondense__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprCondense.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprCondense._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprCondense._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprCondense._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCondense._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCondense.eval()\n\tmosek.fusion.ExprCondense.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprCondense'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprCondense.__new__(ExprCondense)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr.getShape())
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr.eval(_0,_1,_2)
   _3=_0.popi32()
   _4=1
   for _5 in range(0,_3):
    _4 *= _0.popi32()
   _6=_0.popi32()
   _7=_0.popi32()
   _8=(_0.popi32()!=0)
   if _8: # src/fusion/ExprShape.monty:125:12-17
    _0.popi64(_6)
   _0.pushi32(0)
   _0.pushi32(_7)
   _0.pushi32(_6)
   _0.pushi32(_6)
   _0.pushi32(1)
 return ExprCondense
mosek_fusion_ExprCondense=__mk_mosek_fusion_ExprCondense()
del __mk_mosek_fusion_ExprCondense
#BEFORE CLASS
def __mk_mosek_fusion_ExprFromVar():
 class ExprFromVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprFromVar__x']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      self._ctor_init_Lmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Variable_2(*args):# mosek.fusion.Variable
      self._ctor_alt_init_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprFromVar.ctor(mosek.fusion.Variable)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprFromVar._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprFromVar._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprFromVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprFromVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprFromVar.eval()\n\tmosek.fusion.ExprFromVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprFromVar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprFromVar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprFromVar.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprFromVar: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2(x):
    o = ExprFromVar.__new__(ExprFromVar)
    o._ctor_init_Lmosek_4fusion_4Variable_2(x)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    x, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    x, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2(self,x):
    self._ctor_init_Lmosek_4fusion_4Variable_2(x)
  def _ctor_init_Lmosek_4fusion_4Variable_2(self,x):
   mosek_fusion_BaseExpression._ctor_init__3I(self,x.getShape())
   (self.__x) = x
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self.getShape()
   _4=mosek.fusion.Set._size__3I(_3)
   _5=self.__x.numInst()
   _6=_5
   _7=(_4 > _5)
   _8=_0.alloci32((_5 + 1))
   _9=_0.alloci64(_6)
   _10=(_0.alloci64(_5) if (_7 ) else (- 1))
   _11=_0.allocf64(_6)
   _12=_0.allocf64(_5)
   _0.pushi32((1 if (_7 ) else 0))
   _0.pushi32(_6)
   _0.pushi32(_5)
   for _13 in range(0,int((_3).shape[0])):
    _0.pushi32(_3[_13])
   _0.pushi32(int((_3).shape[0]))
   _14=(_0.i32)
   _15=(_0.i64)
   _16=(_0.f64)
   for _17 in range(0,(_5 + 1)):
    _14[(_8 + _17)] = _17
   for _18 in range(0,_5):
    _16[(_12 + _18)] = 0.0
   for _19 in range(0,_6):
    _16[(_11 + _19)] = 1.0
   if _7: # src/fusion/ExprShape.monty:93:12-17
    self.__x.inst(_10,_15,_9,_15)
   else:
    self.__x.inst(_9,_15)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("Expr(")._a_S(self.__x.toString())._a_S(")")._toString_())
 return ExprFromVar
mosek_fusion_ExprFromVar=__mk_mosek_fusion_ExprFromVar()
del __mk_mosek_fusion_ExprFromVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprReshape():
 class ExprReshape(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprReshape__e']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3ILmosek_4fusion_4Expression_2(*args): # []int32,mosek.fusion.Expression
      self._ctor_init__3ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):# []int32,mosek.fusion.Expression
      self._ctor_alt_init__3ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprReshape.ctor(array(int32,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprReshape._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_ExprReshape._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_ExprReshape._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprReshape._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprReshape.eval()\n\tmosek.fusion.ExprReshape.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprReshape._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprReshape._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprReshape.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.ExprReshape: '+self._toString_()
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2(shape,e):
    o = ExprReshape.__new__(ExprReshape)
    o._ctor_init__3ILmosek_4fusion_4Expression_2(shape,e)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    shape,e, = args
    return (__arg_match__3I__(shape) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    shape,e, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2(self,shape,e):
    self._ctor_init__3ILmosek_4fusion_4Expression_2(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),e)
  def _ctor_init__3ILmosek_4fusion_4Expression_2(self,shape,e):
   assert shape is None or isinstance(shape,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.Utils.Tools._arraycopy__3I(shape))
   _0=e.getSize()
   if (mosek.fusion.Set._size__3I(shape)!=e.getSize()): # src/fusion/ExprShape.monty:11:12-42
    raise mosek_fusion_LengthError._ctor_S("Cannot reshape to mismatching shape")
   (self.__e) = e
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self.getShape()
   self.__e.eval(_0,_1,_2)
   _0.peek_expr()
   _4=_0.popi32()
   _5=1
   for _6 in range(0,_4):
    _5 *= _0.popi32()
   if (_5!=self.getSize()): # src/fusion/ExprShape.monty:37:12-27
    raise mosek_fusion_DimensionError._ctor_S("The two shapes have different sizes")
   for _7 in range(0,int((_3).shape[0])):
    _0.pushi32(_3[_7])
   _0.pushi32(int((_3).shape[0]))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprReshape((")
   if (self.getND() > 0): # src/fusion/ExprShape.monty:19:12-23
    _0._a_I(self.getDim(0))
    for _1 in range(1,self.getND()):
     _0._a_S(",")._a_I(self.getDim(_1))
   _0._a_S("),")._a_S(self.__e.toString())._a_S(")")
   return (_0._toString_())
 return ExprReshape
mosek_fusion_ExprReshape=__mk_mosek_fusion_ExprReshape()
del __mk_mosek_fusion_ExprReshape
#BEFORE CLASS
def __mk_mosek_fusion_Expr():
 class Expr(mosek_fusion_BaseExpression):
  __slots__ = ['_Expr__inst','_Expr__cof_v','_Expr__subj','_Expr__ptrb','_Expr__bfix','_Expr__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3J_3D_3D_3I_3J(*args): # []int64,[]int64,[]double,[]double,[]int32,[]int64
      self._ctor_init__3J_3J_3D_3D_3I_3J(*args)
    elif self.__match_alt_ctor__3J_3J_3D_3D_3I_3J(*args):# []int64,[]int64,[]double,[]double,[]int32,[]int64
      self._ctor_alt_init__3J_3J_3D_3D_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Expr.ctor(array(int64,ndim=1),array(int64,ndim=1),array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int64,ndim=1))')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_hstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_hstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.hstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.hstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,double)')
  @staticmethod
  def sub(*args):
    if False: pass
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_sub__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.sub(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,double)')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_stack__3_3Lmosek_4fusion_4Expression_2(*args): # [][]mosek.fusion.Expression
      return mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args): # [][]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_I_3Lmosek_4fusion_4Expression_2(*args): # int32,[]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args): # int32,[]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2D(*args): # int32,double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args): # int32,double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DD(*args): # int32,mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args): # int32,mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_stack_IDDLmosek_4fusion_4Expression_2(*args): # int32,double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args): # int32,double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.stack(array(array(mosek.fusion.Expression,ndim=1),ndim=1))\n\tmosek.fusion.Expr.stack(int32,array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.stack(int32,double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)')
  @staticmethod
  def zeros(*args):
    if False: pass
    elif mosek_fusion_Expr._match_zeros_I(*args): # int32
      return mosek_fusion_Expr._zeros_I(*args)
    elif mosek_fusion_Expr._match_alt_zeros_I(*args): # int32
      return mosek_fusion_Expr._zeros_alt_I(*args)
    elif mosek_fusion_Expr._match_zeros__3I(*args): # []int32
      return mosek_fusion_Expr._zeros__3I(*args)
    elif mosek_fusion_Expr._match_alt_zeros__3I(*args): # []int32
      return mosek_fusion_Expr._zeros_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list zeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.zeros(int32)\n\tmosek.fusion.Expr.zeros(array(int32,ndim=1))')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Expr._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.getShape()')
  @staticmethod
  def add(*args):
    if False: pass
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.add(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.add(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,double)')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Expr._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.getND()')
  @staticmethod
  def transpose(*args):
    if False: pass
    elif mosek_fusion_Expr._match_transpose_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._transpose_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_transpose_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._transpose_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.transpose(mosek.fusion.Expression)')
  @staticmethod
  def mul(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,double)')
  @staticmethod
  def dot(*args):
    if False: pass
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_dot__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    else:
      raise ValueError('Invalid argument list dot('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.dot(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=2))')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_Expr._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.numNonzeros()')
  @staticmethod
  def ones(*args):
    if False: pass
    elif mosek_fusion_Expr._match_ones_(*args): # 
      return mosek_fusion_Expr._ones_(*args)
    elif mosek_fusion_Expr._match_alt_ones_(*args): # 
      return mosek_fusion_Expr._ones_alt_(*args)
    elif mosek_fusion_Expr._match_ones__3I(*args): # []int32
      return mosek_fusion_Expr._ones__3I(*args)
    elif mosek_fusion_Expr._match_alt_ones__3I(*args): # []int32
      return mosek_fusion_Expr._ones_alt__3I(*args)
    elif mosek_fusion_Expr._match_ones_I(*args): # int32
      return mosek_fusion_Expr._ones_I(*args)
    elif mosek_fusion_Expr._match_alt_ones_I(*args): # int32
      return mosek_fusion_Expr._ones_alt_I(*args)
    elif mosek_fusion_Expr._match_ones__3I_3_5I(*args): # []int32,[,]int32
      return mosek_fusion_Expr._ones__3I_3_5I(*args)
    elif mosek_fusion_Expr._match_alt_ones__3I_3_5I(*args): # []int32,[,]int32
      return mosek_fusion_Expr._ones_alt__3I_3_5I(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.ones()\n\tmosek.fusion.Expr.ones(array(int32,ndim=1))\n\tmosek.fusion.Expr.ones(int32)\n\tmosek.fusion.Expr.ones(array(int32,ndim=1),array(int32,ndim=2))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_eval_(*args): # 
      return self._eval_(*args)
    elif mosek_fusion_Expr._match_alt_eval_(*args): # 
      return self._eval_alt_(*args)
    elif mosek_fusion_Expr._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_Expr._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.eval()\n\tmosek.fusion.Expr.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  @staticmethod
  def condense(*args):
    if False: pass
    elif mosek_fusion_Expr._match_condense_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._condense_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_condense_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._condense_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list condense('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.condense(mosek.fusion.Expression)')
  @staticmethod
  def sum(*args):
    if False: pass
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list sum('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression,int32)')
  @staticmethod
  def mulDiag(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    else:
      raise ValueError('Invalid argument list mulDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)')
  @staticmethod
  def constTerm(*args):
    if False: pass
    elif mosek_fusion_Expr._match_constTerm__3D(*args): # []double
      return mosek_fusion_Expr._constTerm__3D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3D(*args): # []double
      return mosek_fusion_Expr._constTerm_alt__3D(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_constTerm__3_5D(*args): # [,]double
      return mosek_fusion_Expr._constTerm__3_5D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3_5D(*args): # [,]double
      return mosek_fusion_Expr._constTerm_alt__3_5D(*args)
    elif mosek_fusion_Expr._match_constTerm_D(*args): # double
      return mosek_fusion_Expr._constTerm_D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_D(*args): # double
      return mosek_fusion_Expr._constTerm_alt_D(*args)
    elif mosek_fusion_Expr._match_constTerm_ID(*args): # int32,double
      return mosek_fusion_Expr._constTerm_ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_ID(*args): # int32,double
      return mosek_fusion_Expr._constTerm_alt_ID(*args)
    elif mosek_fusion_Expr._match_constTerm__3ID(*args): # []int32,double
      return mosek_fusion_Expr._constTerm__3ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3ID(*args): # []int32,double
      return mosek_fusion_Expr._constTerm_alt__3ID(*args)
    elif mosek_fusion_Expr._match_constTerm__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_Expr._constTerm__3I_3_5I_3D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_Expr._constTerm_alt__3I_3_5I_3D(*args)
    elif mosek_fusion_Expr._match_constTerm__3I_3_5ID(*args): # []int32,[,]int32,double
      return mosek_fusion_Expr._constTerm__3I_3_5ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3I_3_5ID(*args): # []int32,[,]int32,double
      return mosek_fusion_Expr._constTerm_alt__3I_3_5ID(*args)
    else:
      raise ValueError('Invalid argument list constTerm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.constTerm(array(double,ndim=1))\n\tmosek.fusion.Expr.constTerm(mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.constTerm(mosek.fusion.Matrix)\n\tmosek.fusion.Expr.constTerm(array(double,ndim=2))\n\tmosek.fusion.Expr.constTerm(double)\n\tmosek.fusion.Expr.constTerm(int32,double)\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),double)\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),array(int32,ndim=2),double)')
  @staticmethod
  def mulElm(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mulElm__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    else:
      raise ValueError('Invalid argument list mulElm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mulElm(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=2))')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Expr._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.size()')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_vstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_vstack_DDD(*args): # double,double,double
      return mosek_fusion_Expr._vstack_DDD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDD(*args): # double,double,double
      return mosek_fusion_Expr._vstack_alt_DDD(*args)
    elif mosek_fusion_Expr._match_vstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.vstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.vstack(double,double,double)\n\tmosek.fusion.Expr.vstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,double)')
  @staticmethod
  def outer(*args):
    if False: pass
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_outer__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._outer__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_outer__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_outer__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._outer__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_outer__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._outer_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    else:
      raise ValueError('Invalid argument list outer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.outer(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.outer(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.outer(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.outer(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.outer(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.outer(mosek.fusion.Expression,array(double,ndim=1))')
  @staticmethod
  def flatten(*args):
    if False: pass
    elif mosek_fusion_Expr._match_flatten_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_flatten_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._flatten_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.flatten(mosek.fusion.Expression)')
  @staticmethod
  def neg(*args):
    if False: pass
    elif mosek_fusion_Expr._match_neg_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_neg_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._neg_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list neg('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.neg(mosek.fusion.Expression)')
  @staticmethod
  def reshape(*args):
    if False: pass
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2_3I(*args): # mosek.fusion.Expression,[]int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2_3I(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2_3I(*args): # mosek.fusion.Expression,[]int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2_3I(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,array(int32,ndim=1))\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32)\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Expr._match_repeat_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._repeat_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.repeat(mosek.fusion.Expression,int32,int32)')
  def __repr__(self): return 'mosek.fusion.Expr'
  @staticmethod
  def _ctor__3J_3J_3D_3D_3I_3J(ptrb,subj,cof,bfix,shape,inst):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3J_3D_3D_3I_3J(ptrb,subj,cof,bfix,shape,inst)
    return o
  @staticmethod
  def __match_ctor__3J_3J_3D_3D_3I_3J(*args):
    if len(args) != 6: return False
    ptrb,subj,cof,bfix,shape,inst, = args
    return (__arg_match__3J__(ptrb) and __arg_match__3J__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(shape) and __arg_match__3J__(inst))
  @staticmethod
  def __match_alt_ctor__3J_3J_3D_3D_3I_3J(*args):
    if len(args) != 6: return False
    ptrb,subj,cof,bfix,shape,inst, = args
    return (__arg_alt_match__3J__(ptrb) and __arg_alt_match__3J__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(inst))
  def _ctor_alt_init__3J_3J_3D_3D_3I_3J(self,ptrb,subj,cof,bfix,shape,inst):
    self._ctor_init__3J_3J_3D_3D_3I_3J(numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int64)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(inst,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3J_3J_3D_3D_3I_3J(self,ptrb,subj,cof,bfix,shape,inst):
   assert ptrb is None or isinstance(ptrb,numpy.ndarray)
   assert subj is None or isinstance(subj,numpy.ndarray)
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert inst is None or isinstance(inst,numpy.ndarray)
   mosek_fusion_Expr._ctor_init__3J_3J_3D_3D_3I_3JI(self,mosek.fusion.Utils.Tools._arraycopy__3J(ptrb),mosek.fusion.Utils.Tools._arraycopy__3J(subj),mosek.fusion.Utils.Tools._arraycopy__3D(cof),mosek.fusion.Utils.Tools._arraycopy__3D(bfix),(mosek.fusion.Utils.Tools._arraycopy__3I(shape) if ((shape is not None) ) else numpy.array([(int((ptrb).shape[0]) - 1)], dtype=numpy.dtype(numpy.int32))),(mosek.fusion.Utils.Tools._arraycopy__3J(inst) if ((inst is not None) ) else None),1)
   _0=(int((ptrb).shape[0]) - 1)
   if (_0 < 0): # src/fusion/Expr.mbi:565:12-21
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb")
   _1=ptrb[_0]
   if ((_1 < 0) or ((_1!=int((cof).shape[0])) or (_1!=int((subj).shape[0])))): # src/fusion/Expr.mbi:568:12-58
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb construction")
   _2=True
   _3=True
   _4=True
   _5=(self.__shape)
   _6=mosek.fusion.Set._size__3I(_5)
   for _7 in range(0,int((_5).shape[0])):
    _3 = (_3 and (_5[_7] >= 0))
   for _8 in range(0,_0):
    _2 = (_2 and (ptrb[_8] <= ptrb[(_8 + 1)]))
   if ((inst is not None) and (int((inst).shape[0]) > 0)): # src/fusion/Expr.mbi:579:14-44
    _4 = ((inst[0] >= 0) and (inst[(_0 - 1)] < _6))
    for _9 in range(0,(_0 - 1)):
     _4 = (_4 and (inst[_9] < inst[(_9 + 1)]))
   if (not _3): # src/fusion/Expr.mbi:584:12-24
    raise mosek_fusion_ExpressionError._ctor_S("Invalid shape")
   if (not _2): # src/fusion/Expr.mbi:586:12-23
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb")
   if (not _4): # src/fusion/Expr.mbi:588:12-23
    raise mosek_fusion_ExpressionError._ctor_S("Invalid sparsity pattern")
  @staticmethod
  def _ctor__3J_3J_3D_3D_3I_3JI(ptrb,subj,cof,bfix,shp,inst,unchecked_):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3J_3D_3D_3I_3JI(ptrb,subj,cof,bfix,shp,inst,unchecked_)
    return o
  @staticmethod
  def __match_ctor__3J_3J_3D_3D_3I_3JI(*args):
    if len(args) != 7: return False
    ptrb,subj,cof,bfix,shp,inst,unchecked_, = args
    return (__arg_match__3J__(ptrb) and __arg_match__3J__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(shp) and __arg_match__3J__(inst) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor__3J_3J_3D_3D_3I_3JI(*args):
    if len(args) != 7: return False
    ptrb,subj,cof,bfix,shp,inst,unchecked_, = args
    return (__arg_alt_match__3J__(ptrb) and __arg_alt_match__3J__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(shp) and __arg_alt_match__3J__(inst) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init__3J_3J_3D_3D_3I_3JI(self,ptrb,subj,cof,bfix,shp,inst,unchecked_):
    self._ctor_init__3J_3J_3D_3D_3I_3JI(numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int64)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(shp,dtype=numpy.dtype(numpy.int32)),numpy.array(inst,dtype=numpy.dtype(numpy.int64)),numpy.int32(unchecked_))
  def _ctor_init__3J_3J_3D_3D_3I_3JI(self,ptrb,subj,cof,bfix,shp,inst,unchecked_):
   assert ptrb is None or isinstance(ptrb,numpy.ndarray)
   assert subj is None or isinstance(subj,numpy.ndarray)
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   assert shp is None or isinstance(shp,numpy.ndarray)
   assert inst is None or isinstance(inst,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,shp)
   (self.__shape) = shp
   (self.__ptrb) = ptrb
   (self.__subj) = subj
   (self.__cof_v) = cof
   (self.__bfix) = bfix
   (self.__inst) = inst
   if ((self.__shape) is None): # src/fusion/Expr.mbi:503:12-30
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: NULL shape")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(e):
    o = Expr.__new__(Expr)
    o._ctor_init_Lmosek_4fusion_4Expression_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,e):
    self._ctor_init_Lmosek_4fusion_4Expression_2(e)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,e.getShape())
   _1=e
   if   isinstance(_1,mosek_fusion_Expr):
    ee=_1
    self.__shape = (ee.__shape)
    self.__ptrb = (ee.__ptrb)
    self.__subj = (ee.__subj)
    self.__cof_v = (ee.__cof_v)
    self.__bfix = (ee.__bfix)
    self.__inst = (ee.__inst)
   else:
    ee=_1
    _1=mosek_fusion_WorkStack._ctor_()
    _2=mosek_fusion_WorkStack._ctor_()
    _3=mosek_fusion_WorkStack._ctor_()
    ee.eval(_3,_2,_1)
    _4=_3.popi32()
    _5=_3.popi32(_4)
    _6=_3.popi32()
    _7=_3.popi32()
    _8=(_3.popi32()!=0)
    _9=_3.popi32((_6 + 1))
    _10=(_3.popi64(_6) if (_8 ) else 0)
    _11=_3.popi64(_7)
    _12=_3.popf64(_6)
    _13=_3.popf64(_7)
    _14=(_3.i32)
    _15=(_3.i64)
    _16=(_3.f64)
    self.__shape = numpy.array([_14[(_5 + _17)] for _17 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
    self.__ptrb = numpy.array([_14[(_9 + _18)] for _18 in range(0,(_6 + 1))], dtype=numpy.dtype(numpy.int64))
    self.__subj = numpy.array([_15[(_11 + _19)] for _19 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    self.__cof_v = numpy.array([_16[(_13 + _20)] for _20 in range(0,_7)], dtype=numpy.dtype(numpy.float64))
    self.__bfix = numpy.array([_16[(_12 + _21)] for _21 in range(0,_7)], dtype=numpy.dtype(numpy.float64))
    self.__inst = (numpy.array([_15[(_10 + _22)] for _22 in range(0,_7)], dtype=numpy.dtype(numpy.int64)) if (_8 ) else None)
   if (self.__shape is None): # src/fusion/Expr.mbi:405:12-25
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: NULL shape")
  def __prod_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self.__prod__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __prod__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   for _2 in range(0,int((_0).shape[0])):
    _1 *= _0[_2]
   return numpy.int32(_1)
  @staticmethod
  def __varstack_alt__3_3Lmosek_4fusion_4Variable_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Expr.__varstack__3_3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __varstack__3_3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (numpy.array([_0[_1][_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0[_1]).shape[0]))], dtype=numpy.dtype(object)))
  @staticmethod
  def __varstack_alt__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (_0 is None): # src/fusion/Expr.mbi:1821:12-22
    return (_1)
   elif (_1 is None): # src/fusion/Expr.mbi:1822:16-26
    return (_0)
   else:
    _2=numpy.ndarray(((int((_0).shape[0]) + int((_1).shape[0])),), dtype=numpy.dtype(object))
    for _3 in range(0,int((_0).shape[0])):
     _2[_3] = _0[_3]
    for _4 in range(0,int((_1).shape[0])):
     _2[(_4 + int((_0).shape[0]))] = _1[_4]
    return (_2)
  @staticmethod
  def _match_condense_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_condense_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _condense_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._condense_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _condense_Lmosek_4fusion_4Expression_2(_0):
   return (mosek_fusion_ExprCondense._ctor_Lmosek_4fusion_4Expression_2(_0))
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None): # src/fusion/Expr.mbi:1809:12-21
    raise ValueError("Arguments for flatten may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(_0.getSize())))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if (_0 is None): # src/fusion/Expr.mbi:1800:12-21
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,mosek.fusion.Set._make_II(_1,_2)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(__1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2I(_0,_1):
   if (_0 is None): # src/fusion/Expr.mbi:1790:12-21
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,mosek.fusion.Set._make_I(_1)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int64((int((self.__ptrb).shape[0]) - 1))
  @staticmethod
  def _match_eval_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_eval_(*args):
    if len(args) != 0: return False
    return True
  def _eval_alt_(self,):
    return self._eval_()
  def _eval_(self,):
   _0=(None if ((self.__bfix is None) ) else mosek.fusion.Utils.Tools._arraycopy__3D(self.__bfix))
   _1=(None if ((self.__inst is None) ) else mosek.fusion.Utils.Tools._arraycopy__3J(self.__inst))
   return (mosek_fusion_FlatExpr._ctor__3D_3J_3J_3D_3I_3J(_0,mosek.fusion.Utils.Tools._arraycopy__3J(self.__ptrb),mosek.fusion.Utils.Tools._arraycopy__3J(self.__subj),mosek.fusion.Utils.Tools._arraycopy__3D(self.__cof_v),self.__shape,self.__inst))
  @staticmethod
  def _match_zeros__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_zeros__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _zeros_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._zeros__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _zeros__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr._constTerm__3ID(_0,0))
  @staticmethod
  def _match_zeros_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_zeros_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _zeros_alt_I(_t__0):
    return mosek_fusion_Expr._zeros_I(numpy.int32(__0))
  @staticmethod
  def _zeros_I(_0):
   return (mosek.fusion.Expr._constTerm_ID(_0,0))
  @staticmethod
  def _match_ones_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_ones_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _ones_alt_():
    return mosek_fusion_Expr._ones_()
  @staticmethod
  def _ones_():
   return (mosek.fusion.Expr._constTerm_D(1))
  @staticmethod
  def _match_ones__3I_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_ones__3I_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1))
  @staticmethod
  def _ones_alt__3I_3_5I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._ones__3I_3_5I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ones__3I_3_5I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr._constTerm__3I_3_5ID(_0,_1,1))
  @staticmethod
  def _match_ones__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_ones__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _ones_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._ones__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ones__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr._constTerm__3ID(_0,1))
  @staticmethod
  def _match_ones_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ones_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _ones_alt_I(_t__0):
    return mosek_fusion_Expr._ones_I(numpy.int32(__0))
  @staticmethod
  def _ones_I(_0):
   return (mosek.fusion.Expr._constTerm_ID(_0,1))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(_t__0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4NDSparseArray_2(_0):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D((_0._dims),(_0._inst),(_0._cof)))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4Matrix_2(_0):
   _1=_0.numRows()
   _2=_0.numColumns()
   _3=mosek.fusion.Set._make_II(_1,_2)
   if _0.isSparse(): # src/fusion/Expr.mbi:1737:12-24
    _4=numpy.zeros((_0.numNonzeros(),), dtype=numpy.dtype(numpy.float64))
    _5=numpy.zeros((_0.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_0.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
    _0.getDataAsTriplets(_6,_5,_4)
    _7=numpy.array([((_6[_8] * _2) + _5[_8]) for _8 in range(0,int((_5).shape[0]))], dtype=numpy.dtype(numpy.int64))
    return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_3,_7,_4))
   else:
    return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_3,None,_0.getDataAsArray()))
  @staticmethod
  def _match_constTerm_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_constTerm_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _constTerm_alt_D(_t__0):
    return mosek_fusion_Expr._constTerm_D(numpy.float64(__0))
  @staticmethod
  def _constTerm_D(_0):
   return (mosek_fusion_ExprConst._ctor__3I_3JD(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,_0))
  @staticmethod
  def _match_constTerm__3I_3_5ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_constTerm__3I_3_5ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _constTerm_alt__3I_3_5ID(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.float64(_t__2)
   _1 = mosek_fusion_Expr._constTerm__3I_3_5ID(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3I_3_5ID(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=int((_1).shape[0])
   _4=int((_0).shape[0])
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
   _6[(_4 - 1)] = 1
   for _7 in range(1,_4):
    _6[((_4 - _7) - 1)] = (_6[(_4 - _7)] * _0[(_4 - _7)])
   for _8 in range(0,_3):
    for _9 in range(0,_4):
     _5[_8] += (_6[_9] * _1[_8,_9])
   return (mosek_fusion_ExprConst._ctor__3I_3JD(_0,_5,_2))
  @staticmethod
  def _match_constTerm__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_constTerm__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _constTerm_alt__3I_3_5I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3I_3_5I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3I_3_5I_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=int((_1).shape[0])
   _4=int((_0).shape[0])
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
   _6[(_4 - 1)] = 1
   for _7 in range(1,_4):
    _6[((_4 - _7) - 1)] = (_6[(_4 - _7)] * _0[(_4 - _7)])
   for _8 in range(0,_3):
    for _9 in range(0,_4):
     _5[_8] += (_6[_9] * _1[_8,_9])
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_0,_5,_2))
  @staticmethod
  def _match_constTerm__3ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_constTerm__3ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _constTerm_alt__3ID(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.float64(_t__1)
   _1 = mosek_fusion_Expr._constTerm__3ID(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3ID(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprConst._ctor__3I_3JD(_0,None,_1))
  @staticmethod
  def _match_constTerm_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_constTerm_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _constTerm_alt_ID(_t__0,_t__1):
    return mosek_fusion_Expr._constTerm_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _constTerm_ID(_0,_1):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([_0], dtype=numpy.dtype(numpy.int32)),None,numpy.array([_1 for _2 in range(0,_0)], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _constTerm_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3_5D(_0)
   return _1
  @staticmethod
  def _constTerm__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32)),None,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_constTerm__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_constTerm__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _constTerm_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32)),None,_0))
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(int((self.__cof_v).shape[0]))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(__1))
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2I(_0,_1):
   return (mosek_fusion_ExprSumReduce._ctor_ILmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2(_0):
   return (mosek_fusion_ExprSumReduce._ctor_ILmosek_4fusion_4Expression_2(0,mosek.fusion.Expr._flatten_Lmosek_4fusion_4Expression_2(_0)))
  @staticmethod
  def _match_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _neg_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _neg_Lmosek_4fusion_4Expression_2(_0):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2((- 1),_0))
  @staticmethod
  def __mulDiag_alt_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def __mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   _3=_1.numNonzeros()
   _4=_1.numRows()
   _5=_1.numColumns()
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _1.getDataAsTriplets(_8,_7,_6)
   if _0: # src/fusion/Expr.mbi:1657:12-16
    return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_4,_5,_8,_7,_6,_2))
   else:
    return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_4,_5,_8,_7,_6,_2))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_1,_0.asExpr()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_0,_1.asExpr()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_1).shape[0]),int((_1).shape[1]),numpy.array([_2 for _2 in range(0,int((_1).shape[0])) for _3 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_1).shape[0])) for _5 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_1[_6,_7] for _6 in range(0,int((_1).shape[0])) for _7 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64)),_0.asExpr()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_1).shape[0]),int((_1).shape[1]),numpy.array([_2 for _2 in range(0,int((_1).shape[0])) for _3 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_1).shape[0])) for _5 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_1[_6,_7] for _6 in range(0,int((_1).shape[0])) for _7 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64)),_0))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_0).shape[0]),int((_0).shape[1]),numpy.array([_2 for _2 in range(0,int((_0).shape[0])) for _3 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_0).shape[0])) for _5 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_6,_7] for _6 in range(0,int((_0).shape[0])) for _7 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),_1.asExpr()))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_0).shape[0]),int((_0).shape[1]),numpy.array([_2 for _2 in range(0,int((_0).shape[0])) for _3 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_0).shape[0])) for _5 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_6,_7] for _6 in range(0,int((_0).shape[0])) for _7 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   _2=_1.getShape()
   _3=_1
   if (int((_2).shape[0])==1): # src/fusion/Expr.mbi:1618:12-28
    _2 = numpy.array([_2[0],1], dtype=numpy.dtype(numpy.int32))
    _3 = mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_2,_1)
   if ((int((_2).shape[0])!=2) or ((_0.numRows()!=_2[0]) or (_0.numColumns()!=_2[1]))): # src/fusion/Expr.mbi:1622:12-1624:39
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _4=_0.numColumns()
   _5=_0.numNonzeros()
   _6=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
   _0.getDataAsTriplets(_6,_7,_8)
   return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2I(_8,numpy.array([((_6[_9] * _4) + _7[_9]) for _9 in range(0,_5)], dtype=numpy.dtype(numpy.int64)),_3,1))
  @staticmethod
  def __mulElm_1_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((_0 is None) or (_1 is None)): # src/fusion/Expr.mbi:1603:12-37
    raise ValueError("Arguments for mulElm may not be null")
   if ((_1.getND()==0) and (int((_0).shape[0])==1)): # src/fusion/Expr.mbi:1605:12-45
    return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_0[0],_1))
   elif ((_1.getND()!=1) or (_1.getDim(0)!=int((_0).shape[0]))): # src/fusion/Expr.mbi:1607:16-1608:40
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   else:
    return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2(_0,numpy.array([_2 for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)): # src/fusion/Expr.mbi:1590:12-39
    raise ValueError("Arguments for mulElm may not be null")
   _2=_1.getShape()
   if (int((_2).shape[0])!=int(((_0._dims)).shape[0])): # src/fusion/Expr.mbi:1592:12-40
    raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   for _3 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_3]!=_2[_3]): # src/fusion/Expr.mbi:1595:14-38
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2((_0._cof),(_0._inst),_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _mul_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mul__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mul__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def __mul_alt_Z_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = mosek_fusion_Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_Z_3DLmosek_4fusion_4Expression_2(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=int((_1).shape[0])
   _4=_3
   _5=mosek.fusion.Utils.Tools._arraycopy__3D(_1)
   _6=_2.getND()
   if (_6==0): # src/fusion/Expr.mbi:1564:12-19
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_3], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_3,1,numpy.array([_7 for _7 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([0 for _8 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2,1)))
   elif (_6!=2): # src/fusion/Expr.mbi:1566:16-23
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   elif (_0 and (_2.getDim(0)==int((_1).shape[0]))): # src/fusion/Expr.mbi:1568:21-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_2.getDim(1)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(1,_3,numpy.array([0 for _9 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([_10 for _10 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2)))
   elif (_0 and (_2.getDim(0)==1)): # src/fusion/Expr.mbi:1570:17-42
    return (mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_3,1,numpy.array([_11 for _11 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([0 for _12 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2,1))
   elif ((not _0) and (_2.getDim(1)==_3)): # src/fusion/Expr.mbi:1572:17-50
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_2.getDim(0)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,1,numpy.array([_13 for _13 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([0 for _14 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2)))
   elif ((not _0) and (_2.getDim(1)==1)): # src/fusion/Expr.mbi:1574:17-46
    return (mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(1,_3,numpy.array([0 for _15 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([_16 for _16 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2,1))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def __mul_alt_Z_3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = mosek_fusion_Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(_0,_1,_2)
   return _1
  @staticmethod
  def __mul_Z_3_5DLmosek_4fusion_4Expression_2(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=int((_1).shape[0])
   _4=int((_1).shape[1])
   _5=(_3 * _4)
   _6=numpy.array([_7 for _7 in range(0,_3) for _8 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
   _9=numpy.array([_11 for _10 in range(0,_3) for _11 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
   _12=numpy.array([_1[_13,_14] for _13 in range(0,_3) for _14 in range(0,_4)], dtype=numpy.dtype(numpy.float64))
   _15=_2.getSize()
   _16=_2.getShape()
   if (int((_16).shape[0])==0): # src/fusion/Expr.mbi:1538:12-28
    return (mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_3,_4,_6,_9,_12,_2,1))
   elif _0: # src/fusion/Expr.mbi:1540:16-20
    if (int((_16).shape[0])==1): # src/fusion/Expr.mbi:1541:14-30
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([int((_1).shape[0])], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_16[0],1], dtype=numpy.dtype(numpy.int32)),_2))))
    elif (int((_16).shape[0])==2): # src/fusion/Expr.mbi:1543:18-34
     return (mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,_2))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   else:
    if (int((_16).shape[0])==1): # src/fusion/Expr.mbi:1549:14-30
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([int((_1).shape[1])], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_16[0]], dtype=numpy.dtype(numpy.int32)),_2))))
    elif (int((_16).shape[0])==2): # src/fusion/Expr.mbi:1551:18-34
     return (mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,_2))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def __mul_alt_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def __mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   _3=_1.numNonzeros()
   _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   _7=_1.numRows()
   _8=_1.numColumns()
   _1.getDataAsTriplets(_4,_5,_6)
   _9=_2.getND()
   if (_9==0): # src/fusion/Expr.mbi:1508:12-19
    return (mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,_2))
   elif (_9==1): # src/fusion/Expr.mbi:1510:16-23
    _10=_2.getShape()
    if _0: # src/fusion/Expr.mbi:1512:14-18
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_7], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_10[0],1], dtype=numpy.dtype(numpy.int32)),_2))))
    else:
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_8], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_10[0]], dtype=numpy.dtype(numpy.int32)),_2))))
   elif (_9==2): # src/fusion/Expr.mbi:1517:16-23
    if _0: # src/fusion/Expr.mbi:1518:14-18
     return (mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,_2))
    else:
     return (mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions for multiplication")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   _2=_1.numRows()
   _3=_1.numColumns()
   _4=numpy.zeros((_1.numNonzeros(),), dtype=numpy.dtype(numpy.float64))
   _5=numpy.zeros((_1.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_1.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
   _1.getDataAsTriplets(_6,_5,_4)
   return (mosek.fusion.Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(False,_2,_3,_6,_5,_4,_0))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   _2=_0.numRows()
   _3=_0.numColumns()
   _4=numpy.zeros((_0.numNonzeros(),), dtype=numpy.dtype(numpy.float64))
   _5=numpy.zeros((_0.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_0.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
   _0.getDataAsTriplets(_6,_5,_4)
   return (mosek.fusion.Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(True,_2,_3,_6,_5,_4,_1))
  @staticmethod
  def __mul_alt_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=_t__6
   _1 = mosek_fusion_Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6):
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   if (_6.getND()==0): # src/fusion/Expr.mbi:1409:12-26
    return (mosek_fusion_ExprMulScalarVar._ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(_1,_2,_3,_4,_5,_6))
   elif (_6.getND()==1): # src/fusion/Expr.mbi:1411:16-30
    _7=_6.getShape()
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([(_1 if (_0 ) else _2)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulVar._ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_6,(numpy.array([_7[0],1], dtype=numpy.dtype(numpy.int32)) if (_0 ) else numpy.array([1,_7[0]], dtype=numpy.dtype(numpy.int32)))))))
   else:
    return (mosek_fusion_ExprMulVar._ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   _2=_1.numNonzeros()
   if (not _1.isSparse()): # src/fusion/Expr.mbi:1395:12-28
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,numpy.array([_3 for _3 in range(0,_2)], dtype=numpy.dtype(numpy.int64)),_1.getDataAsArray()))
   else:
    _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
    _7=_1.numColumns()
    _1.getDataAsTriplets(_4,_5,_6)
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,numpy.array([((_4[_8] * _7) + _5[_8]) for _8 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int64)),_6))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,numpy.array([_2 for _2 in range(0,(int((_1).shape[0]) * int((_1).shape[1])))], dtype=numpy.dtype(numpy.int64)),numpy.array([_1[_3,_4] for _3 in range(0,int((_1).shape[0])) for _4 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,(_1._inst),(_1._cof)))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=_0.getShape()
   if ((_0.getSize()==int((_1).shape[0])) and (int((_2).shape[0]) > 1)): # src/fusion/Expr.mbi:1377:12-54
    _3=0
    for _4 in range(0,int((_2).shape[0])):
     if (_2[_4] > 1): # src/fusion/Expr.mbi:1378:62-75
      _3 += 1
    if (_3 > 1): # src/fusion/Expr.mbi:1379:14-27
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
    else:
     _5=numpy.array([numpy.int32(_0.getSize())], dtype=numpy.dtype(numpy.int32))
     return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3D(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_5,_0),_1))
   else:
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3D(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_1,_0))
  @staticmethod
  def _match_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _dot__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(_1,_0))
  @staticmethod
  def _match_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2_3D(_1,_0))
  @staticmethod
  def _match_outer__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_outer__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _outer_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._outer__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=_1.getShape()
   if (int((_2).shape[0])!=1): # src/fusion/Expr.mbi:1338:12-28
    raise mosek_fusion_DimensionError._ctor_S("Arguments must be one-dimensional")
   if (_2[0]!=int((_0).shape[0])): # src/fusion/Expr.mbi:1340:12-31
    raise mosek_fusion_DimensionError._ctor_S("Argument lengths do not match")
   _3=_1.eval()
   return (mosek.fusion.Expr.__outer_1_I_3J_3J_3D_3D_3J_3D_3IIZ((_3.shape)[0],(_3.ptrb),(_3.subj),(_3.cof),(_3.bfix),(_3.inst),_0,numpy.array([_4 for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),int((_0).shape[0]),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((_0.getND()!=1) or (_0.getND()!=1)): # src/fusion/Expr.mbi:1318:12-44
    raise mosek_fusion_DimensionError._ctor_S("Arguments must be one-dimensional")
   _2=_0.eval()
   return (mosek.fusion.Expr.__outer_1_I_3J_3J_3D_3D_3J_3D_3IIZ((_2.shape)[0],(_2.ptrb),(_2.subj),(_2.cof),(_2.bfix),(_2.inst),_1,numpy.array([_3 for _3 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32)),int((_1).shape[0]),False))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   _2=_1.getShape()
   if (not ((int((_2).shape[0])==1) or ((int((_2).shape[0])==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1295:13-1296:59
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   if ((_0._dimj)!=1): # src/fusion/Expr.mbi:1298:12-23
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   _4=_0
   if   isinstance(_4,mosek_fusion_DenseMatrix):
    m=_4
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_2[0],(m._data),None,int(((m._data)).shape[0]),True))
   else:
    mx=_4
    _4=numpy.zeros((mx.numNonzeros(),), dtype=numpy.dtype(numpy.float64))
    _5=numpy.zeros((mx.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((mx.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
    mx.getDataAsTriplets(_6,_5,_4)
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_2[0],_4,_6,(mx._dimi),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   _2=_0.getShape()
   if (not ((_0.getND()==1) or ((_0.getND()==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1271:13-1272:56
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   if ((_1._dimj)!=1): # src/fusion/Expr.mbi:1274:12-23
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   _4=_1
   if   isinstance(_4,mosek_fusion_DenseMatrix):
    m=_4
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_2[0],(m._data),None,int(((m._data)).shape[0]),False))
   else:
    mx=_4
    _4=numpy.zeros((mx.numNonzeros(),), dtype=numpy.dtype(numpy.float64))
    _5=numpy.zeros((mx.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_1.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
    mx.getDataAsTriplets(_6,_5,_4)
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_0.getShape()[0],_4,_6,(mx._dimi),False))
  @staticmethod
  def _match_outer__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_outer__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _outer_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._outer__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer__3DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=_1.getShape()
   if (not ((_1.getND()==1) or ((_1.getND()==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1261:13-1262:57
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_2[0],_0,None,int((_0).shape[0]),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=_0.getShape()
   if (not ((_0.getND()==1) or ((_0.getND()==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1251:13-1252:56
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_2[0],_1,None,int((_1).shape[0]),False))
  @staticmethod
  def __outer_1_alt_I_3J_3J_3D_3D_3J_3D_3IIZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _8=numpy.int32(_t__8)
   _9=_t__9
   _1 = mosek_fusion_Expr.__outer_1_I_3J_3J_3D_3D_3J_3D_3IIZ(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __outer_1_I_3J_3J_3D_3D_3J_3D_3IIZ(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   _10=(mosek.fusion.Set._make_II(_0,_8) if ((not _9) ) else mosek.fusion.Set._make_II(_8,_0))
   _11=(int((_6).shape[0]) * int((_5).shape[0]))
   _12=(int((_6).shape[0]) * int((_2).shape[0]))
   _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
   _14=(numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64)) if ((_4 is not None) ) else None)
   _15=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
   _16=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   _17=numpy.zeros(((_11 + 1),), dtype=numpy.dtype(numpy.int64))
   _18=numpy.int32(_17[(int((_17).shape[0]) - 1)])
   if (not _9): # src/fusion/Expr.mbi:1176:12-25
    _19=0
    _20=0
    for _21 in range(0,int((_5).shape[0])):
     _22=(_1[(_21 + 1)] - _1[_21])
     for _23 in range(0,int((_6).shape[0])):
      _5[_19] = ((_5[_21] * _8) + _7[_23])
      _17[(_19 + 1)] = (_17[_19] + _22)
      _19 += 1
      for _24 in range(_1[_21],_1[(_21 + 1)]):
       _16[_20] = _2[_24]
       _15[_20] = (_3[_24] * _6[_23])
       _20 += 1
    if (_14 is not None): # src/fusion/Expr.mbi:1199:14-26
     _25=0
     for _26 in range(0,int((_5).shape[0])):
      for _27 in range(0,int((_6).shape[0])):
       _14[_25] = (_6[_27] * _4[_26])
       _25 += 1
   else:
    _28=0
    _29=0
    for _30 in range(0,int((_6).shape[0])):
     _31=_6[_30]
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(_2,0,_16,_29,_18)
     for _32 in range(0,_18):
      _15[(_29 + _32)] = (_3[_32] * _6[_30])
     for _33 in range(0,int((_5).shape[0])):
      _34=(_1[(_33 + 1)] - _1[_33])
      _5[_28] = ((_5[_33] * _8) + _7[_30])
      _17[(_28 + 1)] = (_17[_28] + _34)
      _28 += 1
     _29 += _18
    if (_14 is not None): # src/fusion/Expr.mbi:1231:14-26
     _35=0
     for _36 in range(0,int((_6).shape[0])):
      _37=_6[_36]
      for _38 in range(0,int((_5).shape[0])):
       _14[_35] = (_4[_38] * _37)
       _35 += 1
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3J(_17,_16,_15,_14,_10,_13))
  @staticmethod
  def __outer_1_alt_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.int32(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _6=(mosek.fusion.Set._make_II(_1,_4) if ((not _5) ) else mosek.fusion.Set._make_II(_4,_1))
   _7=(None if ((_4==int((_2).shape[0])) ) else numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.int64)))
   _8=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.float64))
   _9=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.float64))
   _10=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.int64))
   _11=numpy.zeros((((int((_2).shape[0]) * _1) + 1),), dtype=numpy.dtype(numpy.int64))
   if (_4==int((_2).shape[0])): # src/fusion/Expr.mbi:1082:12-25
    _12=0
    if (not _5): # src/fusion/Expr.mbi:1085:14-27
     for _13 in range(0,_1):
      for _14 in range(0,_4):
       _11[(_12 + 1)] = (_12 + 1)
       _10[_12] = numpy.int64(_13)
       _9[_12] = _2[_14]
       _12 += 1
    else:
     for _15 in range(0,_4):
      for _16 in range(0,_1):
       _11[(_12 + 1)] = (_12 + 1)
       _10[_12] = numpy.int64(_16)
       _9[_12] = _2[_15]
       _12 += 1
   else:
    _17=0
    if (not _5): # src/fusion/Expr.mbi:1111:14-27
     for _18 in range(0,_1):
      for _19 in range(0,int((_2).shape[0])):
       _11[(_17 + 1)] = (_17 + 1)
       _10[_17] = numpy.int64(_18)
       _9[_17] = _2[_19]
       _7[_17] = ((_18 * _4) + _3[_19])
       _17 += 1
    else:
     for _20 in range(0,int((_2).shape[0])):
      for _21 in range(0,_1):
       _11[(_17 + 1)] = (_17 + 1)
       _10[_17] = numpy.int64(_21)
       _9[_17] = _2[_20]
       _7[_17] = ((_3[_20] * _1) + _21)
       _17 += 1
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3J(_11,_10,_9,_8,_6,_7))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Expression_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None): # src/fusion/Expr.mbi:1054:12-25
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    _2=_0[_1]
    if (_2 is None): # src/fusion/Expr.mbi:1058:14-24
     raise ValueError("Arguments for stack may not be null")
    for _3 in range(0,int((_2).shape[0])):
     if (_2[_3] is None): # src/fusion/Expr.mbi:1060:16-29
      raise ValueError("Arguments for stack may not be null")
   _4=numpy.array([mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0[_5],1) for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_4,0))
  @staticmethod
  def _match_vstack_DDD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DDD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DDD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDD(numpy.float64(__0),numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_DDD(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _vstack_DDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DD(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None): # src/fusion/Expr.mbi:994:12-25
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] is None): # src/fusion/Expr.mbi:996:14-30
     raise ValueError("Arguments for vstack may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   if ((_0 is None) or ((_1 is None) or (_2 is None))): # src/fusion/Expr.mbi:983:99-137
    raise ValueError("Arguments e1, e2 and e3 may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DD(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _hstack_DDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None): # src/fusion/Expr.mbi:908:12-25
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] is None): # src/fusion/Expr.mbi:910:14-30
     raise ValueError("Arguments for hstack may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0,1))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(numpy.int32(__0),_1,numpy.float64(__2),numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DD(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(numpy.int32(__0),numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),numpy.float64(__2),_3)
  @staticmethod
  def _stack_IDDLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,numpy.float64(__2))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Expression_2(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_1,_0))
  @staticmethod
  def __stack_1_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __stack_1__3Lmosek_4fusion_4Expression_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])==1): # src/fusion/Expr.mbi:857:12-27
    return (_0[0])
   else:
    return (mosek_fusion_ExprStack._ctor__3Lmosek_4fusion_4Expression_2I(mosek.fusion.Expr.__promote__3Lmosek_4fusion_4Expression_2I(_0,_1),_1))
  @staticmethod
  def __promote_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Expr.__promote__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __promote__3Lmosek_4fusion_4Expression_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=int((_0).shape[0])
   _3=numpy.array([_0[_4].getND() for _4 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   _5=_3[0]
   _6=_3[0]
   for _7 in range(1,_2):
    if (_3[_7] < _6): # src/fusion/Expr.mbi:829:14-28
     _6 = _3[_7]
    if (_3[_7] > _5): # src/fusion/Expr.mbi:830:14-28
     _5 = _3[_7]
   if (_5 < _1): # src/fusion/Expr.mbi:833:12-23
    _5 = _1
   if (_6 < _5): # src/fusion/Expr.mbi:834:12-25
    _8=numpy.ndarray((_2,), dtype=numpy.dtype(object))
    _9=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
    for _10 in range(0,_2):
     if (_0[_10].getND()==_5): # src/fusion/Expr.mbi:839:16-41
      _8[_10] = _0[_10]
     else:
      _11=_0[_10].getShape()
      for _12 in range(0,int((_11).shape[0])):
       _9[_12] = _11[_12]
      for _13 in range(int((_11).shape[0]),_5):
       _9[_13] = 1
      _8[_10] = mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_9,_0[_10])
    return (_8)
   else:
    return (_0)
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if (_1 <= 0): # src/fusion/Expr.mbi:816:12-18
    raise mosek_fusion_DimensionError._ctor_S("Cannot repeat Expression 0 or less times")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0 for _3 in range(0,_1)], dtype=numpy.dtype(object)),_2))
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprWSum._ctor__3Lmosek_4fusion_4Expression_2_3D(_0,numpy.array([1.0 for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None): # src/fusion/Expr.mbi:735:12-22
    raise ValueError("Argument vs may not be null")
   if (int((_0).shape[0])==0): # src/fusion/Expr.mbi:736:12-24
    return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3JI(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),1))
   if ((int((_0).shape[0]) > 0) and (_0[0] is None)): # src/fusion/Expr.mbi:739:12-41
    raise ValueError("Argument vs may contain null")
   _1=_0[0].getND()
   for _2 in range(1,int((_0).shape[0])):
    if (_1 < _0[_2].getND()): # src/fusion/Expr.mbi:740:61-79
     _1 = _0[_2].getND()
   _3=numpy.zeros((int((_0).shape[0]),_1,), dtype=numpy.dtype(numpy.int32))
   for _4 in range(0,int((_0).shape[0])):
    _5=_0[_4].getShape()
    for _6 in range(0,int((_5).shape[0])):
     _3[_4,_6] = _5[_6]
    for _7 in range(int((_5).shape[0]),_1):
     _3[_4,_7] = 1
   for _8 in range(1,int((_0).shape[0])):
    for _9 in range(0,_1):
     if (_3[0,_9]!=_3[_8,_9]): # src/fusion/Expr.mbi:750:16-42
      raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _10=numpy.array([_3[0,_11] for _11 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _12=1
   for _13 in range(0,_1):
    _12 *= _10[_13]
   _14=0
   _15=0
   for _16 in range(0,int((_0).shape[0])):
    _17=_0[_16].numInst()
    _14 += _17
    _15 = (_15 if ((_15 > _17) ) else _17)
   _18=numpy.zeros(((_12 + 1),), dtype=numpy.dtype(numpy.int64))
   _19=numpy.zeros((_14,), dtype=numpy.dtype(numpy.int64))
   _20=numpy.array([1.0 for _21 in range(0,_14)], dtype=numpy.dtype(numpy.float64))
   _22=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int64))
   _23=numpy.zeros((_15,), dtype=numpy.dtype(numpy.int64))
   for _24 in range(0,int((_0).shape[0])):
    _25=_0[_24].inst(0,_22,0,_23)
    for _26 in range(0,_25):
     _18[(_22[_26] + 1)] += 1
   for _27 in range(0,_12):
    _18[(_27 + 1)] += _18[_27]
   for _28 in range(0,int((_0).shape[0])):
    _29=_0[_28].inst(0,_22,0,_23)
    for _30 in range(0,_29):
     _19[_18[_22[_30]]] = _23[_30]
     _18[_22[_30]] += 1
   for _31 in range(0,_12):
    _18[(_12 - _31)] = _18[((_12 - _31) - 1)]
   _18[0] = 0
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3JI(_18,_19,_20,numpy.array([0.0 for _32 in range(0,_12)], dtype=numpy.dtype(numpy.float64)),_10,None,1))
  @staticmethod
  def __add_1_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def __add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   _4=_0.getND()
   _5=_2.getND()
   if (_4==_5): # src/fusion/Expr.mbi:695:12-22
    return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(_0,_2,_1,_3))
   else:
    _6=(_4 if ((_4 > _5) ) else _5)
    _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
    if (_4 < _5): # src/fusion/Expr.mbi:700:14-23
     _8=_0.getShape()
     for _9 in range(0,_4):
      _7[_9] = _8[_9]
     for _10 in range(_4,_6):
      _7[_10] = 1
     return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_7,_0),_2,_1,_3))
    else:
     _11=_2.getShape()
     for _12 in range(0,_5):
      _7[_12] = _11[_12]
     for _13 in range(_5,_6):
      _7[_13] = 1
     return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(_0,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_7,_2),_1,_3))
  @staticmethod
  def _match_transpose_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_transpose_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _transpose_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._transpose_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _transpose_Lmosek_4fusion_4Expression_2(_0):
   if (_0.getND()==0): # src/fusion/Expr.mbi:678:16-30
    return (_0)
   elif (_0.getND()==1): # src/fusion/Expr.mbi:680:16-30
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_0.getDim(0)], dtype=numpy.dtype(numpy.int32)),_0))
   elif (_0.getND()==2): # src/fusion/Expr.mbi:682:16-30
    return (mosek_fusion_ExprTranspose._ctor_Lmosek_4fusion_4Expression_2(_0))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Incorrect number of dimensions for transpose")
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mulElm__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _sub_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3ID(_1.getShape(),_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3ID(_0.getShape(),_1),(- 1.0)))
  @staticmethod
  def _match_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _sub__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1,(- 1.0)))
  @staticmethod
  def _match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),1.0))
  @staticmethod
  def _match_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _add_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3ID(_1.getShape(),_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3ID(_0.getShape(),_1),1.0))
  @staticmethod
  def _match_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _add__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3_5D(_0),1.0))
  @staticmethod
  def _match_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3D(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3D(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1,1.0))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   mosek.fusion.BaseExpression._storeexpr_Lmosek_4fusion_4WorkStack_2_3I_3I_3J_3J_3D_3D(_0,self.__shape,numpy.array([numpy.int32(self.__ptrb[_3]) for _3 in range(0,int((self.__ptrb).shape[0]))], dtype=numpy.dtype(numpy.int32)),self.__inst,self.__subj,self.__cof_v,self.__bfix)
  @staticmethod
  def __validateData_alt__3J_3J_3D_3D_3I_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Expr.__validateData__3J_3J_3D_3D_3I_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validateData__3J_3J_3D_3D_3I_3J(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   if (_4 is None): # src/fusion/Expr.mbi:424:16-29
    raise mosek_fusion_ExpressionError._ctor_S("Array 'shape' in expression is null")
   _6=(int((_0).shape[0]) - 1)
   _7=_0[(int((_0).shape[0]) - 1)]
   _8=int((_4).shape[0])
   _9=1
   for _10 in range(0,_8):
    _9 *= _4[_10]
   if (int((_0).shape[0]) < 1): # src/fusion/Expr.mbi:430:16-29
    raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong size")
   if (_7!=int((_1).shape[0])): # src/fusion/Expr.mbi:432:17-36
    raise mosek_fusion_ExpressionError._ctor_S("Array 'subj' in expression has wrong size")
   if (_7!=int((_2).shape[0])): # src/fusion/Expr.mbi:434:17-35
    raise mosek_fusion_ExpressionError._ctor_S("Array 'cof' in expression has wrong size")
   if ((_3 is None) or (_6!=int((_3).shape[0]))): # src/fusion/Expr.mbi:436:17-54
    raise mosek_fusion_ExpressionError._ctor_S("Array 'bfix' in expression has wrong length")
   if ((_5 is not None) and (int((_5).shape[0]) < _9)): # src/fusion/Expr.mbi:439:12-45
    if (int((_5).shape[0])!=(int((_0).shape[0]) - 1)): # src/fusion/Expr.mbi:441:14-38
     raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' in expression has wrong length")
    if (int((_5).shape[0]) > 0): # src/fusion/Expr.mbi:444:14-27
     if ((_5[0] < 0) or (_5[0] >= _9)): # src/fusion/Expr.mbi:446:16-46
      raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' contains an invalid index")
     _11=True
     _12=_9
     for _13 in range(1,int((_5).shape[0])):
      _11 = (_11 and ((_5[_13] >= 0) and ((_5[_13] < _12) and (_5[_13] > _5[(_13 - 1)]))))
     if (not _11): # src/fusion/Expr.mbi:459:16-35
      raise mosek_fusion_ExpressionError._ctor_S("Invalid array 'inst'")
   else:
    if (_9!=(int((_0).shape[0]) - 1)): # src/fusion/Expr.mbi:464:14-37
     raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong length")
   _14=False
   _15=False
   if (_0[0]!=0): # src/fusion/Expr.mbi:470:12-25
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
   _16=True
   for _17 in range(0,_6):
    _16 = (_16 and (_0[_17] <= _0[(_17 + 1)]))
   if (not _16): # src/fusion/Expr.mbi:476:12-27
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
  @staticmethod
  def __extractModel_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__extractModel__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __extractModel__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return ((None if (((_0 is None) or (int((_0).shape[0])==0)) ) else _0[0].getModel()))
 return Expr
mosek_fusion_Expr=__mk_mosek_fusion_Expr()
del __mk_mosek_fusion_Expr
#BEFORE CLASS
def __mk_mosek_fusion_WorkStack():
 class WorkStack(object):
  __slots__ = ['cof_base','bfix_base','nidxs_base','sp_base','shape_base','ptr_base','hassp','nelem','nnz','nd','pf64','pi64','pi32','f64','i64','i32']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.WorkStack.ctor()')
  def peek_hassp(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1hassp_(*args): # 
      return self._peek_1hassp_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1hassp_(*args): # 
      return self._peek_1hassp_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_hassp('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_hassp()')
  def peeki32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peeki32_(*args): # 
      return self._peeki32_(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki32_(*args): # 
      return self._peeki32_alt_(*args)
    elif mosek_fusion_WorkStack._match_peeki32_I(*args): # int32
      return self._peeki32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki32_I(*args): # int32
      return self._peeki32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peeki32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peeki32()\n\tmosek.fusion.WorkStack.peeki32(int32)')
  def peekf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peekf64_(*args): # 
      return self._peekf64_(*args)
    elif mosek_fusion_WorkStack._match_alt_peekf64_(*args): # 
      return self._peekf64_alt_(*args)
    elif mosek_fusion_WorkStack._match_peekf64_I(*args): # int32
      return self._peekf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peekf64_I(*args): # int32
      return self._peekf64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peekf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peekf64()\n\tmosek.fusion.WorkStack.peekf64(int32)')
  def pushi32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pushi32_I(*args): # int32
      return self._pushi32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_pushi32_I(*args): # int32
      return self._pushi32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list pushi32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushi32(int32)')
  def peek_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1expr_(*args): # 
      return self._peek_1expr_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1expr_(*args): # 
      return self._peek_1expr_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_expr()')
  def pushf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pushf64_D(*args): # double
      return self._pushf64_D(*args)
    elif mosek_fusion_WorkStack._match_alt_pushf64_D(*args): # double
      return self._pushf64_alt_D(*args)
    else:
      raise ValueError('Invalid argument list pushf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushf64(double)')
  def alloc_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_alloc_1expr_IIIZ(*args): # int32,int32,int32,bool
      return self._alloc_1expr_IIIZ(*args)
    elif mosek_fusion_WorkStack._match_alt_alloc_1expr_IIIZ(*args): # int32,int32,int32,bool
      return self._alloc_1expr_alt_IIIZ(*args)
    else:
      raise ValueError('Invalid argument list alloc_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloc_expr(int32,int32,int32,bool)')
  def peek_nd(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nd_(*args): # 
      return self._peek_1nd_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nd_(*args): # 
      return self._peek_1nd_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nd()')
  def pushi64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pushi64_J(*args): # int64
      return self._pushi64_J(*args)
    elif mosek_fusion_WorkStack._match_alt_pushi64_J(*args): # int64
      return self._pushi64_alt_J(*args)
    else:
      raise ValueError('Invalid argument list pushi64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushi64(int64)')
  def ensuref64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensuref64_I(*args): # int32
      return self._ensuref64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensuref64_I(*args): # int32
      return self._ensuref64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensuref64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensuref64(int32)')
  def peeki64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peeki64_(*args): # 
      return self._peeki64_(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki64_(*args): # 
      return self._peeki64_alt_(*args)
    elif mosek_fusion_WorkStack._match_peeki64_I(*args): # int32
      return self._peeki64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki64_I(*args): # int32
      return self._peeki64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peeki64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peeki64()\n\tmosek.fusion.WorkStack.peeki64(int32)')
  def ensurei32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensurei32_I(*args): # int32
      return self._ensurei32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensurei32_I(*args): # int32
      return self._ensurei32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensurei32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensurei32(int32)')
  def popf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_popf64_(*args): # 
      return self._popf64_(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_(*args): # 
      return self._popf64_alt_(*args)
    elif mosek_fusion_WorkStack._match_popf64_I(*args): # int32
      return self._popf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_I(*args): # int32
      return self._popf64_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popf64_I_3DI(*args): # int32,[]double,int32
      return self._popf64_I_3DI(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_I_3DI(*args): # int32,[]double,int32
      return self._popf64_alt_I_3DI(*args)
    else:
      raise ValueError('Invalid argument list popf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popf64()\n\tmosek.fusion.WorkStack.popf64(int32)\n\tmosek.fusion.WorkStack.popf64(int32,array(double,ndim=1),int32)')
  def popi64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_popi64_(*args): # 
      return self._popi64_(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_(*args): # 
      return self._popi64_alt_(*args)
    elif mosek_fusion_WorkStack._match_popi64_I(*args): # int32
      return self._popi64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_I(*args): # int32
      return self._popi64_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popi64_I_3JI(*args): # int32,[]int64,int32
      return self._popi64_I_3JI(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_I_3JI(*args): # int32,[]int64,int32
      return self._popi64_alt_I_3JI(*args)
    else:
      raise ValueError('Invalid argument list popi64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popi64()\n\tmosek.fusion.WorkStack.popi64(int32)\n\tmosek.fusion.WorkStack.popi64(int32,array(int64,ndim=1),int32)')
  def popi32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_popi32_(*args): # 
      return self._popi32_(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_(*args): # 
      return self._popi32_alt_(*args)
    elif mosek_fusion_WorkStack._match_popi32_I(*args): # int32
      return self._popi32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_I(*args): # int32
      return self._popi32_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popi32_I_3II(*args): # int32,[]int32,int32
      return self._popi32_I_3II(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_I_3II(*args): # int32,[]int32,int32
      return self._popi32_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list popi32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popi32()\n\tmosek.fusion.WorkStack.popi32(int32)\n\tmosek.fusion.WorkStack.popi32(int32,array(int32,ndim=1),int32)')
  def alloci64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_alloci64_I(*args): # int32
      return self._alloci64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_alloci64_I(*args): # int32
      return self._alloci64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloci64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloci64(int32)')
  def move_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_move_1expr_Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack
      return self._move_1expr_Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_WorkStack._match_alt_move_1expr_Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack
      return self._move_1expr_alt_Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list move_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.move_expr(mosek.fusion.WorkStack)')
  def ensurei64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensurei64_I(*args): # int32
      return self._ensurei64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensurei64_I(*args): # int32
      return self._ensurei64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensurei64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensurei64(int32)')
  def peek_nnz(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nnz_(*args): # 
      return self._peek_1nnz_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nnz_(*args): # 
      return self._peek_1nnz_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nnz('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nnz()')
  def clear(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_clear_(*args): # 
      return self._clear_(*args)
    elif mosek_fusion_WorkStack._match_alt_clear_(*args): # 
      return self._clear_alt_(*args)
    else:
      raise ValueError('Invalid argument list clear('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.clear()')
  def peek_nelem(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nelem_(*args): # 
      return self._peek_1nelem_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nelem_(*args): # 
      return self._peek_1nelem_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nelem('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nelem()')
  def ensure_sparsity(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensure_1sparsity_(*args): # 
      return self._ensure_1sparsity_(*args)
    elif mosek_fusion_WorkStack._match_alt_ensure_1sparsity_(*args): # 
      return self._ensure_1sparsity_alt_(*args)
    else:
      raise ValueError('Invalid argument list ensure_sparsity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensure_sparsity()')
  def alloci32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_alloci32_I(*args): # int32
      return self._alloci32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_alloci32_I(*args): # int32
      return self._alloci32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloci32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloci32(int32)')
  def allocf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_allocf64_I(*args): # int32
      return self._allocf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_allocf64_I(*args): # int32
      return self._allocf64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list allocf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.allocf64(int32)')
  def peek_dim(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1dim_I(*args): # int32
      return self._peek_1dim_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1dim_I(*args): # int32
      return self._peek_1dim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peek_dim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_dim(int32)')
  def pop_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pop_1expr_(*args): # 
      return self._pop_1expr_(*args)
    elif mosek_fusion_WorkStack._match_alt_pop_1expr_(*args): # 
      return self._pop_1expr_alt_(*args)
    else:
      raise ValueError('Invalid argument list pop_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pop_expr()')
  def __repr__(self): return 'mosek.fusion.WorkStack'
  @staticmethod
  def _ctor_():
    o = WorkStack.__new__(WorkStack)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   self.i32 = numpy.zeros((256,), dtype=numpy.dtype(numpy.int32))
   self.i64 = numpy.zeros((256,), dtype=numpy.dtype(numpy.int64))
   self.f64 = numpy.zeros((256,), dtype=numpy.dtype(numpy.float64))
   self.pi32 = 0
   self.pi64 = 0
   self.pf64 = 0
   self.nd = 0
   self.nnz = 0
   self.nelem = 0
   self.hassp = False
   self.ptr_base = 0
   self.shape_base = 0
   self.sp_base = 0
   self.nidxs_base = 0
   self.bfix_base = 0
   self.cof_base = 0
  @staticmethod
  def _match_peek_1hassp_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1hassp_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1hassp_alt_(self,):
    return self._peek_1hassp_()
  def _peek_1hassp_(self,):
   return ((self.peeki32((3 + self.peek_nd()))!=0))
  @staticmethod
  def _match_peek_1nnz_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nnz_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nnz_alt_(self,):
    return self._peek_1nnz_()
  def _peek_1nnz_(self,):
   return numpy.int32(self.peeki32((2 + self.peek_nd())))
  @staticmethod
  def _match_peek_1nelem_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nelem_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nelem_alt_(self,):
    return self._peek_1nelem_()
  def _peek_1nelem_(self,):
   return numpy.int32(self.peeki32((1 + self.peek_nd())))
  @staticmethod
  def _match_peek_1dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peek_1dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peek_1dim_alt_I(self,_t__0):
    return self._peek_1dim_I(numpy.int32(__0))
  def _peek_1dim_I(self,_0):
   return numpy.int32(self.peeki32((_0 + 1)))
  @staticmethod
  def _match_peek_1nd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nd_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nd_alt_(self,):
    return self._peek_1nd_()
  def _peek_1nd_(self,):
   return numpy.int32(self.peeki32())
  @staticmethod
  def _match_alloc_1expr_IIIZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_alloc_1expr_IIIZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Z__(_3))
  def _alloc_1expr_alt_IIIZ(self,_t__0,_t__1,_t__2,_t__3):
    return self._alloc_1expr_IIIZ(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2),_3)
  def _alloc_1expr_IIIZ(self,_0,_1,_2,_3):
   self.cof_base = self.allocf64(_2)
   self.bfix_base = self.allocf64(_1)
   self.nidxs_base = self.alloci64(_2)
   self.sp_base = (self.alloci64(_1) if (_3 ) else (- 9999))
   self.ptr_base = self.alloci32((_1 + 1))
   self.pushi32((1 if (_3 ) else 0))
   self.pushi32(_2)
   self.pushi32(_1)
   self.shape_base = self.alloci32(_0)
   self.pushi32(_0)
   (self.nd) = _0
   (self.nelem) = _1
   (self.nnz) = _2
   (self.hassp) = _3
  @staticmethod
  def _match_move_1expr_Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0))
  @staticmethod
  def _match_alt_move_1expr_Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0))
  def _move_1expr_alt_Lmosek_4fusion_4WorkStack_2(self,_t__0):
    return self._move_1expr_Lmosek_4fusion_4WorkStack_2(_0)
  def _move_1expr_Lmosek_4fusion_4WorkStack_2(self,_0):
   _1=self.pi32
   _2=self.pi64
   _3=self.pf64
   self.pop_expr()
   _4=_0.alloci32((_1 - self.pi32))
   _5=_0.alloci64((_2 - self.pi64))
   _6=_0.allocf64((_3 - self.pf64))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,self.pi32,(_0.i32),_4,(_1 - self.pi32))
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,self.pi64,(_0.i64),_5,(_2 - self.pi64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,self.pf64,(_0.f64),_6,(_3 - self.pf64))
  @staticmethod
  def _match_peek_1expr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1expr_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1expr_alt_(self,):
    return self._peek_1expr_()
  def _peek_1expr_(self,):
   _0=self.pi32
   _1=self.pi64
   _2=self.pf64
   self.pop_expr()
   self.pi32 = _0
   self.pi64 = _1
   self.pf64 = _2
  @staticmethod
  def _match_pop_1expr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_pop_1expr_(*args):
    if len(args) != 0: return False
    return True
  def _pop_1expr_alt_(self,):
    return self._pop_1expr_()
  def _pop_1expr_(self,):
   self.nd = self.popi32()
   self.shape_base = self.popi32(self.nd)
   self.nelem = self.popi32()
   self.nnz = self.popi32()
   self.hassp = (self.popi32()!=0)
   self.ptr_base = self.popi32((self.nelem + 1))
   self.sp_base = (self.popi64(self.nelem) if (self.hassp ) else (- 9999))
   self.nidxs_base = self.popi64(self.nnz)
   self.bfix_base = self.popf64(self.nelem)
   self.cof_base = self.popf64(self.nnz)
  @staticmethod
  def _match_ensure_1sparsity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_ensure_1sparsity_(*args):
    if len(args) != 0: return False
    return True
  def _ensure_1sparsity_alt_(self,):
    return self._ensure_1sparsity_()
  def _ensure_1sparsity_(self,):
   _0=self.i32[(self.pi32 - 1)]
   _1=(self.i32[((self.pi32 - _0) - 3)]!=0)
   _2=self.i32[((self.pi32 - _0) - 1)]
   if (not _1): # src/fusion/BaseExpression.monty:238:12-21
    self.i32[((self.pi32 - _0) - 3)] = 1
    _3=self.alloci64(_2)
    for _4 in range(0,_2):
     self.i64[_3] = _4
  @staticmethod
  def _match_clear_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clear_(*args):
    if len(args) != 0: return False
    return True
  def _clear_alt_(self,):
    return self._clear_()
  def _clear_(self,):
   self.pi32 = 0
   self.pi64 = 0
   self.pf64 = 0
  @staticmethod
  def _match_allocf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_allocf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _allocf64_alt_I(self,_t__0):
    return self._allocf64_I(numpy.int32(__0))
  def _allocf64_I(self,_0):
   self.ensuref64(_0)
   _1=self.pf64
   self.pf64 += _0
   return numpy.int32(_1)
  @staticmethod
  def _match_alloci64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloci64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloci64_alt_I(self,_t__0):
    return self._alloci64_I(numpy.int32(__0))
  def _alloci64_I(self,_0):
   self.ensurei64(_0)
   _1=self.pi64
   self.pi64 += _0
   return numpy.int32(_1)
  @staticmethod
  def _match_alloci32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloci32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloci32_alt_I(self,_t__0):
    return self._alloci32_I(numpy.int32(__0))
  def _alloci32_I(self,_0):
   if (_0 > 0): # src/fusion/BaseExpression.monty:162:12-17
    self.ensurei32(_0)
    _1=self.pi32
    self.pi32 += _0
    return numpy.int32(_1)
   else:
    return numpy.int32(0)
  @staticmethod
  def _match_pushf64_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_pushf64_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _pushf64_alt_D(self,_t__0):
    return self._pushf64_D(numpy.float64(__0))
  def _pushf64_D(self,_0):
   self.ensuref64(1)
   self.f64[self.pf64] = _0
   self.pf64 += 1
  @staticmethod
  def _match_pushi64_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_pushi64_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _pushi64_alt_J(self,_t__0):
    return self._pushi64_J(numpy.int64(__0))
  def _pushi64_J(self,_0):
   self.ensurei64(1)
   self.i64[self.pi64] = _0
   self.pi64 += 1
  @staticmethod
  def _match_pushi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_pushi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _pushi32_alt_I(self,_t__0):
    return self._pushi32_I(numpy.int32(__0))
  def _pushi32_I(self,_0):
   self.ensurei32(1)
   self.i32[self.pi32] = _0
   self.pi32 += 1
  @staticmethod
  def _match_ensuref64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ensuref64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _ensuref64_alt_I(self,_t__0):
    return self._ensuref64_I(numpy.int32(__0))
  def _ensuref64_I(self,_0):
   if ((self.pf64 + _0) > int((self.f64).shape[0])): # src/fusion/BaseExpression.monty:126:12-29
    _1=((int((self.f64).shape[0]) * 2) if ((_0 < int((self.f64).shape[0])) ) else (int((self.f64).shape[0]) + _0))
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,0,_2,0,self.pf64)
    self.f64 = _2
  @staticmethod
  def _match_ensurei64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ensurei64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _ensurei64_alt_I(self,_t__0):
    return self._ensurei64_I(numpy.int32(__0))
  def _ensurei64_I(self,_0):
   if ((self.pi64 + _0) > int((self.i64).shape[0])): # src/fusion/BaseExpression.monty:116:12-29
    _1=(int((self.i64).shape[0]) + (int((self.i64).shape[0]) if ((_0 < int((self.i64).shape[0])) ) else _0))
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,0,_2,0,self.pi64)
    self.i64 = _2
  @staticmethod
  def _match_ensurei32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ensurei32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _ensurei32_alt_I(self,_t__0):
    return self._ensurei32_I(numpy.int32(__0))
  def _ensurei32_I(self,_0):
   if ((self.pi32 + _0) > int((self.i32).shape[0])): # src/fusion/BaseExpression.monty:106:12-29
    _1=((int((self.i32).shape[0]) * 2) if ((_0 < int((self.i32).shape[0])) ) else (int((self.i32).shape[0]) + _0))
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,0,_2,0,self.pi32)
    self.i32 = _2
  @staticmethod
  def _match_popf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_popf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _popf64_alt_I(self,_t__0):
    return self._popf64_I(numpy.int32(__0))
  def _popf64_I(self,_0):
   self.pf64 -= _0
   return numpy.int32(self.pf64)
  @staticmethod
  def _match_popi64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_popi64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _popi64_alt_I(self,_t__0):
    return self._popi64_I(numpy.int32(__0))
  def _popi64_I(self,_0):
   self.pi64 -= _0
   return numpy.int32(self.pi64)
  @staticmethod
  def _match_popi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_popi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _popi32_alt_I(self,_t__0):
    return self._popi32_I(numpy.int32(__0))
  def _popi32_I(self,_0):
   self.pi32 -= _0
   return numpy.int32(self.pi32)
  @staticmethod
  def _match_popf64_I_3DI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_popf64_I_3DI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_I__(_2))
  def _popf64_alt_I_3DI(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int32(_t__2)
   _1 = self._popf64_I_3DI(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _popf64_I_3DI(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self.pf64 -= _0
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,self.pf64,_1,_2,_0)
  @staticmethod
  def _match_popi64_I_3JI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_popi64_I_3JI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2))
  def _popi64_alt_I_3JI(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _1 = self._popi64_I_3JI(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _popi64_I_3JI(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self.pi64 -= _0
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,self.pi64,_1,_2,_0)
  @staticmethod
  def _match_popi32_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_popi32_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2))
  def _popi32_alt_I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self._popi32_I_3II(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _popi32_I_3II(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self.pi32 -= _0
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,self.pi32,_1,_2,_0)
  @staticmethod
  def _match_popf64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popf64_(*args):
    if len(args) != 0: return False
    return True
  def _popf64_alt_(self,):
    return self._popf64_()
  def _popf64_(self,):
   self.pf64 -= 1
   return numpy.float64(self.f64[self.pf64])
  @staticmethod
  def _match_popi64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popi64_(*args):
    if len(args) != 0: return False
    return True
  def _popi64_alt_(self,):
    return self._popi64_()
  def _popi64_(self,):
   self.pi64 -= 1
   return numpy.int64(self.i64[self.pi64])
  @staticmethod
  def _match_popi32_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popi32_(*args):
    if len(args) != 0: return False
    return True
  def _popi32_alt_(self,):
    return self._popi32_()
  def _popi32_(self,):
   self.pi32 -= 1
   return numpy.int32(self.i32[self.pi32])
  @staticmethod
  def _match_peekf64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peekf64_(*args):
    if len(args) != 0: return False
    return True
  def _peekf64_alt_(self,):
    return self._peekf64_()
  def _peekf64_(self,):
   return numpy.float64(self.f64[(self.pf64 - 1)])
  @staticmethod
  def _match_peeki64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peeki64_(*args):
    if len(args) != 0: return False
    return True
  def _peeki64_alt_(self,):
    return self._peeki64_()
  def _peeki64_(self,):
   return numpy.int64(self.i64[(self.pi64 - 1)])
  @staticmethod
  def _match_peeki32_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peeki32_(*args):
    if len(args) != 0: return False
    return True
  def _peeki32_alt_(self,):
    return self._peeki32_()
  def _peeki32_(self,):
   return numpy.int32(self.i32[(self.pi32 - 1)])
  @staticmethod
  def _match_peekf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peekf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peekf64_alt_I(self,_t__0):
    return self._peekf64_I(numpy.int32(__0))
  def _peekf64_I(self,_0):
   return numpy.float64(self.f64[((self.pf64 - _0) - 1)])
  @staticmethod
  def _match_peeki64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peeki64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peeki64_alt_I(self,_t__0):
    return self._peeki64_I(numpy.int32(__0))
  def _peeki64_I(self,_0):
   return numpy.int64(self.i64[((self.pi64 - _0) - 1)])
  @staticmethod
  def _match_peeki32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peeki32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peeki32_alt_I(self,_t__0):
    return self._peeki32_I(numpy.int32(__0))
  def _peeki32_I(self,_0):
   return numpy.int32(self.i32[((self.pi32 - _0) - 1)])
 return WorkStack
mosek_fusion_WorkStack=__mk_mosek_fusion_WorkStack()
del __mk_mosek_fusion_WorkStack
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricExpr():
 class SymmetricExpr(object):
  __slots__ = ['_SymmetricExpr__xs','_SymmetricExpr__b','_SymmetricExpr__Ms','_SymmetricExpr__n']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricExpr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SymmetricExpr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricExpr.toString()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.SymmetricExpr: '+self._toString_()
  @staticmethod
  def _ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(n,Ms,xs,b):
    o = SymmetricExpr.__new__(SymmetricExpr)
    o._ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(n,Ms,xs,b)
    return o
  @staticmethod
  def __match_ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 4: return False
    n,Ms,xs,b, = args
    return (__arg_match_I__(n) and __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(Ms) and __arg_match__3Lmosek_4fusion_4Variable_2__(xs) and __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(b))
  @staticmethod
  def __match_alt_ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 4: return False
    n,Ms,xs,b, = args
    return (__arg_alt_match_I__(n) and __arg_alt_match__3Lmosek_4fusion_4SymmetricMatrix_2__(Ms) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(xs) and __arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(b))
  def _ctor_alt_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(self,n,Ms,xs,b):
    self._ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(numpy.int32(n),numpy.array(Ms,dtype=numpy.dtype(object)),numpy.array(xs,dtype=numpy.dtype(object)),b)
  def _ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(self,n,Ms,xs,b):
   assert Ms is None or isinstance(Ms,numpy.ndarray)
   assert xs is None or isinstance(xs,numpy.ndarray)
   (self.__n) = n
   (self.__Ms) = Ms
   (self.__xs) = xs
   (self.__b) = b
  @staticmethod
  def _add_alt_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_0,_1):
   if ((_0.__n)!=_1.getdim()): # src/fusion/SymExpr.monty:139:12-29
    raise mosek_fusion_DimensionError._ctor_S("Dimension does not match")
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),(_0.__Ms),(_0.__xs),((_0.__b).add(_1) if (((_0.__b) is not None) ) else _1)))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4SymmetricExpr_2D(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._mul_Lmosek_4fusion_4SymmetricExpr_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4SymmetricExpr_2D(_0,_1):
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),numpy.array([(_0.__Ms)[_2].mul(_1) for _2 in range(0,int(((_0.__Ms)).shape[0]))], dtype=numpy.dtype(object)),(_0.__xs),((_0.__b).mul(_1) if (((_0.__b) is not None) ) else None)))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_0,_1):
   if ((_0.__n)!=(_1.__n)): # src/fusion/SymExpr.monty:108:12-26
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
   _2=numpy.ndarray(((int(((_0.__Ms)).shape[0]) + int(((_1.__Ms)).shape[0])),), dtype=numpy.dtype(object))
   _3=numpy.ndarray(((int(((_0.__xs)).shape[0]) + int(((_1.__xs)).shape[0])),), dtype=numpy.dtype(object))
   _4=int(((_0.__Ms)).shape[0])
   for _5 in range(0,int(((_0.__Ms)).shape[0])):
    _2[_5] = (_0.__Ms)[_5]
   for _6 in range(0,int(((_1.__Ms)).shape[0])):
    _2[(_6 + _4)] = (_1.__Ms)[_6]
   _7=int(((_0.__xs)).shape[0])
   for _8 in range(0,int(((_0.__xs)).shape[0])):
    _3[_8] = (_0.__xs)[_8]
   for _9 in range(0,int(((_1.__xs)).shape[0])):
    _3[(_9 + _7)] = (_1.__xs)[_9]
   _10=(None if ((((_0.__b) is None) and ((_1.__b) is None)) ) else ((_0.__b).add((_1.__b)) if ((((_0.__b) is not None) and ((_1.__b) is not None)) ) else ((_0.__b) if (((_0.__b) is not None) ) else (_1.__b))))
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),_2,_3,_10))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SymmetricExpr( (")._a_I(self.__n)._a_S(",")._a_I(self.__n)._a_S(") )")
   return (_0._toString_())
 return SymmetricExpr
mosek_fusion_SymmetricExpr=__mk_mosek_fusion_SymmetricExpr()
del __mk_mosek_fusion_SymmetricExpr
#BEFORE CLASS
def __mk_mosek_fusion_FlatExpr():
 class FlatExpr(object):
  __slots__ = ['inst','shape','nnz','cof','subj','ptrb','bfix']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4FlatExpr_2(*args): # mosek.fusion.FlatExpr
      self._ctor_init_Lmosek_4fusion_4FlatExpr_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4FlatExpr_2(*args):# mosek.fusion.FlatExpr
      self._ctor_alt_init_Lmosek_4fusion_4FlatExpr_2(*args)
    elif self.__match_ctor__3D_3J_3J_3D_3I_3J(*args): # []double,[]int64,[]int64,[]double,[]int32,[]int64
      self._ctor_init__3D_3J_3J_3D_3I_3J(*args)
    elif self.__match_alt_ctor__3D_3J_3J_3D_3I_3J(*args):# []double,[]int64,[]int64,[]double,[]int32,[]int64
      self._ctor_alt_init__3D_3J_3J_3D_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FlatExpr.ctor(mosek.fusion.FlatExpr)\n\tmosek.fusion.FlatExpr.ctor(array(double,ndim=1),array(int64,ndim=1),array(int64,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int64,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FlatExpr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FlatExpr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FlatExpr.toString()')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_FlatExpr._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_FlatExpr._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FlatExpr.size()')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.FlatExpr: '+self._toString_()
  @staticmethod
  def _ctor_Lmosek_4fusion_4FlatExpr_2(e):
    o = FlatExpr.__new__(FlatExpr)
    o._ctor_init_Lmosek_4fusion_4FlatExpr_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4FlatExpr_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4FlatExpr_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4FlatExpr_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4FlatExpr_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4FlatExpr_2(self,e):
    self._ctor_init_Lmosek_4fusion_4FlatExpr_2(e)
  def _ctor_init_Lmosek_4fusion_4FlatExpr_2(self,e):
   self.bfix = mosek.fusion.Utils.Tools._arraycopy__3D((e.bfix))
   self.ptrb = mosek.fusion.Utils.Tools._arraycopy__3J((e.ptrb))
   self.subj = mosek.fusion.Utils.Tools._arraycopy__3J((e.subj))
   self.cof = mosek.fusion.Utils.Tools._arraycopy__3D((e.cof))
   self.nnz = (e.nnz)
   self.shape = (e.shape)
   self.inst = (e.inst)
  @staticmethod
  def _ctor__3D_3J_3J_3D_3I_3J(bfix_,ptrb_,subj_,cof_,shape_,inst_):
    o = FlatExpr.__new__(FlatExpr)
    o._ctor_init__3D_3J_3J_3D_3I_3J(bfix_,ptrb_,subj_,cof_,shape_,inst_)
    return o
  @staticmethod
  def __match_ctor__3D_3J_3J_3D_3I_3J(*args):
    if len(args) != 6: return False
    bfix_,ptrb_,subj_,cof_,shape_,inst_, = args
    return (__arg_match__3D__(bfix_) and __arg_match__3J__(ptrb_) and __arg_match__3J__(subj_) and __arg_match__3D__(cof_) and __arg_match__3I__(shape_) and __arg_match__3J__(inst_))
  @staticmethod
  def __match_alt_ctor__3D_3J_3J_3D_3I_3J(*args):
    if len(args) != 6: return False
    bfix_,ptrb_,subj_,cof_,shape_,inst_, = args
    return (__arg_alt_match__3D__(bfix_) and __arg_alt_match__3J__(ptrb_) and __arg_alt_match__3J__(subj_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3I__(shape_) and __arg_alt_match__3J__(inst_))
  def _ctor_alt_init__3D_3J_3J_3D_3I_3J(self,bfix_,ptrb_,subj_,cof_,shape_,inst_):
    self._ctor_init__3D_3J_3J_3D_3I_3J(numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(shape_,dtype=numpy.dtype(numpy.int32)),numpy.array(inst_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3D_3J_3J_3D_3I_3J(self,bfix_,ptrb_,subj_,cof_,shape_,inst_):
   assert bfix_ is None or isinstance(bfix_,numpy.ndarray)
   assert ptrb_ is None or isinstance(ptrb_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   assert shape_ is None or isinstance(shape_,numpy.ndarray)
   assert inst_ is None or isinstance(inst_,numpy.ndarray)
   if ((bfix_ is not None) and (int((bfix_).shape[0])!=(int((ptrb_).shape[0]) - 1))): # src/fusion/FlatExpr.mbi:58:12-59:40
    raise mosek_fusion_SparseFormatError._ctor_S("Mismatching lengths of bfix and ptrb")
   if ((cof_ is None) or ((subj_ is None) or (int((subj_).shape[0])!=int((cof_).shape[0])))): # src/fusion/FlatExpr.mbi:64:13-66:36
    raise mosek_fusion_SparseFormatError._ctor_S("Mismatching lengths of subj and cof")
   if (shape_ is not None): # src/fusion/FlatExpr.mbi:71:12-26
    if (inst_ is not None): # src/fusion/FlatExpr.mbi:73:14-27
     if (int((inst_).shape[0])!=(int((ptrb_).shape[0]) - 1)): # src/fusion/FlatExpr.mbi:75:16-42
      raise mosek_fusion_SparseFormatError._ctor_S("Mismatching lengths of inst and ptrb")
    elif (mosek.fusion.Set._size__3I(shape_)!=(int((ptrb_).shape[0]) - 1)): # src/fusion/FlatExpr.mbi:80:18-54
     raise mosek_fusion_SparseFormatError._ctor_S("Mismatching shape and ptrb")
   self.bfix = bfix_
   self.ptrb = ptrb_
   self.subj = subj_
   self.cof = cof_
   self.nnz = self.ptrb[(int((self.ptrb).shape[0]) - 1)]
   self.shape = shape_
   self.inst = inst_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("FlatExpr:")._lf_()._a_S("+-----------------")._lf_()._a_S("| ptrb[")._a_I(int((self.ptrb).shape[0]))._a_S("] = ")._a__3J(self.ptrb)._lf_()._a_S("| subj[")._a_I(int((self.subj).shape[0]))._a_S("] = ")._a__3J(self.subj)._lf_()._a_S("| cof [")._a_I(int((self.cof).shape[0]))._a_S("] = ")._a__3D(self.cof)._lf_()._a_S("| bfix[")
   if (self.bfix is not None): # src/fusion/FlatExpr.mbi:134:12-24
    _0._a_I(int((self.bfix).shape[0]))
   _0._a_S("] = ")._a__3D(self.bfix)._lf_()._a_S("| inst[")
   if (self.inst is not None): # src/fusion/FlatExpr.mbi:137:12-24
    _0._a_I(int((self.inst).shape[0]))
   _0._a_S("] = ")._a__3J(self.inst)._lf_()._a_S("+-----------------")
   return (_0._toString_())
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int32((int((self.ptrb).shape[0]) - 1))
 return FlatExpr
mosek_fusion_FlatExpr=__mk_mosek_fusion_FlatExpr()
del __mk_mosek_fusion_FlatExpr
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricMatrix():
 class SymmetricMatrix(object):
  __slots__ = ['_SymmetricMatrix__nnz','_SymmetricMatrix__scale','_SymmetricMatrix__vval','_SymmetricMatrix__vsubj','_SymmetricMatrix__vsubi','_SymmetricMatrix__uval','_SymmetricMatrix__usubj','_SymmetricMatrix__usubi','_SymmetricMatrix__d1','_SymmetricMatrix__d0']
  @staticmethod
  def rankOne(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_rankOne__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._rankOne__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._rankOne_alt__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_rankOne_I_3I_3D(*args): # int32,[]int32,[]double
      return mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne_I_3I_3D(*args): # int32,[]int32,[]double
      return mosek_fusion_SymmetricMatrix._rankOne_alt_I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list rankOne('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.rankOne(array(double,ndim=1))\n\tmosek.fusion.SymmetricMatrix.rankOne(int32,array(int32,ndim=1),array(double,ndim=1))')
  @staticmethod
  def diag(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_diag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._diag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_diag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._diag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.diag(array(double,ndim=1))')
  def mul(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_mul_D(*args): # double
      return self._mul_D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_mul_D(*args): # double
      return self._mul_alt_D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.mul(double)')
  def sub(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.sub(mosek.fusion.SymmetricMatrix)')
  @staticmethod
  def antiDiag(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_antiDiag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._antiDiag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_antiDiag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._antiDiag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list antiDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.antiDiag(array(double,ndim=1))')
  def getdim(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_getdim_(*args): # 
      return self._getdim_(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_getdim_(*args): # 
      return self._getdim_alt_(*args)
    else:
      raise ValueError('Invalid argument list getdim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.getdim()')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._add_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._add_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.add(mosek.fusion.SymmetricMatrix)')
  def __repr__(self): return 'mosek.fusion.SymmetricMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    o = SymmetricMatrix.__new__(SymmetricMatrix)
    o._ctor_init_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match__3I__(usubi) and __arg_match__3I__(usubj) and __arg_match__3D__(uval) and __arg_match__3I__(vsubi) and __arg_match__3I__(vsubj) and __arg_match__3D__(vval) and __arg_match_D__(scale))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match__3I__(usubi) and __arg_alt_match__3I__(usubj) and __arg_alt_match__3D__(uval) and __arg_alt_match__3I__(vsubi) and __arg_alt_match__3I__(vsubj) and __arg_alt_match__3D__(vval) and __arg_alt_match_D__(scale))
  def _ctor_alt_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    self._ctor_init_II_3I_3I_3D_3I_3I_3DD(numpy.int32(dim0),numpy.int32(dim1),numpy.array(usubi,dtype=numpy.dtype(numpy.int32)),numpy.array(usubj,dtype=numpy.dtype(numpy.int32)),numpy.array(uval,dtype=numpy.dtype(numpy.float64)),numpy.array(vsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(vsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(vval,dtype=numpy.dtype(numpy.float64)),numpy.float64(scale))
  def _ctor_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
   assert usubi is None or isinstance(usubi,numpy.ndarray)
   assert usubj is None or isinstance(usubj,numpy.ndarray)
   assert uval is None or isinstance(uval,numpy.ndarray)
   assert vsubi is None or isinstance(vsubi,numpy.ndarray)
   assert vsubj is None or isinstance(vsubj,numpy.ndarray)
   assert vval is None or isinstance(vval,numpy.ndarray)
   (self.__d0) = dim0
   (self.__d1) = dim1
   (self.__usubi) = usubi
   (self.__usubj) = usubj
   (self.__uval) = uval
   (self.__vsubi) = vsubi
   (self.__vsubj) = vsubj
   (self.__vval) = vval
   (self.__scale) = scale
   self.__nnz = (- 1)
  @staticmethod
  def _match_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _rankOne_alt_I_3I_3D(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _rankOne_I_3I_3D(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (int((_1).shape[0])!=int((_2).shape[0])): # src/fusion/SymmetricMatrix.monty:168:12-30
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   for _3 in range(0,int((_1).shape[0])):
    if ((_1[_3] < 0) or (_1[_3] >= _0)): # src/fusion/SymmetricMatrix.monty:172:14-39
     raise mosek_fusion_LengthError._ctor_S("Invalid index in argument 'sub'")
   _4=numpy.array([_1[_5] for _5 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([1 for _7 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _8=numpy.array([_2[_9] for _9 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_0,1,_4,_6,_8,_4,_6,_8,1.0))
  @staticmethod
  def _match_rankOne__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_rankOne__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _rankOne_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._rankOne__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _rankOne__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _4=numpy.array([1 for _5 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([_0[_7] for _7 in range(0,_1)], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,1,_2,_4,_6,_2,_4,_6,1.0))
  @staticmethod
  def _match_antiDiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_antiDiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _antiDiag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._antiDiag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antiDiag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,_1,_2,numpy.array([(_1 - _4) for _4 in range(0,_1)], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_5] for _5 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),_2,_2,numpy.array([1.0 for _6 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _diag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._diag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,_1,_2,_2,numpy.array([_0[_4] for _4 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),_2,_2,numpy.array([1.0 for _5 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  def _add_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__0):
    return self._add_Lmosek_4fusion_4SymmetricMatrix_2(_0)
  def _add_Lmosek_4fusion_4SymmetricMatrix_2(self,_0):
   _1=self.getdim()
   if (_0.getdim()!=_1): # src/fusion/SymmetricMatrix.monty:78:12-27
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   _2=int((self.__usubi).shape[0])
   _3=int(((_0.__usubi)).shape[0])
   _4=(_2 + _3)
   _5=int((self.__vsubi).shape[0])
   _6=int(((_0.__vsubi)).shape[0])
   _7=(_5 + _6)
   _8=numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
   _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _12=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_13,0,_2)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.__usubi),0,_13,_2,_3)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubj,0,_12,0,_2)
   for _14 in range(0,_3):
    _12[(_14 + _2)] = ((_0.__usubj)[_14] + self.__d1)
   if ((self.__scale > 1.0) or (self.__scale < 1.0)): # src/fusion/SymmetricMatrix.monty:101:12-38
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__uval,0,_11,0,_2)
   else:
    for _15 in range(0,_2):
     _11[_15] = (self.__scale * self.__uval[_15])
   if (((_0.__scale) > 1.0) or ((_0.__scale) < 1.0)): # src/fusion/SymmetricMatrix.monty:106:12-42
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.__uval),0,_11,_2,_3)
   else:
    for _16 in range(0,_3):
     _11[(_16 + _2)] = ((_0.__scale) * (_0.__uval)[_16])
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_13,0,_2)
   for _17 in range(0,_6):
    _10[(_17 + _5)] = ((_0.__vsubi)[_17] + (_0.__d1))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__vsubj,0,_9,0,_5)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.__vsubj),_5,_9,_5,_6)
   if ((self.__scale > 1.0) or (self.__scale < 1.0)): # src/fusion/SymmetricMatrix.monty:119:12-38
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__vval,0,_8,0,_5)
   else:
    for _18 in range(0,_5):
     _8[_18] = (self.__scale * self.__vval[_18])
   if (((_0.__scale) > 1.0) or ((_0.__scale) < 1.0)): # src/fusion/SymmetricMatrix.monty:124:12-42
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.__vval),0,_8,_5,_6)
   else:
    for _19 in range(0,_6):
     _8[(_19 + _5)] = ((_0.__scale) * (_0.__vval)[_19])
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,(self.__d1 + (_0.__d1)),_13,_12,_11,_10,_9,_8,1.0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  def _sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__0):
    return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(_0)
  def _sub_Lmosek_4fusion_4SymmetricMatrix_2(self,_0):
   return (self.add(_0.mul((- 1.0))))
  @staticmethod
  def _match_mul_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_mul_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _mul_alt_D(self,_t__0):
    return self._mul_D(numpy.float64(__0))
  def _mul_D(self,_0):
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,self.__d1,self.__usubi,self.__usubj,self.__uval,self.__vsubi,self.__vsubj,self.__vval,(self.__scale * _0)))
  @staticmethod
  def _match_getdim_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getdim_(*args):
    if len(args) != 0: return False
    return True
  def _getdim_alt_(self,):
    return self._getdim_()
  def _getdim_(self,):
   return numpy.int32(self.__d0)
 return SymmetricMatrix
mosek_fusion_SymmetricMatrix=__mk_mosek_fusion_SymmetricMatrix()
del __mk_mosek_fusion_SymmetricMatrix
#BEFORE CLASS
def __mk_mosek_fusion_NDSparseArray():
 class NDSparseArray(object):
  __slots__ = ['_cof','_inst','_dims','_size']
  @staticmethod
  def make(*args):
    if False: pass
    elif mosek_fusion_NDSparseArray._match_make_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_NDSparseArray._make_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3J_3D(*args): # []int32,[]int64,[]double
      return mosek_fusion_NDSparseArray._make__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3J_3D(*args): # []int32,[]int64,[]double
      return mosek_fusion_NDSparseArray._make_alt__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_NDSparseArray._make__3I_3_5I_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_NDSparseArray._make_alt__3I_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSparseArray.make(mosek.fusion.Matrix)\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NDSparseArray'
  @staticmethod
  def _ctor__3I_3_5I_3D(dims_,sub,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3_5I_3D(dims_,sub,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3_5I__(sub) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3_5I__(sub) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3_5I_3D(self,dims_,sub,cof_):
    self._ctor_init__3I_3_5I_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(sub,dtype=numpy.dtype(numpy.int32)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3_5I_3D(self,dims_,sub,cof_):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert sub is None or isinstance(sub,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   _0=numpy.zeros((int((sub).shape[0]),), dtype=numpy.dtype(numpy.int64))
   self._size = 1
   for _1 in range(0,int((dims_).shape[0])):
    self._size = (self._size * dims_[_1])
   _2=int((dims_).shape[0])
   if (int((sub).shape[0])!=int((cof_).shape[0])): # src/fusion/Matrix.mbi:1074:12-35
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   if (int((sub).shape[1])!=_2): # src/fusion/Matrix.mbi:1076:12-28
    raise mosek_fusion_IndexError._ctor_S("An index key in sub has wrong length")
   _3=False
   for _4 in range(0,int((sub).shape[0])):
    for _5 in range(0,int((sub).shape[1])):
     if ((sub[_4,_5] < 0) or (sub[_4,_5] >= dims_[_5])): # src/fusion/Matrix.mbi:1083:16-52
      _3 = True
   if _3: # src/fusion/Matrix.mbi:1086:12-23
    raise mosek_fusion_IndexError._ctor_S("An index in sub is out of bounds")
   for _6 in range(0,int((sub).shape[0])):
    _7=0
    for _8 in range(0,int((sub).shape[1])):
     _7 = ((_7 * dims_[_8]) + sub[_6,_8])
    _0[_6] = _7
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _9=True
   for _10 in range(1,int((_0).shape[0])):
    _9 = (_9 and (_0[_10] >= _0[(_10 - 1)]))
   if _9: # src/fusion/Matrix.mbi:1101:12-20
    _11=1
    for _12 in range(1,int((_0).shape[0])):
     if (_0[(_12 - 1)] < _0[_12]): # src/fusion/Matrix.mbi:1105:16-37
      _11 += 1
    if (_11==int((_0).shape[0])): # src/fusion/Matrix.mbi:1107:14-35
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(_0)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = _0[0]
     self._cof = numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _13=0
     for _14 in range(1,int((_0).shape[0])):
      if (_0[_14] > _0[(_14 - 1)]): # src/fusion/Matrix.mbi:1118:18-39
       _13 += 1
       self._inst[_13] = _0[_14]
       self._cof[_13] = cof_[_14]
      else:
       self._cof[_13] = (self._cof[_13] + cof_[_14])
   else:
    _15=mosek.fusion.Utils.Tools._range_J(int((_0).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_15,_0,None,0,int((_0).shape[0]))
    _16=1
    for _17 in range(1,int((_0).shape[0])):
     if (_0[_15[(_17 - 1)]] < _0[_15[_17]]): # src/fusion/Matrix.mbi:1132:16-49
      _16 += 1
    self._inst = numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = _0[_15[0]]
    self._cof = numpy.zeros((_16,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_15[0]]
    _18=0
    for _19 in range(1,int((_0).shape[0])):
     if (_0[_15[_19]] > _0[_15[(_19 - 1)]]): # src/fusion/Matrix.mbi:1139:16-49
      _18 += 1
      self._inst[_18] = _0[_15[_19]]
      self._cof[_18] = cof_[_15[_19]]
     else:
      self._cof[_18] = (self._cof[_18] + cof_[_15[_19]])
  @staticmethod
  def _ctor__3I_3J_3D(dims_,inst_,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3J_3D(dims_,inst_,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3J__(inst_) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(inst_) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3J_3D(self,dims_,inst_,cof_):
    self._ctor_init__3I_3J_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(inst_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3J_3D(self,dims_,inst_,cof_):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert inst_ is None or isinstance(inst_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   self._size = 1
   for _0 in range(0,int((dims_).shape[0])):
    self._size = (self._size * dims_[_0])
   if (int((inst_).shape[0])!=int((cof_).shape[0])): # src/fusion/Matrix.mbi:1007:12-35
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   _1=False
   for _2 in range(0,int((inst_).shape[0])):
    _1 = (_1 or ((inst_[_2] < 0) or (inst_[_2] >= self._size)))
   if _1: # src/fusion/Matrix.mbi:1013:14-17
    raise mosek_fusion_IndexError._ctor_S("An index in inst is out of bounds")
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _3=True
   for _4 in range(1,int((inst_).shape[0])):
    _3 = (_3 and (inst_[_4] >= inst_[(_4 - 1)]))
   if _3: # src/fusion/Matrix.mbi:1021:12-20
    _5=1
    for _6 in range(1,int((inst_).shape[0])):
     if (inst_[(_6 - 1)] < inst_[_6]): # src/fusion/Matrix.mbi:1025:16-37
      _5 += 1
    if (_5==int((inst_).shape[0])): # src/fusion/Matrix.mbi:1027:14-35
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(inst_)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = inst_[0]
     self._cof = numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _7=0
     for _8 in range(1,int((inst_).shape[0])):
      if (inst_[_8] > inst_[(_8 - 1)]): # src/fusion/Matrix.mbi:1038:18-39
       _7 += 1
       self._inst[_7] = inst_[_8]
       self._cof[_7] = cof_[_8]
      else:
       self._cof[_7] = (self._cof[_7] + cof_[_8])
   else:
    _9=mosek.fusion.Utils.Tools._range_J(int((inst_).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_9,inst_,None,0,int((inst_).shape[0]))
    _10=1
    for _11 in range(1,int((inst_).shape[0])):
     if (inst_[_9[(_11 - 1)]] < inst_[_9[_11]]): # src/fusion/Matrix.mbi:1052:16-49
      _10 += 1
    self._inst = numpy.zeros((_10,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = inst_[_9[0]]
    self._cof = numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_9[0]]
    _12=0
    for _13 in range(1,int((inst_).shape[0])):
     if (inst_[_9[_13]] > self._inst[_9[(_13 - 1)]]): # src/fusion/Matrix.mbi:1059:16-48
      _12 += 1
      self._inst[_12] = inst_[_9[_13]]
      self._cof[_12] = cof_[_9[_13]]
     else:
      self._cof[_12] = (self._cof[_12] + cof_[_9[_13]])
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m):
   _0=m.numNonzeros()
   _1=m.numColumns()
   _2=m.numRows()
   _3=numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
   _4=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   m.getDataAsTriplets(_5,_4,_3)
   self._size = (numpy.int64(m.numRows()) * numpy.int64(m.numColumns()))
   self._dims = numpy.array([_2,_1], dtype=numpy.dtype(numpy.int32))
   self._inst = numpy.array([((numpy.int64(_5[_6]) * _1) + numpy.int64(_4[_6])) for _6 in range(0,_0)], dtype=numpy.dtype(numpy.int64))
   self._cof = _3
  @staticmethod
  def _match_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _make_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _make_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek_fusion_NDSparseArray._ctor_Lmosek_4fusion_4Matrix_2(_0))
  @staticmethod
  def _match_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _make_alt__3I_3J_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_NDSparseArray._make__3I_3J_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3J_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_NDSparseArray._ctor__3I_3J_3D(_0,_1,_2))
  @staticmethod
  def _match_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _make_alt__3I_3_5I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_NDSparseArray._make__3I_3_5I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3_5I_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_NDSparseArray._ctor__3I_3_5I_3D(_0,_1,_2))
 return NDSparseArray
mosek_fusion_NDSparseArray=__mk_mosek_fusion_NDSparseArray()
del __mk_mosek_fusion_NDSparseArray
#BEFORE CLASS
def __mk_mosek_fusion_Matrix():
 class Matrix(object):
  __slots__ = ['_dimj','_dimi']
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_Matrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numNonzeros()')
  @staticmethod
  def antidiag(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_antidiag__3D(*args): # []double
      return mosek_fusion_Matrix._antidiag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3D(*args): # []double
      return mosek_fusion_Matrix._antidiag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_antidiag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._antidiag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._antidiag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_antidiag_ID(*args): # int32,double
      return mosek_fusion_Matrix._antidiag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_ID(*args): # int32,double
      return mosek_fusion_Matrix._antidiag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_antidiag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._antidiag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._antidiag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1))\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.antidiag(int32,double)\n\tmosek.fusion.Matrix.antidiag(int32,double,int32)')
  def numRows(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numRows_(*args): # 
      return self._numRows_(*args)
    elif mosek_fusion_Matrix._match_alt_numRows_(*args): # 
      return self._numRows_alt_(*args)
    else:
      raise ValueError('Invalid argument list numRows('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numRows()')
  @staticmethod
  def diag(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_diag__3D(*args): # []double
      return mosek_fusion_Matrix._diag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3D(*args): # []double
      return mosek_fusion_Matrix._diag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_diag__3Lmosek_4fusion_4Matrix_2(*args): # []mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args): # []mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_alt__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._diag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._diag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_diag_ILmosek_4fusion_4Matrix_2(*args): # int32,mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ILmosek_4fusion_4Matrix_2(*args): # int32,mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_alt_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag_ID(*args): # int32,double
      return mosek_fusion_Matrix._diag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ID(*args): # int32,double
      return mosek_fusion_Matrix._diag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_diag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._diag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_diag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._diag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.diag(array(double,ndim=1))\n\tmosek.fusion.Matrix.diag(array(mosek.fusion.Matrix,ndim=1))\n\tmosek.fusion.Matrix.diag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.diag(int32,mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.diag(int32,double)\n\tmosek.fusion.Matrix.diag(int32,double,int32)')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsArray()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_Matrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.isSparse()')
  @staticmethod
  def ones(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_ones_II(*args): # int32,int32
      return mosek_fusion_Matrix._ones_II(*args)
    elif mosek_fusion_Matrix._match_alt_ones_II(*args): # int32,int32
      return mosek_fusion_Matrix._ones_alt_II(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.ones(int32,int32)')
  def numColumns(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numColumns_(*args): # 
      return self._numColumns_(*args)
    elif mosek_fusion_Matrix._match_alt_numColumns_(*args): # 
      return self._numColumns_alt_(*args)
    else:
      raise ValueError('Invalid argument list numColumns('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numColumns()')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_Matrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.get(int32,int32)')
  @staticmethod
  def eye(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_eye_I(*args): # int32
      return mosek_fusion_Matrix._eye_I(*args)
    elif mosek_fusion_Matrix._match_alt_eye_I(*args): # int32
      return mosek_fusion_Matrix._eye_alt_I(*args)
    else:
      raise ValueError('Invalid argument list eye('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.eye(int32)')
  @staticmethod
  def sparse(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_sparse__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._sparse__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._sparse_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args): # [][]mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args): # [][]mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_alt__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_II(*args): # int32,int32
      return mosek_fusion_Matrix._sparse_II(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II(*args): # int32,int32
      return mosek_fusion_Matrix._sparse_alt_II(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3I_3D(*args): # []int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3I_3D(*args): # []int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_alt__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3ID(*args): # []int32,[]int32,double
      return mosek_fusion_Matrix._sparse__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3ID(*args): # []int32,[]int32,double
      return mosek_fusion_Matrix._sparse_alt__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3ID(*args): # int32,int32,[]int32,[]int32,double
      return mosek_fusion_Matrix._sparse_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3ID(*args): # int32,int32,[]int32,[]int32,double
      return mosek_fusion_Matrix._sparse_alt_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3I_3D(*args): # int32,int32,[]int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_II_3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3I_3D(*args): # int32,int32,[]int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_alt_II_3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.sparse(array(double,ndim=2))\n\tmosek.fusion.Matrix.sparse(array(array(mosek.fusion.Matrix,ndim=1),ndim=1))\n\tmosek.fusion.Matrix.sparse(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.sparse(int32,int32)\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Matrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.transpose()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Matrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.toString()')
  @staticmethod
  def dense(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_dense__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._dense__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_dense__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._dense_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_dense_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_dense_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._dense_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_dense_IID(*args): # int32,int32,double
      return mosek_fusion_Matrix._dense_IID(*args)
    elif mosek_fusion_Matrix._match_alt_dense_IID(*args): # int32,int32,double
      return mosek_fusion_Matrix._dense_alt_IID(*args)
    elif mosek_fusion_Matrix._match_dense_II_3D(*args): # int32,int32,[]double
      return mosek_fusion_Matrix._dense_II_3D(*args)
    elif mosek_fusion_Matrix._match_alt_dense_II_3D(*args): # int32,int32,[]double
      return mosek_fusion_Matrix._dense_alt_II_3D(*args)
    else:
      raise ValueError('Invalid argument list dense('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.dense(array(double,ndim=2))\n\tmosek.fusion.Matrix.dense(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.dense(int32,int32,double)\n\tmosek.fusion.Matrix.dense(int32,int32,array(double,ndim=1))')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.Matrix: '+self._toString_()
  @staticmethod
  def _ctor_II(di,dj):
    o = Matrix.__new__(Matrix)
    o._ctor_init_II(di,dj)
    return o
  @staticmethod
  def __match_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_match_I__(di) and __arg_match_I__(dj))
  @staticmethod
  def __match_alt_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_alt_match_I__(di) and __arg_alt_match_I__(dj))
  def _ctor_alt_init_II(self,di,dj):
    self._ctor_init_II(numpy.int32(di),numpy.int32(dj))
  def _ctor_init_II(self,di,dj):
   if ((di < 0) or (dj < 0)): # src/fusion/Matrix.mbi:67:12-28
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimensions")
   self._dimi = di
   self._dimj = dj
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("")
  def _switchDims_alt_(self,):
    return self._switchDims_()
  def _switchDims_(self,):
   _0=self._dimi
   self._dimi = self._dimj
   self._dimj = _0
  @staticmethod
  def _match_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _diag_alt_ILmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(numpy.int32(__0),_1)
  @staticmethod
  def _diag_ILmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Matrix._diag__3Lmosek_4fusion_4Matrix_2(numpy.array([_1 for _2 in range(0,_0)], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _diag_alt__3Lmosek_4fusion_4Matrix_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3Lmosek_4fusion_4Matrix_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=_0
   _2=0
   _3=0
   _4=0
   for _5 in range(0,int((_0).shape[0])):
    _4 = (_4 + (_0[_5]._dimi))
    _3 = (_3 + (_0[_5]._dimj))
    _2 = (_2 + _0[_5].numNonzeros())
   _6=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _9=0
   _10=0
   _11=0
   for _12 in range(0,int((_0).shape[0])):
    _13=_0[_12].numNonzeros()
    _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _0[_12].getDataAsTriplets(_16,_15,_14)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_14,0,_8,_11,_13)
    for _17 in range(0,_13):
     _6[(_11 + _17)] = (_16[_17] + _10)
     _7[(_11 + _17)] = (_16[_17] + _9)
    _11 = (_11 + _13)
    _10 = (_10 + (_0[_12]._dimi))
    _9 = (_9 + (_0[_12]._dimj))
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_4,_3,_6,_7,_8))
  @staticmethod
  def _match_antidiag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_antidiag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _antidiag_alt_IDI(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._antidiag_IDI(numpy.int32(__0),numpy.float64(__1),numpy.int32(__2))
  @staticmethod
  def _antidiag_IDI(_0,_1,_2):
   if ((_2 < _0) and (_2 >= 0)): # src/fusion/Matrix.mbi:487:16-32
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 - _2)),_2))
   elif ((_2 > (- _0)) and (_2 < 0)): # src/fusion/Matrix.mbi:489:16-32
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 + _2)),_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_antidiag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_antidiag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _antidiag_alt_ID(_t__0,_t__1):
    return mosek_fusion_Matrix._antidiag_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _antidiag_ID(_0,_1):
   return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,_0),0))
  @staticmethod
  def _match_diag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_diag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _diag_alt_IDI(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._diag_IDI(numpy.int32(__0),numpy.float64(__1),numpy.int32(__2))
  @staticmethod
  def _diag_IDI(_0,_1,_2):
   if ((_2 < _0) and (_2 >= 0)): # src/fusion/Matrix.mbi:471:16-32
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 - _2)),_2))
   elif ((_2 > (- _0)) and (_2 < 0)): # src/fusion/Matrix.mbi:473:16-32
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 + _2)),_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_diag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_diag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _diag_alt_ID(_t__0,_t__1):
    return mosek_fusion_Matrix._diag_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _diag_ID(_0,_1):
   return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,_0),0))
  @staticmethod
  def _match_antidiag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_antidiag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _antidiag_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Matrix._antidiag__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antidiag__3DI(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=(_1 if ((_1 > 0) ) else (- _1))
   _3=(int((_0).shape[0]) + _2)
   _4=int((_0).shape[0])
   if (_1 >= 0): # src/fusion/Matrix.mbi:447:12-18
    _5=mosek.fusion.Utils.Tools._range_II(_1,(_4 + _1))
    _6=numpy.array([((_4 + _1) - _7) for _7 in range(1,(_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_5,_6,_0))
   else:
    _8=mosek.fusion.Utils.Tools._range_II(0,_4)
    _9=numpy.array([(_4 - _10) for _10 in range(1,(_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_8,_9,_0))
  @staticmethod
  def _match_antidiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_antidiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _antidiag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._antidiag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antidiag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Matrix._antidiag__3DI(_0,0))
  @staticmethod
  def _match_diag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_diag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _diag_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Matrix._diag__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3DI(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=(_1 if ((_1 > 0) ) else (- _1))
   _3=(int((_0).shape[0]) + _2)
   _4=int((_0).shape[0])
   if (_1 >= 0): # src/fusion/Matrix.mbi:421:12-18
    _5=mosek.fusion.Utils.Tools._range_II(0,_4)
    _6=mosek.fusion.Utils.Tools._range_II(_2,(_4 + _2))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_5,_6,_0))
   else:
    _7=mosek.fusion.Utils.Tools._range_II(_2,(_4 + _2))
    _8=mosek.fusion.Utils.Tools._range_II(0,_4)
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_7,_8,_0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _diag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._diag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Matrix._diag__3DI(_0,0))
  @staticmethod
  def _match_ones_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_ones_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _ones_alt_II(_t__0,_t__1):
    return mosek_fusion_Matrix._ones_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _ones_II(_0,_1):
   return (mosek.fusion.Matrix._dense_IID(_0,_1,1.0))
  @staticmethod
  def _match_eye_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_eye_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _eye_alt_I(_t__0):
    return mosek_fusion_Matrix._eye_I(numpy.int32(__0))
  @staticmethod
  def _eye_I(_0):
   return (mosek.fusion.Matrix._diag__3D(numpy.array([1.0 for _1 in range(0,_0)], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _dense_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _dense_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek_fusion_DenseMatrix._ctor_Lmosek_4fusion_4Matrix_2(_0))
  @staticmethod
  def _match_dense_IID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_dense_IID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _dense_alt_IID(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._dense_IID(numpy.int32(__0),numpy.int32(__1),numpy.float64(__2))
  @staticmethod
  def _dense_IID(_0,_1,_2):
   return (mosek_fusion_DenseMatrix._ctor_IID(_0,_1,_2))
  @staticmethod
  def _match_dense_II_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_dense_II_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _dense_alt_II_3D(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._dense_II_3D(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dense_II_3D(_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_DenseMatrix._ctor_II_3D(_0,_1,_2))
  @staticmethod
  def _match_dense__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_dense__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _dense_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._dense__3_5D(_0)
   return _1
  @staticmethod
  def _dense__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_DenseMatrix._ctor__3_5D(_0))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _sparse_Lmosek_4fusion_4Matrix_2(_0):
   _1=numpy.zeros((_0.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
   _2=numpy.zeros((_0.numNonzeros(),), dtype=numpy.dtype(numpy.int32))
   _3=numpy.zeros((_0.numNonzeros(),), dtype=numpy.dtype(numpy.float64))
   _0.getDataAsTriplets(_1,_2,_3)
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_0.numRows(),_0.numColumns(),_1,_2,_3))
  @staticmethod
  def _match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _sparse_alt__3_3Lmosek_4fusion_4Matrix_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3_3Lmosek_4fusion_4Matrix_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=int((_0[0]).shape[0])
   _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=0
   _6=0
   _7=0
   while (_7 < _1):
    _8=0
    while (_8 < _2):
     _9=_0[_7][_8]
     if (_9 is not None): # src/fusion/Matrix.mbi:247:21-30
      if (_4[_8]==0): # src/fusion/Matrix.mbi:249:23-36
       _4[_8] = (_9._dimj)
      elif (_4[_8]!=(_9._dimj)): # src/fusion/Matrix.mbi:253:23-41
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      if (_3[_7]==0): # src/fusion/Matrix.mbi:258:23-36
       _3[_7] = (_9._dimi)
      elif (_3[_7]!=(_9._dimi)): # src/fusion/Matrix.mbi:262:23-41
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      _5 = (_5 + _9.numNonzeros())
     _6 += 1
     _8 += 1
    _7 += 1
   _10=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
   _11=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _13=0
   _14=0
   _15=0
   while (_15 < _1):
    _16=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _17=0
    while (_17 < _3[_15]):
     _18=0
     _19=0
     while (_19 < _2):
      _20=_0[_15][_19]
      if (_20 is not None): # src/fusion/Matrix.mbi:315:23-33
       _22=_20
       if   isinstance(_22,mosek_fusion_DenseMatrix):
        m=_22
        _22=_16[_19]
        _23=0
        while (_23 < (m._dimj)):
         _10[_13] = (m._data)[_22]
         _11[_13] = (_14 + _17)
         _12[_13] = (_18 + _23)
         _22 += 1
         _13 += 1
         _23 += 1
        _16[_19] = _22
       elif isinstance(_22,mosek_fusion_SparseMatrix):
        _24=_22
        _25 = _16[_19]
        while ((_25 < (_24._nnz)) and ((_24._subi)[_25]==_17)):
         _10[_13] = (_24._val)[_25]
         _12[_13] = ((_24._subj)[_25] + _18)
         _11[_13] = (_14 + _17)
         _13 += 1
         _25 += 1
        _16[_19] = _25
       else:
        m=_22
        raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
      _18 = (_18 + _4[_19])
      _19 += 1
     _17 += 1
    _14 = (_14 + _3[_15])
    _15 += 1
   _26=0
   _27=0
   _28=0
   while (_28 < _1):
    _26 = (_26 + _3[_28])
    _28 += 1
   _29=0
   while (_29 < _2):
    _27 = (_27 + _4[_29])
    _29 += 1
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_26,_27,_11,_12,_10))
  @staticmethod
  def _match_sparse__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_sparse__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _sparse_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse__3_5D(_0)
   return _1
  @staticmethod
  def _sparse__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=int((_0).shape[1])
   _3=numpy.int64((_1 * _2))
   _4=0
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   _8=0
   while (_8 < _1):
    _9=0
    while (_9 < _2):
     _5[_4] = _8
     _6[_4] = _9
     _7[_4] = _0[_8,_9]
     _4 += 1
     _9 += 1
    _8 += 1
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_1,_2,_5,_6,_7))
  @staticmethod
  def _match_sparse_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sparse_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sparse_alt_II(_t__0,_t__1):
    return mosek_fusion_Matrix._sparse_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _sparse_II(_0,_1):
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_0,_1,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),0))
  @staticmethod
  def _match_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match_D__(_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match_D__(_4))
  @staticmethod
  def _sparse_alt_II_3I_3ID(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.float64(_t__4)
   _1 = mosek_fusion_Matrix._sparse_II_3I_3ID(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_II_3I_3ID(_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _5=0
   if (_2 is not None): # src/fusion/Matrix.mbi:196:16-28
    _5 = int((_2).shape[0])
   elif (_3 is not None): # src/fusion/Matrix.mbi:197:16-28
    _5 = int((_3).shape[0])
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(_0,_1,_2,_3,mosek.fusion.Utils.Tools._makevector_DI(_4,_5)))
  @staticmethod
  def _match_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _sparse_alt__3I_3ID(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.float64(_t__2)
   _1 = mosek_fusion_Matrix._sparse__3I_3ID(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3I_3ID(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=0
   _4=0
   _5=int((_0).shape[0])
   if (_5 > int((_1).shape[0])): # src/fusion/Matrix.mbi:177:12-27
    _5 = int((_1).shape[0])
   for _6 in range(0,_5):
    if (_4 < _0[_6]): # src/fusion/Matrix.mbi:181:14-28
     _4 = _0[_6]
    if (_3 < _1[_6]): # src/fusion/Matrix.mbi:182:14-28
     _3 = _1[_6]
   return (mosek.fusion.Matrix._sparse_II_3I_3ID((_4 + 1),(_3 + 1),_0,_1,_2))
  @staticmethod
  def _match_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _sparse_alt__3I_3I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3I_3I_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=0
   _4=0
   _5=int((_0).shape[0])
   if (_5 > int((_1).shape[0])): # src/fusion/Matrix.mbi:158:12-27
    _5 = int((_1).shape[0])
   if (_5 > int((_2).shape[0])): # src/fusion/Matrix.mbi:159:12-26
    _5 = int((_2).shape[0])
   for _6 in range(0,_5):
    if (_4 < _0[_6]): # src/fusion/Matrix.mbi:163:14-28
     _4 = _0[_6]
    if (_3 < _1[_6]): # src/fusion/Matrix.mbi:164:14-28
     _3 = _1[_6]
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D((_4 + 1),(_3 + 1),_0,_1,_2))
  @staticmethod
  def _match_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3D__(_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3D__(_4))
  @staticmethod
  def _sparse_alt_II_3I_3I_3D(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse_II_3I_3I_3D(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_II_3I_3I_3D(_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=(_4 if ((_4 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
   _6=(_3 if ((_3 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _7=(_2 if ((_2 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _8=int((_7).shape[0])
   if ((int((_6).shape[0])!=_8) or (int((_5).shape[0])!=_8)): # src/fusion/Matrix.mbi:140:17-141:35
    raise mosek_fusion_SparseFormatError._ctor_S("Arrays defining sparse data have different lengths")
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_0,_1,_7,_6,_5,_8))
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   pass
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   pass
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   pass
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   pass
  @staticmethod
  def _match_numColumns_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numColumns_(*args):
    if len(args) != 0: return False
    return True
  def _numColumns_alt_(self,):
    return self._numColumns_()
  def _numColumns_(self,):
   return numpy.int32(self._dimj)
  @staticmethod
  def _match_numRows_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numRows_(*args):
    if len(args) != 0: return False
    return True
  def _numRows_alt_(self,):
    return self._numRows_()
  def _numRows_(self,):
   return numpy.int32(self._dimi)
 return Matrix
mosek_fusion_Matrix=__mk_mosek_fusion_Matrix()
del __mk_mosek_fusion_Matrix
#BEFORE CLASS
def __mk_mosek_fusion_DenseMatrix():
 class DenseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_data']
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsArray()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.isSparse()')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.numNonzeros()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.transpose()')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.toString()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_DenseMatrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.get(int32,int32)')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.DenseMatrix: '+self._toString_()
  @staticmethod
  def _ctor_II_3D(dimi_,dimj_,cof):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_II_3D(dimi_,dimj_,cof)
    return o
  @staticmethod
  def __match_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3D__(cof))
  @staticmethod
  def __match_alt_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3D__(cof))
  def _ctor_alt_init_II_3D(self,dimi_,dimj_,cof):
    self._ctor_init_II_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(cof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3D(self,dimi_,dimj_,cof):
   assert cof is None or isinstance(cof,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._nnz = numpy.int64((dimi_ * dimj_))
   self._data = numpy.zeros(((dimi_ * dimj_),), dtype=numpy.dtype(numpy.float64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(cof,0,self._data,0,(dimi_ * dimj_))
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m_))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m_):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m_):
   mosek_fusion_Matrix._ctor_init_II(self,(m_._dimi),(m_._dimj))
   _1=m_
   if   isinstance(_1,mosek_fusion_DenseMatrix):
    m=_1
    self._data = mosek.fusion.Utils.Tools._arraycopy__3D((m._data))
   elif isinstance(_1,mosek_fusion_SparseMatrix):
    _1=_1
    self._data = mosek.fusion.Utils.Tools._zeros_I(((_1._dimi) * (_1._dimj)))
    for _2 in range(0,(_1._nnz)):
     self._data[(((_1._subi)[_2] * self._dimj) + (_1._subj)[_2])] = (_1._val)[_2]
   else:
    m=_1
    raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor__3_5D(d):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init__3_5D(d)
    return o
  @staticmethod
  def __match_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_match__3_5D__(d))
  @staticmethod
  def __match_alt_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_alt_match__3_5D__(d))
  def _ctor_alt_init__3_5D(self,d):
    self._ctor_init__3_5D(numpy.array(d,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3_5D(self,d):
   assert d is None or isinstance(d,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,int((d).shape[0]),int((d).shape[1]))
   self._data = numpy.array([d[_0,_1] for _0 in range(0,self._dimi) for _1 in range(0,self._dimj)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor_IID(dimi_,dimj_,value_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_IID(dimi_,dimj_,value_)
    return o
  @staticmethod
  def __match_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match_D__(value_))
  @staticmethod
  def __match_alt_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match_D__(value_))
  def _ctor_alt_init_IID(self,dimi_,dimj_,value_):
    self._ctor_init_IID(numpy.int32(dimi_),numpy.int32(dimj_),numpy.float64(value_))
  def _ctor_init_IID(self,dimi_,dimj_,value_):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._data = numpy.array([value_ for _0 in range(0,dimi_) for _1 in range(0,dimj_)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((dimi_ * dimj_))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("DenseMatrix(")
   _0._a_I(self._dimi)
   _0._a_S(",")
   _0._a_I(self._dimj)
   _0._a_S(": ")
   _1=0
   _2=0
   while (_2 < self._dimi):
    if (_2 > 0): # src/fusion/Matrix.mbi:947:19-24
     _0._a_S(",")
    _0._a_S("[ ")
    _0._a_D(self._data[_1])
    _1 += 1
    _3=1
    while (_3 < self._dimj):
     _0._a_S(",")
     _0._a_D(self._data[_1])
     _1 += 1
     _3 += 1
    _0._a_S(" ]")
    _2 += 1
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   _0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   _1=0
   _2=self._dimi
   for _3 in range(0,self._dimi):
    _4=_3
    for _5 in range(0,self._dimj):
     _0[_4] = self._data[_1]
     _4 = (_4 + _2)
     _1 += 1
   return (mosek_fusion_DenseMatrix._ctor_II_3D(self._dimj,self._dimi,_0))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (False)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3D(self._data))
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((int((_0).shape[0]) < self._nnz) or ((int((_1).shape[0]) < self._nnz) or (int((_2).shape[0]) < self._nnz))): # src/fusion/Matrix.mbi:817:12-819:27
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self._data,0,_2,0,int((self._data).shape[0]))
   _3=0
   for _4 in range(0,self._dimi):
    for _5 in range(0,self._dimj):
     _0[_3] = _4
     _1[_3] = _5
     _3 += 1
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   return numpy.float64(self._data[((_0 * self._dimj) + _1)])
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(numpy.int64((self._dimi * self._dimj)))
 return DenseMatrix
mosek_fusion_DenseMatrix=__mk_mosek_fusion_DenseMatrix()
del __mk_mosek_fusion_DenseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_SparseMatrix():
 class SparseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_val','_subj','_subi']
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.isSparse()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.transpose()')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsArray()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.toString()')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.numNonzeros()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_SparseMatrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.get(int32,int32)')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def __str__(self): return self._toString_()
  def __repr__(self): return 'mosek.fusion.SparseMatrix: '+self._toString_()
  @staticmethod
  def _ctor_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_) and __arg_match_J__(nelm))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_) and __arg_alt_match_J__(nelm))
  def _ctor_alt_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
    self._ctor_init_II_3I_3I_3DJ(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)),numpy.int64(nelm))
  def _ctor_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
   assert subi_ is None or isinstance(subi_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert val_ is None or isinstance(val_,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   if (nelm > 0): # src/fusion/Matrix.mbi:680:17-25
    if ((int((subi_).shape[0]) < nelm) or ((int((subj_).shape[0]) < nelm) or (int((val_).shape[0]) < nelm))): # src/fusion/Matrix.mbi:682:19-684:36
     raise mosek_fusion_SparseFormatError._ctor_S("Mismatching arrays in sparse data.")
    _0=False
    for _1 in range(0,nelm):
     if ((subi_[_1] < 0) or ((subi_[_1] >= self._dimi) or ((subj_[_1] < 0) or (subj_[_1] >= self._dimj)))): # src/fusion/Matrix.mbi:690:17-691:49
      _0 = True
    if _0: # src/fusion/Matrix.mbi:694:14-25
     raise mosek_fusion_SparseFormatError._ctor_S("Subscript out of bounds.")
    _2=numpy.ndarray((1,), dtype=numpy.dtype(object))
    _3=numpy.ndarray((1,), dtype=numpy.dtype(object))
    _4=numpy.ndarray((1,), dtype=numpy.dtype(object))
    mosek.fusion.CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(subi_,subj_,val_,_2,_3,_4,nelm,self._dimi,self._dimj)
    self._subi = _2[0]
    self._subj = _3[0]
    self._val = _4[0]
    self._nnz = int((self._val).shape[0])
   else:
    self._subi = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = 0
  @staticmethod
  def _ctor_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_))
  def _ctor_alt_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
    self._ctor_init_II_3I_3I_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
   assert subi_ is None or isinstance(subi_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert val_ is None or isinstance(val_,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   _0=0
   for _1 in range(0,int((val_).shape[0])):
    if ((val_[_1] > 0) or (val_[_1] < 0)): # src/fusion/Matrix.mbi:625:53-79
     _0 += 1
   if ((_0 > 0) and (_0 < int((subi_).shape[0]))): # src/fusion/Matrix.mbi:627:12-36
    self._subi = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = _0
    _2=0
    for _3 in range(0,int((val_).shape[0])):
     if ((val_[_3] < 0) or (val_[_3] > 0)): # src/fusion/Matrix.mbi:635:16-42
      self._val[_2] = val_[_3]
      self._subj[_2] = subj_[_3]
      self._subi[_2] = subi_[_3]
      _2 += 1
   else:
    self._subi = subi_
    self._subj = subj_
    self._val = val_
    if (subi_ is None): # src/fusion/Matrix.mbi:648:19-32
     self._nnz = 0
    else:
     self._nnz = int((self._subi).shape[0])
  def _formPtrb_alt_(self,):
    return self._formPtrb_()
  def _formPtrb_(self,):
   _0=numpy.zeros(((self._dimi + 1),), dtype=numpy.dtype(numpy.int64))
   _1=0
   for _2 in range(0,self._dimi):
    _0[_2] = _1
    while ((_1 < self._nnz) and (self._subi[_1]==_2)):
     pass
     _1 += 1
   _0[self._dimi] = _1
   return (_0)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SparseMatrix(")._a_I(self._dimi)._a_S(",")._a_I(self._dimj)._a_S(", [")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)): # src/fusion/Matrix.mbi:764:12-42
    _0._a_S("(")._a_I(self._subi[0])._a_S(",")._a_I(self._subj[0])._a_S(",")._a_D(self._val[0])._a_S(")")
    for _1 in range(1,int((self._subi).shape[0])):
     _0._a_S(",(")._a_I(self._subi[_1])._a_S(",")._a_I(self._subj[_1])._a_S(",")._a_D(self._val[_1])._a_S(")")
   _0._a_S(" ])")
   return (_0._toString_())
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(self._nnz)
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(self._dimj,self._dimi,self._subj,self._subi,self._val))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (True)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   _0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   for _1 in range(0,int((self._subi).shape[0])):
    _0[((self._subi[_1] * self._dimj) + self._subj[_1])] = self._val[_1]
   return (_0)
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((int((_0).shape[0]) < self._nnz) or ((int((_1).shape[0]) < self._nnz) or (int((_2).shape[0]) < self._nnz))): # src/fusion/Matrix.mbi:722:12-724:32
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)): # src/fusion/Matrix.mbi:729:12-42
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subi,0,_0,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subj,0,_1,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self._val,0,_2,0,self._nnz)
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   if ((_0 < 0) or ((_0 >= self._dimi) or ((_1 < 0) or (_1 >= self._dimj)))): # src/fusion/Matrix.mbi:590:13-591:31
    raise mosek_fusion_IndexError._ctor_S("Index out if bounds")
   _2=int((self._subi).shape[0])
   _3=0
   while ((_2 - _3) > 1):
    _4=((_3 + _2) // 2)
    if ((self._subi[_4] < _0) or ((self._subi[_4]==_0) and (self._subj[_4] < _1))): # src/fusion/Matrix.mbi:599:18-63
     _3 = _4
    elif ((self._subi[_4] > _0) or ((self._subi[_4]==_0) and (self._subj[_4] > _1))): # src/fusion/Matrix.mbi:600:18-63
     _2 = _4
    else:
     return numpy.float64(self._val[_4])
   if ((self._subi[_3]==_0) and (self._subj[_3]==_1)): # src/fusion/Matrix.mbi:604:12-41
    return numpy.float64(self._val[_3])
   else:
    return numpy.float64(0.0)
 return SparseMatrix
mosek_fusion_SparseMatrix=__mk_mosek_fusion_SparseMatrix()
del __mk_mosek_fusion_SparseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_LinkedBlocks():
 class LinkedBlocks(object):
  __slots__ = ['_LinkedBlocks__bfirst','_LinkedBlocks__bsize','_LinkedBlocks__blocks','_LinkedBlocks__ints']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_I(*args): # int32
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):# int32
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args): # mosek.fusion.LinkedBlocks
      self._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):# mosek.fusion.LinkedBlocks
      self._ctor_alt_init_Lmosek_4fusion_4LinkedBlocks_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LinkedBlocks.ctor()\n\tmosek.fusion.LinkedBlocks.ctor(int32)\n\tmosek.fusion.LinkedBlocks.ctor(mosek.fusion.LinkedBlocks)')
  def maxidx(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_maxidx_I(*args): # int32
      return self._maxidx_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_maxidx_I(*args): # int32
      return self._maxidx_alt_I(*args)
    else:
      raise ValueError('Invalid argument list maxidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.maxidx(int32)')
  def free(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_free_I(*args): # int32
      return self._free_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_free_I(*args): # int32
      return self._free_alt_I(*args)
    else:
      raise ValueError('Invalid argument list free('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.free(int32)')
  def validate(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_validate_(*args): # 
      return self._validate_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_validate_(*args): # 
      return self._validate_alt_(*args)
    else:
      raise ValueError('Invalid argument list validate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.validate()')
  def numblocks(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_numblocks_(*args): # 
      return self._numblocks_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_numblocks_(*args): # 
      return self._numblocks_alt_(*args)
    else:
      raise ValueError('Invalid argument list numblocks('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.numblocks()')
  def alloc(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_alloc_I(*args): # int32
      return self._alloc_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_alloc_I(*args): # int32
      return self._alloc_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.alloc(int32)')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_get_I_3II(*args): # int32,[]int32,int32
      return self._get_I_3II(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_get_I_3II(*args): # int32,[]int32,int32
      return self._get_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.get(int32,array(int32,ndim=1),int32)')
  def capacity(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_capacity_(*args): # 
      return self._capacity_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_capacity_(*args): # 
      return self._capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.capacity()')
  def blocksize(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_blocksize_I(*args): # int32
      return self._blocksize_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_blocksize_I(*args): # int32
      return self._blocksize_alt_I(*args)
    else:
      raise ValueError('Invalid argument list blocksize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.blocksize(int32)')
  def __repr__(self): return 'mosek.fusion.LinkedBlocks'
  @staticmethod
  def _ctor_():
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_LinkedBlocks._ctor_init_I(self,0)
  @staticmethod
  def _ctor_I(n):
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_I(n)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    n, = args
    return (__arg_match_I__(n))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    n, = args
    return (__arg_alt_match_I__(n))
  def _ctor_alt_init_I(self,n):
    self._ctor_init_I(numpy.int32(n))
  def _ctor_init_I(self,n):
   self.__ints = mosek_fusion_LinkedInts._ctor_I(n)
   self.__blocks = mosek_fusion_LinkedInts._ctor_I(128)
   self.__bsize = numpy.zeros((128,), dtype=numpy.dtype(numpy.int32))
   self.__bfirst = numpy.zeros((128,), dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinkedBlocks_2(other):
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinkedBlocks_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinkedBlocks_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinkedBlocks_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(other)
  def _ctor_init_Lmosek_4fusion_4LinkedBlocks_2(self,other):
   self.__ints = mosek_fusion_LinkedInts._ctor_Lmosek_4fusion_4LinkedInts_2((other.__ints))
   self.__blocks = mosek_fusion_LinkedInts._ctor_Lmosek_4fusion_4LinkedInts_2((other.__blocks))
   self.__bsize = mosek.fusion.Utils.Tools._arraycopy__3I((other.__bsize))
   self.__bfirst = mosek.fusion.Utils.Tools._arraycopy__3I((other.__bfirst))
  @staticmethod
  def _match_free_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_free_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _free_alt_I(self,_t__0):
    return self._free_I(numpy.int32(__0))
  def _free_I(self,_0):
   _1=self.__bfirst[_0]
   self.__ints.free(_0,self.__bsize[_0])
   self.__bsize[_0] = (- 1)
   self.__bfirst[_0] = (- 1)
   self.__blocks.free(_1,1)
  @staticmethod
  def _match_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloc_alt_I(self,_t__0):
    return self._alloc_I(numpy.int32(__0))
  def _alloc_I(self,_0):
   _1=(self.__ints.alloc(_0) if ((_0 > 0) ) else (- 1))
   _2=self.__blocks.alloc()
   if (self.__blocks.capacity() > int((self.__bsize).shape[0])): # src/fusion/LinkedList.monty:236:12-42
    _3=numpy.zeros((self.__blocks.capacity(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((self.__blocks.capacity(),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__bsize,0,_3,0,int((self.__bsize).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__bfirst,0,_4,0,int((self.__bfirst).shape[0]))
    self.__bsize = _3
    self.__bfirst = _4
   self.__bfirst[_2] = _1
   self.__bsize[_2] = _0
   return numpy.int32(_2)
  @staticmethod
  def _match_maxidx_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_maxidx_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _maxidx_alt_I(self,_t__0):
    return self._maxidx_I(numpy.int32(__0))
  def _maxidx_I(self,_0):
   return numpy.int32(self.__ints.maxidx(self.__bfirst[_0],self.__bsize[_0]))
  @staticmethod
  def _match_get_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_get_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2))
  def _get_alt_I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self._get_I_3II(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _get_I_3II(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self.__ints.get(self.__bfirst[_0],self.__bsize[_0],_1,_2)
  @staticmethod
  def _match_numblocks_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numblocks_(*args):
    if len(args) != 0: return False
    return True
  def _numblocks_alt_(self,):
    return self._numblocks_()
  def _numblocks_(self,):
   return numpy.int32(int((self.__bsize).shape[0]))
  @staticmethod
  def _match_blocksize_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_blocksize_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _blocksize_alt_I(self,_t__0):
    return self._blocksize_I(numpy.int32(__0))
  def _blocksize_I(self,_0):
   return numpy.int32(self.__bsize[_0])
  @staticmethod
  def _match_capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_capacity_(*args):
    if len(args) != 0: return False
    return True
  def _capacity_alt_(self,):
    return self._capacity_()
  def _capacity_(self,):
   return numpy.int32(self.__ints.capacity())
  @staticmethod
  def _match_validate_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_validate_(*args):
    if len(args) != 0: return False
    return True
  def _validate_alt_(self,):
    return self._validate_()
  def _validate_(self,):
   return ((self.__ints.validate() and self.__blocks.validate()))
 return LinkedBlocks
mosek_fusion_LinkedBlocks=__mk_mosek_fusion_LinkedBlocks()
del __mk_mosek_fusion_LinkedBlocks
#BEFORE CLASS
def __mk_mosek_fusion_LinkedInts():
 class LinkedInts(object):
  __slots__ = ['_LinkedInts__nfree','_LinkedInts__last_free','_LinkedInts__first_free','_LinkedInts__first_used','_LinkedInts__prev','_LinkedInts__next']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_I(*args): # int32
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):# int32
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4LinkedInts_2(*args): # mosek.fusion.LinkedInts
      self._ctor_init_Lmosek_4fusion_4LinkedInts_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4LinkedInts_2(*args):# mosek.fusion.LinkedInts
      self._ctor_alt_init_Lmosek_4fusion_4LinkedInts_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LinkedInts.ctor()\n\tmosek.fusion.LinkedInts.ctor(int32)\n\tmosek.fusion.LinkedInts.ctor(mosek.fusion.LinkedInts)')
  def free(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_free_II(*args): # int32,int32
      return self._free_II(*args)
    elif mosek_fusion_LinkedInts._match_alt_free_II(*args): # int32,int32
      return self._free_alt_II(*args)
    else:
      raise ValueError('Invalid argument list free('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.free(int32,int32)')
  def validate(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_validate_(*args): # 
      return self._validate_(*args)
    elif mosek_fusion_LinkedInts._match_alt_validate_(*args): # 
      return self._validate_alt_(*args)
    else:
      raise ValueError('Invalid argument list validate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.validate()')
  def maxidx(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_maxidx_II(*args): # int32,int32
      return self._maxidx_II(*args)
    elif mosek_fusion_LinkedInts._match_alt_maxidx_II(*args): # int32,int32
      return self._maxidx_alt_II(*args)
    else:
      raise ValueError('Invalid argument list maxidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.maxidx(int32,int32)')
  def capacity(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_capacity_(*args): # 
      return self._capacity_(*args)
    elif mosek_fusion_LinkedInts._match_alt_capacity_(*args): # 
      return self._capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.capacity()')
  def alloc(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_alloc_(*args): # 
      return self._alloc_(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_(*args): # 
      return self._alloc_alt_(*args)
    elif mosek_fusion_LinkedInts._match_alloc_I(*args): # int32
      return self._alloc_I(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_I(*args): # int32
      return self._alloc_alt_I(*args)
    elif mosek_fusion_LinkedInts._match_alloc_I_3II(*args): # int32,[]int32,int32
      return self._alloc_I_3II(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_I_3II(*args): # int32,[]int32,int32
      return self._alloc_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list alloc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.alloc()\n\tmosek.fusion.LinkedInts.alloc(int32)\n\tmosek.fusion.LinkedInts.alloc(int32,array(int32,ndim=1),int32)')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_get_II_3II(*args): # int32,int32,[]int32,int32
      return self._get_II_3II(*args)
    elif mosek_fusion_LinkedInts._match_alt_get_II_3II(*args): # int32,int32,[]int32,int32
      return self._get_alt_II_3II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.get(int32,int32,array(int32,ndim=1),int32)')
  def __repr__(self): return 'mosek.fusion.LinkedInts'
  @staticmethod
  def _ctor_I(cap_):
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_I(cap_)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    cap_, = args
    return (__arg_match_I__(cap_))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    cap_, = args
    return (__arg_alt_match_I__(cap_))
  def _ctor_alt_init_I(self,cap_):
    self._ctor_init_I(numpy.int32(cap_))
  def _ctor_init_I(self,cap_):
   _0=(cap_ if ((cap_ > 0) ) else 128)
   self.__next = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   self.__prev = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   self.__first_used = (- 1)
   self.__first_free = 0
   self.__last_free = (_0 - 1)
   for _1 in range(1,_0):
    self.__prev[_1] = (_1 - 1)
    self.__next[(_1 - 1)] = _1
   self.__prev[0] = (- 1)
   self.__next[(_0 - 1)] = (- 1)
   self.__nfree = _0
  @staticmethod
  def _ctor_():
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_LinkedInts._ctor_init_I(self,128)
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinkedInts_2(other):
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_Lmosek_4fusion_4LinkedInts_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinkedInts_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinkedInts_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinkedInts_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinkedInts_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinkedInts_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinkedInts_2(other)
  def _ctor_init_Lmosek_4fusion_4LinkedInts_2(self,other):
   self.__next = mosek.fusion.Utils.Tools._arraycopy__3I((other.__next))
   self.__prev = mosek.fusion.Utils.Tools._arraycopy__3I((other.__prev))
   self.__first_used = (other.__first_used)
   self.__first_free = (other.__first_free)
   self.__last_free = (other.__last_free)
   self.__nfree = (other.__nfree)
  @staticmethod
  def _match_free_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_free_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _free_alt_II(self,_t__0,_t__1):
    return self._free_II(numpy.int32(__0),numpy.int32(__1))
  def _free_II(self,_0,_1):
   _2=_0
   _3=_2
   for _4 in range(0,(_1 - 1)):
    _3 = self.__next[_3]
   _5=self.__prev[_2]
   _6=self.__next[_3]
   if (_5 >= 0): # src/fusion/LinkedList.monty:185:12-19
    self.__next[_5] = _6
   if (_6 >= 0): # src/fusion/LinkedList.monty:186:12-19
    self.__prev[_6] = _5
   self.__prev[_2] = (- 1)
   self.__next[_3] = self.__first_free
   if (self.__first_free >= 0): # src/fusion/LinkedList.monty:190:12-27
    self.__prev[self.__first_free] = _3
   self.__first_free = _2
   self.__nfree += _1
  @staticmethod
  def _match_alloc_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_alloc_(*args):
    if len(args) != 0: return False
    return True
  def _alloc_alt_(self,):
    return self._alloc_()
  def _alloc_(self,):
   return numpy.int32(self.__allocblock_I(1))
  @staticmethod
  def _match_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloc_alt_I(self,_t__0):
    return self._alloc_I(numpy.int32(__0))
  def _alloc_I(self,_0):
   return numpy.int32(self.__allocblock_I(_0))
  @staticmethod
  def _match_alloc_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_alloc_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2))
  def _alloc_alt_I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self._alloc_I_3II(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _alloc_I_3II(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=self.__allocblock_I(_0)
   for _4 in range(0,_0):
    _1[(_4 + _2)] = _3
    _3 = self.__next[_3]
  @staticmethod
  def _match_get_II_3II(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_get_II_3II(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_I__(_3))
  def _get_alt_II_3II(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int32(_t__3)
   _1 = self._get_II_3II(_0,_1,_2,_3)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _get_II_3II(self,_0,_1,_2,_3):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=_0
   for _5 in range(0,_1):
    _2[(_5 + _3)] = _4
    _4 = self.__next[_4]
  @staticmethod
  def _match_maxidx_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_maxidx_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _maxidx_alt_II(self,_t__0,_t__1):
    return self._maxidx_II(numpy.int32(__0),numpy.int32(__1))
  def _maxidx_II(self,_0,_1):
   _2=_0
   _3=_0
   for _4 in range(1,_1):
    _3 = self.__next[_3]
    if (_2 < _3): # src/fusion/LinkedList.monty:148:14-23
     _2 = _3
   return numpy.int32(_2)
  def __allocblock_alt_I(self,_t__0):
    return self.__allocblock_I(numpy.int32(__0))
  def __allocblock_I(self,_0):
   _1=int((self.__next).shape[0])
   if (self.__nfree < _0): # src/fusion/LinkedList.monty:117:12-23
    _2=(_0 - self.__nfree)
    if (_2 < _1): # src/fusion/LinkedList.monty:119:14-26
     _2 = _1
    self.__recap_I((_2 + _1))
   _3=self.__first_free
   _4=_3
   for _5 in range(0,(_0 - 1)):
    _4 = self.__next[_4]
   self.__first_free = self.__next[_4]
   if (self.__first_free < 0): # src/fusion/LinkedList.monty:129:12-26
    self.__last_free = (- 1)
   else:
    self.__prev[self.__first_free] = (- 1)
   self.__next[_4] = self.__first_used
   if (self.__first_used >= 0): # src/fusion/LinkedList.monty:134:12-27
    self.__prev[self.__first_used] = _4
   self.__first_used = _3
   self.__nfree -= _0
   return numpy.int32(_3)
  def __recap_alt_I(self,_t__0):
    return self.__recap_I(numpy.int32(__0))
  def __recap_I(self,_0):
   _1=int((self.__next).shape[0])
   if (_0 > _1): # src/fusion/LinkedList.monty:90:12-22
    self.__next = mosek.fusion.CommonTools._resize__3II(self.__next,_0)
    self.__prev = mosek.fusion.CommonTools._resize__3II(self.__prev,_0)
    for _2 in range(_1,(_0 - 1)):
     self.__next[_2] = (_2 + 1)
     self.__prev[(_2 + 1)] = _2
    self.__next[(_0 - 1)] = (- 1)
    self.__prev[_1] = self.__last_free
    if (self.__last_free < 0): # src/fusion/LinkedList.monty:102:14-27
     self.__first_free = _1
    else:
     self.__next[self.__last_free] = _1
    self.__last_free = (_0 - 1)
    self.__nfree += (_0 - _1)
  @staticmethod
  def _match_capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_capacity_(*args):
    if len(args) != 0: return False
    return True
  def _capacity_alt_(self,):
    return self._capacity_()
  def _capacity_(self,):
   return numpy.int32(int((self.__next).shape[0]))
  @staticmethod
  def _match_validate_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_validate_(*args):
    if len(args) != 0: return False
    return True
  def _validate_alt_(self,):
    return self._validate_()
  def _validate_(self,):
   _0=numpy.zeros((int((self.__next).shape[0]),), dtype=numpy.dtype(numpy.bool))
   _1=self.__first_used
   while (_1 >= 0):
    _0[_1] = True
    _1 = self.__next[_1]
    if ((_1 >= 0) and _0[_1]): # src/fusion/LinkedList.monty:23:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("used list/next is inconsistent")
   _1 = self.__first_free
   _2=0
   while (_1 >= 0):
    _2 += 1
    _0[_1] = True
    _1 = self.__next[_1]
    if ((_1 >= 0) and _0[_1]): # src/fusion/LinkedList.monty:33:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("free list/next is inconsistent")
   if (_2!=self.__nfree): # src/fusion/LinkedList.monty:36:12-22
    raise mosek_fusion_UnexpectedError._ctor_S("free next list did not contain nfree elements")
   for _3 in range(0,int((_0).shape[0])):
    if (not _0[_1]): # src/fusion/LinkedList.monty:41:14-26
     raise mosek_fusion_UnexpectedError._ctor_S("elements missing from used+free list")
   for _4 in range(0,int((_0).shape[0])):
    _0[_4] = False
   _1 = self.__last_free
   _5=0
   while (_1 >= 0):
    _5 += 1
    _0[_1] = True
    _1 = self.__prev[_1]
    if ((_1 >= 0) and _0[_1]): # src/fusion/LinkedList.monty:51:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("prev list is inconsistent")
   if (_5!=self.__nfree): # src/fusion/LinkedList.monty:55:12-22
    raise mosek_fusion_UnexpectedError._ctor_S("free prev list did not contain nfree elements")
   return (True)
 return LinkedInts
mosek_fusion_LinkedInts=__mk_mosek_fusion_LinkedInts()
del __mk_mosek_fusion_LinkedInts
#BEFORE CLASS
def __mk_mosek_fusion_Parameters():
 class Parameters(object):
  @staticmethod
  def setParameter(*args):
    if False: pass
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SS(*args): # mosek.fusion.Model,string,string
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args): # mosek.fusion.Model,string,string
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SI(*args): # mosek.fusion.Model,string,int32
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args): # mosek.fusion.Model,string,int32
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SD(*args): # mosek.fusion.Model,string,double
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args): # mosek.fusion.Model,string,double
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SD(*args)
    else:
      raise ValueError('Invalid argument list setParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,string)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,int32)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,double)')
  def __repr__(self): return 'mosek.fusion.Parameters'
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SD(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(_0,_1,numpy.float64(__2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SD(_0,_1,_2):
   if False: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4358:6-11
    pass
   elif (_1=="autoUpdateSolInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4359:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_1=="removeUnusedSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4361:10-41
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_1=="numThreads"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4363:6-26
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4365:8-35
     _3=_2
     if (0 <= _3): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4368:10-16
      _0._task_1put_1param_SD("MSK_IPAR_NUM_THREADS",_3)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   elif (_1=="intpntMultiThread"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4378:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
   if (_1=="mtSpincount"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4380:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4382:8-35
     _4=_2
     if ((0 <= _4) and (_4 <= 1000000000)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4385:10-36
      _0._task_1put_1param_SD("MSK_IPAR_MT_SPINCOUNT",_4)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_1=="optimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4395:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   if (_1=="biMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4397:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4399:8-35
     _5=_2
     if (0 <= _5): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4402:10-16
      _0._task_1put_1param_SD("MSK_IPAR_BI_MAX_ITERATIONS",_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4412:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4414:8-35
     _6=_2
     if (0 <= _6): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4417:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_6)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4427:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4429:8-35
     _7=_2
     if (0 <= _7): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4432:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_CUT_SECOND_OPT",_7)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logResponse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4442:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4444:8-35
     _8=_2
     if (0 <= _8): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4447:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_RESPONSE",_8)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   elif (_1=="logLocalInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4457:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
   if (_1=="logBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4459:6-21
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4461:8-35
     _9=_2
     if (0 <= _9): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4464:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_BI",_9)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4474:6-25
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4476:8-35
     _10=_2
     if (0 <= _10): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4479:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_BI_FREQ",_10)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_1=="biCleanOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4489:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_1=="intpntStartingPoint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4491:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_1=="intpntDiffStep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4493:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_1=="intpntScaling"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4495:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_1=="intpntSolveForm"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4497:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_1=="logIntpnt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4499:6-25
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4501:8-35
     _11=_2
     if (0 <= _11): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4504:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_INTPNT",_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4514:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4516:8-35
     _12=_2
     if (0 <= _12): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4519:10-16
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_ITERATIONS",_12)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4529:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4531:8-35
     _13=_2
     if (0 <= _13): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4534:10-16
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_OFF_COL_TRH",_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_1=="intpntOrderMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4544:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   if (_1=="intpntOrderGpNumSeeds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4546:6-37
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4548:8-35
     _14=_2
     if (0 <= _14): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4551:10-16
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_14)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   elif (_1=="intpntBasis"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4561:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_1=="biIgnoreMaxIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4563:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_1=="biIgnoreNumError"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4565:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_1=="intpntMaxNumCor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4567:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4569:8-35
     _15=_2
     if ((- 1) <= _15): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4572:10-17
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_NUM_COR",_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_1=="presolveUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4582:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_1=="presolveLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4584:6-29
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4586:8-35
     _16=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4589:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LEVEL",_16)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4599:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4601:8-35
     _17=_2
     if (0 <= _17): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4604:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_PRESOLVE",_17)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_1=="presolveLindepUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4614:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   if (_1=="presolveMaxNumPass"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4616:6-34
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4618:8-35
     _18=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4621:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_18)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_1=="presolveEliminatorMaxNumTries"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4631:6-45
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4633:8-35
     _19=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4636:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_19)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4646:6-41
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4648:8-35
     _20=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4651:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_20)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4661:6-30
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4663:8-35
     _21=_2
     if (0 <= _21): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4666:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_CRASH",_21)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4676:6-22
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4678:8-35
     _22=_2
     if (0 <= _22): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4681:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM",_22)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4691:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4693:8-35
     _23=_2
     if (0 <= _23): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4696:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_MINOR",_23)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4706:6-26
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4708:8-35
     _24=_2
     if (0 <= _24): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4711:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_FREQ",_24)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4721:6-42
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4723:8-35
     _25=_2
     if ((0 <= _25) and (_25 <= 100)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4726:10-29
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_25)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_1=="simPrimalSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4736:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_1=="simDualRestrictSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4738:6-40
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4740:8-35
     _26=_2
     if ((0 <= _26) and (_26 <= 100)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4743:10-29
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_26)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_1=="simDualSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4753:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_1=="simMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4755:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4757:8-35
     _27=_2
     if (0 <= _27): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4760:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_ITERATIONS",_27)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_1=="simHotstartLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4770:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_1=="simRefactorFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4772:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4774:8-35
     _28=_2
     if (0 <= _28): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4777:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_REFACTOR_FREQ",_28)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="simSeed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4787:6-23
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4789:8-35
     _29=_2
     if ((0 <= _29) and (_29 <= 32749)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4792:10-31
      _0._task_1put_1param_SD("MSK_IPAR_SIM_SEED",_29)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   elif (_1=="mioMode"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4802:10-27
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_1=="logMio"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4804:6-22
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4806:8-35
     _30=_2
     if (0 <= _30): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4809:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_MIO",_30)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4819:6-26
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4821:8-35
     _31=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4824:10-14
      _0._task_1put_1param_SD("MSK_IPAR_LOG_MIO_FREQ",_31)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4834:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4836:8-35
     _32=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4839:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_RELAXS",_32)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4849:6-33
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4851:8-35
     _33=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4854:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_33)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumRootCutRounds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4864:6-38
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4866:8-35
     _34=_2
     if (0 <= _34): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4869:10-16
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_34)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_1=="mioMaxNumSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4879:6-34
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4881:8-35
     _35=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4884:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_35)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_1=="mioNodeSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4894:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   if (_1=="mioHeuristicLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4896:6-33
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4898:8-35
     _36=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4901:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_HEURISTIC_LEVEL",_36)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4911:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4913:8-35
     _37=_2
     if (((- 1) <= _37) and (_37 <= 3)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4916:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_PROBING_LEVEL",_37)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4926:6-36
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4928:8-35
     _38=_2
     if (((- 1) <= _38) and (_38 <= 1)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4931:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_38)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4941:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4943:8-35
     _39=_2
     if (((- 1) <= _39) and (_39 <= 2)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4946:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_39)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_1=="mioBranchDir"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4956:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_1=="mioRootOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4958:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_1=="mioNodeOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4960:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_1=="mioPerspectiveReformulate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4962:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_1=="mioPropagateObjectiveConstraint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4964:10-51
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
   if (_1=="mioSeed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4966:6-23
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4968:8-35
     _40=_2
     if (0 <= _40): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4971:10-16
      _0._task_1put_1param_SD("MSK_IPAR_MIO_SEED",_40)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   elif (_1=="mioConicOuterApproximation"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4981:10-46
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
   elif (_1=="writeLpQuotedNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4983:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
   if (_1=="writeLpLineWidth"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4985:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4987:8-35
     _41=_2
     if (40 <= _41): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4990:10-17
      _0._task_1put_1param_SD("MSK_IPAR_WRITE_LP_LINE_WIDTH",_41)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5000:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5002:8-35
     _42=_2
     if (0 <= _42): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5005:10-16
      _0._task_1put_1param_SD("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_42)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   elif (_1=="writeLpFullObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5015:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   if (_1=="logInfeasAna"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5017:6-28
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5019:8-35
     _43=_2
     if (0 <= _43): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5022:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_INFEAS_ANA",_43)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   elif (_1=="licenseWait"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5032:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_1=="licenseSuppressExpireWrns"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5034:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_1=="licensePauseTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5036:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5038:8-35
     _44=_2
     if ((0 <= _44) and (_44 <= 1000000)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5041:10-33
      _0._task_1put_1param_SD("MSK_IPAR_LICENSE_PAUSE_TIME",_44)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_1=="licenseDebug"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5051:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_1=="log"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5053:6-19
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5055:8-35
     _45=_2
     if (0 <= _45): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5058:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG",_45)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5068:6-25
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5070:8-35
     _46=_2
     if (0 <= _46): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5073:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_EXPAND",_46)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5083:6-23
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5085:8-35
     _47=_2
     if (0 <= _47): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5088:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_FILE",_47)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5098:6-24
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5100:8-35
     _48=_2
     if (0 <= _48): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5103:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_ORDER",_48)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_1=="simScaling"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5113:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_1=="simScalingMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5115:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_1=="simPrimalPhaseoneMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5117:6-39
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5119:8-35
     _49=_2
     if ((0 <= _49) and (_49 <= 10)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5122:10-28
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_49)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5132:6-37
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5134:8-35
     _50=_2
     if ((0 <= _50) and (_50 <= 10)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5137:10-28
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_50)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5147:6-33
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5149:8-35
     _51=_2
     if (0 <= _51): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5152:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_51)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_1=="simHotstart"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5162:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_1=="simBasisFactorUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5164:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_1=="simDegen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5166:10-28
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_1=="simReformulation"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5168:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_1=="simExploitDupvec"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5170:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_1=="simSaveLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5172:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_1=="simNonSingular"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5174:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_1=="simDualCrash"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5176:6-28
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5178:8-35
     _52=_2
     if (0 <= _52): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5181:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_CRASH",_52)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_1=="infeasPreferPrimal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5191:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
   if (_1=="mioRootRepeatPresolveLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5193:6-42
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5195:8-35
     _53=_2
     if (((- 1) <= _53) and (_53 <= 1)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5198:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_53)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   elif (_1=="mioCutCmir"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5208:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_1=="mioCutClique"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5210:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_1=="mioCutImpliedBound"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5212:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_1=="mioCutKnapsackCover"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5214:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_1=="mioCutGmi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5216:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   if (_1=="presolveLindepRelWorkTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5218:6-40
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5220:8-35
     _54=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5223:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_54)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5233:6-40
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5235:8-35
     _55=_2
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5238:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_55)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_1=="cacheLicense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5248:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_1=="intpntRegularizationUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5250:10-43
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_1=="simSolveForm"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5252:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_1=="simSwitchOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5254:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   if (_1=="mioRinsMaxNodes"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5256:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5258:8-35
     _56=_2
     if ((- 1) <= _56): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5261:10-17
      _0._task_1put_1param_SD("MSK_IPAR_MIO_RINS_MAX_NODES",_56)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="mioFeaspumpLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5271:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5273:8-35
     _57=_2
     if (((- 1) <= _57) and (_57 <= 2)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5276:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_FEASPUMP_LEVEL",_57)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   if (_1=="optimizerMaxTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5286:6-32
    _58=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5289:8-12
     _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_58)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5296:6-27
    _59=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5299:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_59)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5306:6-27
    _60=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5309:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5316:6-36
    _61=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5319:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5326:6-36
    _62=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5329:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5336:6-31
    _63=_2
    if (1.000000e-14 <= _63): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5339:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5346:6-33
    _64=_2
    if ((0.000000e+00 <= _64) and (_64 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5349:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5356:6-30
    _65=_2
    if ((1.000000e-06 <= _65) and (_65 <= 9.999990e-01)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5359:8-47
     _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5366:6-32
    _66=_2
    if ((1.000000e-04 <= _66) and (_66 <= 9.999990e-01)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5369:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5376:6-29
    _67=_2
    if ((0.000000e+00 <= _67) and (_67 <= 9.999000e-01)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5379:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5386:6-30
    _68=_2
    if ((0.000000e+00 <= _68) and (_68 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5389:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5396:6-30
    _69=_2
    if ((0.000000e+00 <= _69) and (_69 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5399:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5406:6-30
    _70=_2
    if ((0.000000e+00 <= _70) and (_70 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5409:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5416:6-31
    _71=_2
    if ((0.000000e+00 <= _71) and (_71 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5419:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5426:6-33
    _72=_2
    if ((0.000000e+00 <= _72) and (_72 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5429:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5436:6-32
    _73=_2
    if ((0.000000e+00 <= _73) and (_73 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5439:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5446:6-32
    _74=_2
    if ((0.000000e+00 <= _74) and (_74 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5449:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5456:6-32
    _75=_2
    if ((0.000000e+00 <= _75) and (_75 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5459:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5466:6-34
    _76=_2
    if (1.000000e+00 <= _76): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5469:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5476:6-33
    _77=_2
    if ((0.000000e+00 <= _77) and (_77 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5479:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntTolPsafe"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5486:6-30
    _78=_2
    if (1.000000e-04 <= _78): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5489:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5496:6-30
    _79=_2
    if (1.000000e-04 <= _79): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5499:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5506:6-26
    _80=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5509:8-12
     _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioRelGapConst"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5516:6-30
    _81=_2
    if (1.000000e-15 <= _81): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5519:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5526:6-28
    _82=_2
    if (0.000000e+00 <= _82): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5529:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioTolAbsGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5536:6-28
    _83=_2
    if (0.000000e+00 <= _83): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5539:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5546:6-33
    _84=_2
    if (1.000000e-09 <= _84): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5549:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5556:6-25
    _85=_2
    if (1.000000e-09 <= _85): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5559:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5566:6-25
    _86=_2
    if (1.000000e-09 <= _86): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5569:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5576:6-28
    _87=_2
    if (0.000000e+00 <= _87): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5579:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5586:6-28
    _88=_2
    if (0.000000e+00 <= _88): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5589:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5596:6-28
    _89=_2
    if (0.000000e+00 <= _89): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5599:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5606:6-30
    _90=_2
    if (1.000000e-15 <= _90): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5609:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5616:6-36
    _91=_2
    if (0.000000e+00 <= _91): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5619:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5626:6-36
    _92=_2
    if (0.000000e+00 <= _92): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5629:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5636:6-32
    _93=_2
    if (1.000000e-12 <= _93): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5639:8-25
     _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5646:6-26
    _94=_2
    if ((1.000000e-09 <= _94) and (_94 <= 1.000000e-03)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5649:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="mioTolRelDualBoundImprovement"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5656:6-45
    _95=_2
    if ((0.000000e+00 <= _95) and (_95 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5659:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   elif (_1=="dataFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5666:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (dataFileName)")
   elif (_1=="basSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5668:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basSolFileName)")
   elif (_1=="itrSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5670:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (itrSolFileName)")
   elif (_1=="intSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5672:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intSolFileName)")
   elif (_1=="writeLpGenVarName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5674:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpGenVarName)")
   elif (_1=="remoteAccessToken"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:5676:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteAccessToken)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SI(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(_0,_1,numpy.int32(__2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SI(_0,_1,_2):
   if False: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3308:6-11
    pass
   elif (_1=="autoUpdateSolInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3309:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_1=="removeUnusedSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3311:10-41
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_1=="numThreads"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3313:6-26
    _3=_2
    if (0 <= _3): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3316:8-14
     _0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_3)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   elif (_1=="intpntMultiThread"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3323:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
   if (_1=="mtSpincount"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3325:6-27
    _4=_2
    if ((0 <= _4) and (_4 <= 1000000000)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3328:8-34
     _0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_4)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_1=="optimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3335:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   if (_1=="biMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3337:6-31
    _5=_2
    if (0 <= _5): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3340:8-14
     _0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_5)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3347:6-35
    _6=_2
    if (0 <= _6): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3350:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_6)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3357:6-31
    _7=_2
    if (0 <= _7): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3360:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_7)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logResponse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3367:6-27
    _8=_2
    if (0 <= _8): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3370:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",_8)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   elif (_1=="logLocalInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3377:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
   if (_1=="logBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3379:6-21
    _9=_2
    if (0 <= _9): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3382:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_9)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3389:6-25
    _10=_2
    if (0 <= _10): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3392:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_10)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_1=="biCleanOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3399:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_1=="intpntStartingPoint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3401:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_1=="intpntDiffStep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3403:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_1=="intpntScaling"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3405:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_1=="intpntSolveForm"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3407:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_1=="logIntpnt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3409:6-25
    _11=_2
    if (0 <= _11): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3412:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_11)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3419:6-35
    _12=_2
    if (0 <= _12): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3422:8-14
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_12)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3429:6-31
    _13=_2
    if (0 <= _13): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3432:8-14
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_13)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_1=="intpntOrderMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3439:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   if (_1=="intpntOrderGpNumSeeds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3441:6-37
    _14=_2
    if (0 <= _14): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3444:8-14
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_14)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   elif (_1=="intpntBasis"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3451:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_1=="biIgnoreMaxIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3453:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_1=="biIgnoreNumError"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3455:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_1=="intpntMaxNumCor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3457:6-31
    _15=_2
    if ((- 1) <= _15): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3460:8-15
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_15)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_1=="presolveUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3467:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_1=="presolveLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3469:6-29
    _16=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3472:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",_16)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3479:6-27
    _17=_2
    if (0 <= _17): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3482:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_17)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_1=="presolveLindepUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3489:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   if (_1=="presolveMaxNumPass"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3491:6-34
    _18=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3494:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_18)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_1=="presolveEliminatorMaxNumTries"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3501:6-45
    _19=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3504:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_19)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3511:6-41
    _20=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3514:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_20)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3521:6-30
    _21=_2
    if (0 <= _21): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3524:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_21)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3531:6-22
    _22=_2
    if (0 <= _22): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3534:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_22)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3541:6-27
    _23=_2
    if (0 <= _23): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3544:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",_23)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3551:6-26
    _24=_2
    if (0 <= _24): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3554:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_24)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3561:6-42
    _25=_2
    if ((0 <= _25) and (_25 <= 100)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3564:8-27
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_25)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_1=="simPrimalSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3571:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_1=="simDualRestrictSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3573:6-40
    _26=_2
    if ((0 <= _26) and (_26 <= 100)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3576:8-27
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_26)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_1=="simDualSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3583:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_1=="simMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3585:6-32
    _27=_2
    if (0 <= _27): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3588:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_27)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_1=="simHotstartLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3595:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_1=="simRefactorFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3597:6-31
    _28=_2
    if (0 <= _28): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3600:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_28)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="simSeed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3607:6-23
    _29=_2
    if ((0 <= _29) and (_29 <= 32749)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3610:8-29
     _0._task_1put_1param_SI("MSK_IPAR_SIM_SEED",_29)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   elif (_1=="mioMode"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3617:10-27
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_1=="logMio"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3619:6-22
    _30=_2
    if (0 <= _30): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3622:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_30)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3629:6-26
    _31=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3632:8-12
     _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_31)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3639:6-31
    _32=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3642:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_32)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3649:6-33
    _33=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3652:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_33)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumRootCutRounds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3659:6-38
    _34=_2
    if (0 <= _34): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3662:8-14
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_34)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_1=="mioMaxNumSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3669:6-34
    _35=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3672:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_35)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_1=="mioNodeSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3679:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   if (_1=="mioHeuristicLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3681:6-33
    _36=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3684:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_36)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3691:6-31
    _37=_2
    if (((- 1) <= _37) and (_37 <= 3)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3694:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_37)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3701:6-36
    _38=_2
    if (((- 1) <= _38) and (_38 <= 1)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3704:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_38)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3711:6-35
    _39=_2
    if (((- 1) <= _39) and (_39 <= 2)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3714:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_39)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_1=="mioBranchDir"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3721:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_1=="mioRootOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3723:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_1=="mioNodeOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3725:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_1=="mioPerspectiveReformulate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3727:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_1=="mioPropagateObjectiveConstraint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3729:10-51
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
   if (_1=="mioSeed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3731:6-23
    _40=_2
    if (0 <= _40): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3734:8-14
     _0._task_1put_1param_SI("MSK_IPAR_MIO_SEED",_40)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   elif (_1=="mioConicOuterApproximation"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3741:10-46
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
   elif (_1=="writeLpQuotedNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3743:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
   if (_1=="writeLpLineWidth"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3745:6-32
    _41=_2
    if (40 <= _41): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3748:8-15
     _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_41)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3755:6-35
    _42=_2
    if (0 <= _42): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3758:8-14
     _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_42)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   elif (_1=="writeLpFullObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3765:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   if (_1=="logInfeasAna"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3767:6-28
    _43=_2
    if (0 <= _43): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3770:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",_43)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   elif (_1=="licenseWait"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3777:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_1=="licenseSuppressExpireWrns"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3779:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_1=="licensePauseTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3781:6-32
    _44=_2
    if ((0 <= _44) and (_44 <= 1000000)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3784:8-31
     _0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_44)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_1=="licenseDebug"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3791:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_1=="log"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3793:6-19
    _45=_2
    if (0 <= _45): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3796:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG",_45)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3803:6-25
    _46=_2
    if (0 <= _46): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3806:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_46)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3813:6-23
    _47=_2
    if (0 <= _47): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3816:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_47)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3823:6-24
    _48=_2
    if (0 <= _48): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3826:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_48)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_1=="simScaling"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3833:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_1=="simScalingMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3835:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_1=="simPrimalPhaseoneMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3837:6-39
    _49=_2
    if ((0 <= _49) and (_49 <= 10)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3840:8-26
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_49)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3847:6-37
    _50=_2
    if ((0 <= _50) and (_50 <= 10)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3850:8-26
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_50)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3857:6-33
    _51=_2
    if (0 <= _51): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3860:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_51)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_1=="simHotstart"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3867:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_1=="simBasisFactorUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3869:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_1=="simDegen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3871:10-28
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_1=="simReformulation"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3873:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_1=="simExploitDupvec"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3875:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_1=="simSaveLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3877:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_1=="simNonSingular"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3879:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_1=="simDualCrash"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3881:6-28
    _52=_2
    if (0 <= _52): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3884:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_52)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_1=="infeasPreferPrimal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3891:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
   if (_1=="mioRootRepeatPresolveLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3893:6-42
    _53=_2
    if (((- 1) <= _53) and (_53 <= 1)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3896:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_53)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   elif (_1=="mioCutCmir"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3903:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_1=="mioCutClique"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3905:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_1=="mioCutImpliedBound"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3907:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_1=="mioCutKnapsackCover"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3909:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_1=="mioCutGmi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3911:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   if (_1=="presolveLindepRelWorkTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3913:6-40
    _54=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3916:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_54)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3923:6-40
    _55=_2
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3926:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_55)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_1=="cacheLicense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3933:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_1=="intpntRegularizationUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3935:10-43
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_1=="simSolveForm"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3937:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_1=="simSwitchOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3939:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   if (_1=="mioRinsMaxNodes"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3941:6-31
    _56=_2
    if ((- 1) <= _56): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3944:8-15
     _0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_56)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="mioFeaspumpLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3951:6-32
    _57=_2
    if (((- 1) <= _57) and (_57 <= 2)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3954:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",_57)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   if (_1=="optimizerMaxTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3961:6-32
    _58=numpy.float64(_2)
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3964:8-12
     _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_58)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3971:6-27
    _59=numpy.float64(_2)
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3974:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_59)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3981:6-27
    _60=numpy.float64(_2)
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3984:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3991:6-36
    _61=numpy.float64(_2)
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3994:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4001:6-36
    _62=numpy.float64(_2)
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4004:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4011:6-31
    _63=numpy.float64(_2)
    if (1.000000e-14 <= _63): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4014:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4021:6-33
    _64=numpy.float64(_2)
    if ((0.000000e+00 <= _64) and (_64 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4024:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4031:6-30
    _65=numpy.float64(_2)
    if ((1.000000e-06 <= _65) and (_65 <= 9.999990e-01)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4034:8-47
     _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4041:6-32
    _66=numpy.float64(_2)
    if ((1.000000e-04 <= _66) and (_66 <= 9.999990e-01)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4044:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4051:6-29
    _67=numpy.float64(_2)
    if ((0.000000e+00 <= _67) and (_67 <= 9.999000e-01)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4054:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4061:6-30
    _68=numpy.float64(_2)
    if ((0.000000e+00 <= _68) and (_68 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4064:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4071:6-30
    _69=numpy.float64(_2)
    if ((0.000000e+00 <= _69) and (_69 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4074:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4081:6-30
    _70=numpy.float64(_2)
    if ((0.000000e+00 <= _70) and (_70 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4084:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4091:6-31
    _71=numpy.float64(_2)
    if ((0.000000e+00 <= _71) and (_71 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4094:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4101:6-33
    _72=numpy.float64(_2)
    if ((0.000000e+00 <= _72) and (_72 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4104:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4111:6-32
    _73=numpy.float64(_2)
    if ((0.000000e+00 <= _73) and (_73 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4114:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4121:6-32
    _74=numpy.float64(_2)
    if ((0.000000e+00 <= _74) and (_74 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4124:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4131:6-32
    _75=numpy.float64(_2)
    if ((0.000000e+00 <= _75) and (_75 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4134:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4141:6-34
    _76=numpy.float64(_2)
    if (1.000000e+00 <= _76): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4144:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4151:6-33
    _77=numpy.float64(_2)
    if ((0.000000e+00 <= _77) and (_77 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4154:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntTolPsafe"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4161:6-30
    _78=numpy.float64(_2)
    if (1.000000e-04 <= _78): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4164:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4171:6-30
    _79=numpy.float64(_2)
    if (1.000000e-04 <= _79): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4174:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4181:6-26
    _80=numpy.float64(_2)
    if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4184:8-12
     _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioRelGapConst"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4191:6-30
    _81=numpy.float64(_2)
    if (1.000000e-15 <= _81): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4194:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4201:6-28
    _82=numpy.float64(_2)
    if (0.000000e+00 <= _82): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4204:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioTolAbsGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4211:6-28
    _83=numpy.float64(_2)
    if (0.000000e+00 <= _83): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4214:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4221:6-33
    _84=numpy.float64(_2)
    if (1.000000e-09 <= _84): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4224:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4231:6-25
    _85=numpy.float64(_2)
    if (1.000000e-09 <= _85): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4234:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4241:6-25
    _86=numpy.float64(_2)
    if (1.000000e-09 <= _86): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4244:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4251:6-28
    _87=numpy.float64(_2)
    if (0.000000e+00 <= _87): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4254:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4261:6-28
    _88=numpy.float64(_2)
    if (0.000000e+00 <= _88): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4264:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4271:6-28
    _89=numpy.float64(_2)
    if (0.000000e+00 <= _89): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4274:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4281:6-30
    _90=numpy.float64(_2)
    if (1.000000e-15 <= _90): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4284:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4291:6-36
    _91=numpy.float64(_2)
    if (0.000000e+00 <= _91): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4294:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4301:6-36
    _92=numpy.float64(_2)
    if (0.000000e+00 <= _92): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4304:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4311:6-32
    _93=numpy.float64(_2)
    if (1.000000e-12 <= _93): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4314:8-25
     _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4321:6-26
    _94=numpy.float64(_2)
    if ((1.000000e-09 <= _94) and (_94 <= 1.000000e-03)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4324:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="mioTolRelDualBoundImprovement"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4331:6-45
    _95=numpy.float64(_2)
    if ((0.000000e+00 <= _95) and (_95 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4334:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   elif (_1=="dataFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4341:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (dataFileName)")
   elif (_1=="basSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4343:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basSolFileName)")
   elif (_1=="itrSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4345:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (itrSolFileName)")
   elif (_1=="intSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4347:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intSolFileName)")
   elif (_1=="writeLpGenVarName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4349:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpGenVarName)")
   elif (_1=="remoteAccessToken"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:4351:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteAccessToken)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_S__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_S__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SS(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(_0,_1,_2)
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SS(_0,_1,_2):
   if False: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1672:6-11
    pass
   if (_1=="autoUpdateSolInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1673:6-33
    _3=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_3 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1676:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
    _0._task_1put_1param_SI("MSK_IPAR_AUTO_UPDATE_SOL_INFO",_3)
    return 
   if (_1=="removeUnusedSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1681:6-37
    _4=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_4 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1684:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
    _0._task_1put_1param_SI("MSK_IPAR_REMOVE_UNUSED_SOLUTIONS",_4)
    return 
   if (_1=="numThreads"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1689:6-26
    try:
     _5=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _5): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1694:10-16
      _0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    except mosek_fusion_ValueConversionError as _6:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   if (_1=="intpntMultiThread"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1701:6-33
    _7=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_7 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1704:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MULTI_THREAD",_7)
    return 
   if (_1=="mtSpincount"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1709:6-27
    try:
     _8=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _8) and (_8 <= 1000000000)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1714:10-36
      _0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_8)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    except mosek_fusion_ValueConversionError as _9:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   if (_1=="optimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1721:6-25
    _10=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_10 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1724:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_OPTIMIZER",_10)
    return 
   if (_1=="biMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1729:6-31
    try:
     _11=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _11): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1734:10-16
      _0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    except mosek_fusion_ValueConversionError as _12:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1741:6-35
    try:
     _13=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _13): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1746:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    except mosek_fusion_ValueConversionError as _14:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1753:6-31
    try:
     _15=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _15): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1758:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    except mosek_fusion_ValueConversionError as _16:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logResponse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1765:6-27
    try:
     _17=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _17): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1770:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",_17)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
    except mosek_fusion_ValueConversionError as _18:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   if (_1=="logLocalInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1777:6-28
    _19=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_19 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1780:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
    _0._task_1put_1param_SI("MSK_IPAR_LOG_LOCAL_INFO",_19)
    return 
   if (_1=="logBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1785:6-21
    try:
     _20=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _20): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1790:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_20)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    except mosek_fusion_ValueConversionError as _21:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1797:6-25
    try:
     _22=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _22): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1802:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_22)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    except mosek_fusion_ValueConversionError as _23:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   if (_1=="biCleanOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1809:6-32
    _24=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_24 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1812:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_CLEAN_OPTIMIZER",_24)
    return 
   if (_1=="intpntStartingPoint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1817:6-35
    _25=mosek.fusion.Parameters.__string_1to_1startpointtype_1value_S(_2)
    if (_25 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1820:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_STARTING_POINT",_25)
    return 
   if (_1=="intpntDiffStep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1825:6-30
    _26=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_26 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1828:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_DIFF_STEP",_26)
    return 
   if (_1=="intpntScaling"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1833:6-29
    _27=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_2)
    if (_27 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1836:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_SCALING",_27)
    return 
   if (_1=="intpntSolveForm"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1841:6-31
    _28=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_2)
    if (_28 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1844:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_SOLVE_FORM",_28)
    return 
   if (_1=="logIntpnt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1849:6-25
    try:
     _29=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _29): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1854:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_29)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    except mosek_fusion_ValueConversionError as _30:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1861:6-35
    try:
     _31=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _31): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1866:10-16
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_31)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    except mosek_fusion_ValueConversionError as _32:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1873:6-31
    try:
     _33=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _33): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1878:10-16
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_33)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    except mosek_fusion_ValueConversionError as _34:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   if (_1=="intpntOrderMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1885:6-33
    _35=mosek.fusion.Parameters.__string_1to_1orderingtype_1value_S(_2)
    if (_35 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1888:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_METHOD",_35)
    return 
   if (_1=="intpntOrderGpNumSeeds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1893:6-37
    try:
     _36=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _36): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1898:10-16
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_36)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
    except mosek_fusion_ValueConversionError as _37:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   if (_1=="intpntBasis"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1905:6-27
    _38=mosek.fusion.Parameters.__string_1to_1basindtype_1value_S(_2)
    if (_38 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1908:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_BASIS",_38)
    return 
   if (_1=="biIgnoreMaxIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1913:6-31
    _39=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_39 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1916:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_MAX_ITER",_39)
    return 
   if (_1=="biIgnoreNumError"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1921:6-32
    _40=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_40 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1924:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_NUM_ERROR",_40)
    return 
   if (_1=="intpntMaxNumCor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1929:6-31
    try:
     _41=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((- 1) <= _41): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1934:10-17
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_41)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    except mosek_fusion_ValueConversionError as _42:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   if (_1=="presolveUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1941:6-27
    _43=mosek.fusion.Parameters.__string_1to_1presolvemode_1value_S(_2)
    if (_43 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1944:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
    _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_USE",_43)
    return 
   if (_1=="presolveLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1949:6-29
    try:
     _44=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1954:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",_44)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
    except mosek_fusion_ValueConversionError as _45:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1961:6-27
    try:
     _46=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _46): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1966:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_46)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    except mosek_fusion_ValueConversionError as _47:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   if (_1=="presolveLindepUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1973:6-33
    _48=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_48 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1976:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
    _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_USE",_48)
    return 
   if (_1=="presolveMaxNumPass"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1981:6-34
    try:
     _49=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1986:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_49)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
    except mosek_fusion_ValueConversionError as _50:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_1=="presolveEliminatorMaxNumTries"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1993:6-45
    try:
     _51=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1998:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_51)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    except mosek_fusion_ValueConversionError as _52:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2005:6-41
    try:
     _53=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2010:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_53)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    except mosek_fusion_ValueConversionError as _54:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2017:6-30
    try:
     _55=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _55): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2022:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_55)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    except mosek_fusion_ValueConversionError as _56:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2029:6-22
    try:
     _57=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _57): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2034:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_57)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    except mosek_fusion_ValueConversionError as _58:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2041:6-27
    try:
     _59=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _59): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2046:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",_59)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
    except mosek_fusion_ValueConversionError as _60:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2053:6-26
    try:
     _61=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _61): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2058:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_61)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    except mosek_fusion_ValueConversionError as _62:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2065:6-42
    try:
     _63=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _63) and (_63 <= 100)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2070:10-29
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_63)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    except mosek_fusion_ValueConversionError as _64:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   if (_1=="simPrimalSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2077:6-34
    _65=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_2)
    if (_65 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2080:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_SELECTION",_65)
    return 
   if (_1=="simDualRestrictSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2085:6-40
    try:
     _66=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _66) and (_66 <= 100)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2090:10-29
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_66)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    except mosek_fusion_ValueConversionError as _67:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   if (_1=="simDualSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2097:6-32
    _68=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_2)
    if (_68 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2100:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_SELECTION",_68)
    return 
   if (_1=="simMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2105:6-32
    try:
     _69=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _69): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2110:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_69)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    except mosek_fusion_ValueConversionError as _70:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   if (_1=="simHotstartLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2117:6-29
    _71=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_71 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2120:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART_LU",_71)
    return 
   if (_1=="simRefactorFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2125:6-31
    try:
     _72=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _72): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2130:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_72)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    except mosek_fusion_ValueConversionError as _73:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="simSeed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2137:6-23
    try:
     _74=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _74) and (_74 <= 32749)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2142:10-31
      _0._task_1put_1param_SI("MSK_IPAR_SIM_SEED",_74)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
    except mosek_fusion_ValueConversionError as _75:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   if (_1=="mioMode"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2149:6-23
    _76=mosek.fusion.Parameters.__string_1to_1miomode_1value_S(_2)
    if (_76 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2152:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_MODE",_76)
    return 
   if (_1=="logMio"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2157:6-22
    try:
     _77=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _77): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2162:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_77)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    except mosek_fusion_ValueConversionError as _78:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2169:6-26
    try:
     _79=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2174:10-14
      _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_79)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    except mosek_fusion_ValueConversionError as _80:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2181:6-31
    try:
     _81=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2186:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_81)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    except mosek_fusion_ValueConversionError as _82:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2193:6-33
    try:
     _83=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2198:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_83)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    except mosek_fusion_ValueConversionError as _84:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumRootCutRounds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2205:6-38
    try:
     _85=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _85): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2210:10-16
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_85)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
    except mosek_fusion_ValueConversionError as _86:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_1=="mioMaxNumSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2217:6-34
    try:
     _87=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2222:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_87)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    except mosek_fusion_ValueConversionError as _88:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   if (_1=="mioNodeSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2229:6-32
    _89=mosek.fusion.Parameters.__string_1to_1mionodeseltype_1value_S(_2)
    if (_89 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2232:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_SELECTION",_89)
    return 
   if (_1=="mioHeuristicLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2237:6-33
    try:
     _90=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2242:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_90)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    except mosek_fusion_ValueConversionError as _91:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2249:6-31
    try:
     _92=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _92) and (_92 <= 3)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2254:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_92)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    except mosek_fusion_ValueConversionError as _93:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2261:6-36
    try:
     _94=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _94) and (_94 <= 1)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2266:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_94)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    except mosek_fusion_ValueConversionError as _95:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2273:6-35
    try:
     _96=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _96) and (_96 <= 2)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2278:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_96)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    except mosek_fusion_ValueConversionError as _97:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   if (_1=="mioBranchDir"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2285:6-28
    _98=mosek.fusion.Parameters.__string_1to_1branchdir_1value_S(_2)
    if (_98 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2288:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_BRANCH_DIR",_98)
    return 
   if (_1=="mioRootOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2293:6-32
    _99=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_99 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2296:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_OPTIMIZER",_99)
    return 
   if (_1=="mioNodeOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2301:6-32
    _100=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_100 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2304:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_OPTIMIZER",_100)
    return 
   if (_1=="mioPerspectiveReformulate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2309:6-41
    _101=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_101 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2312:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE",_101)
    return 
   if (_1=="mioPropagateObjectiveConstraint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2317:6-47
    _102=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_102 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2320:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT",_102)
    return 
   if (_1=="mioSeed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2325:6-23
    try:
     _103=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _103): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2330:10-16
      _0._task_1put_1param_SI("MSK_IPAR_MIO_SEED",_103)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
    except mosek_fusion_ValueConversionError as _104:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   if (_1=="mioConicOuterApproximation"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2337:6-42
    _105=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_105 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2340:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION",_105)
    return 
   if (_1=="writeLpQuotedNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2345:6-34
    _106=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_106 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2348:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
    _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_QUOTED_NAMES",_106)
    return 
   if (_1=="writeLpLineWidth"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2353:6-32
    try:
     _107=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (40 <= _107): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2358:10-17
      _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_107)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    except mosek_fusion_ValueConversionError as _108:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2365:6-35
    try:
     _109=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _109): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2370:10-16
      _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_109)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
    except mosek_fusion_ValueConversionError as _110:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   if (_1=="writeLpFullObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2377:6-30
    _111=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_111 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2380:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
    _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_FULL_OBJ",_111)
    return 
   if (_1=="logInfeasAna"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2385:6-28
    try:
     _112=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _112): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2390:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",_112)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
    except mosek_fusion_ValueConversionError as _113:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   if (_1=="licenseWait"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2397:6-27
    _114=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_114 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2400:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_WAIT",_114)
    return 
   if (_1=="licenseSuppressExpireWrns"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2405:6-41
    _115=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_115 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2408:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS",_115)
    return 
   if (_1=="licensePauseTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2413:6-32
    try:
     _116=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _116) and (_116 <= 1000000)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2418:10-33
      _0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_116)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    except mosek_fusion_ValueConversionError as _117:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   if (_1=="licenseDebug"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2425:6-28
    _118=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_118 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2428:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_DEBUG",_118)
    return 
   if (_1=="log"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2433:6-19
    try:
     _119=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _119): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2438:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG",_119)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    except mosek_fusion_ValueConversionError as _120:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2445:6-25
    try:
     _121=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _121): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2450:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_121)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    except mosek_fusion_ValueConversionError as _122:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2457:6-23
    try:
     _123=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _123): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2462:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_123)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    except mosek_fusion_ValueConversionError as _124:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2469:6-24
    try:
     _125=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _125): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2474:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_125)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    except mosek_fusion_ValueConversionError as _126:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   if (_1=="simScaling"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2481:6-26
    _127=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_2)
    if (_127 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2484:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING",_127)
    return 
   if (_1=="simScalingMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2489:6-32
    _128=mosek.fusion.Parameters.__string_1to_1scalingmethod_1value_S(_2)
    if (_128 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2492:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING_METHOD",_128)
    return 
   if (_1=="simPrimalPhaseoneMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2497:6-39
    try:
     _129=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _129) and (_129 <= 10)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2502:10-28
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_129)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    except mosek_fusion_ValueConversionError as _130:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2509:6-37
    try:
     _131=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _131) and (_131 <= 10)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2514:10-28
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_131)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    except mosek_fusion_ValueConversionError as _132:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2521:6-33
    try:
     _133=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _133): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2526:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_133)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    except mosek_fusion_ValueConversionError as _134:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   if (_1=="simHotstart"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2533:6-27
    _135=mosek.fusion.Parameters.__string_1to_1simhotstart_1value_S(_2)
    if (_135 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2536:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART",_135)
    return 
   if (_1=="simBasisFactorUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2541:6-33
    _136=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_136 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2544:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_BASIS_FACTOR_USE",_136)
    return 
   if (_1=="simDegen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2549:6-24
    _137=mosek.fusion.Parameters.__string_1to_1simdegen_1value_S(_2)
    if (_137 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2552:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_DEGEN",_137)
    return 
   if (_1=="simReformulation"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2557:6-32
    _138=mosek.fusion.Parameters.__string_1to_1simreform_1value_S(_2)
    if (_138 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2560:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_REFORMULATION",_138)
    return 
   if (_1=="simExploitDupvec"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2565:6-32
    _139=mosek.fusion.Parameters.__string_1to_1simdupvec_1value_S(_2)
    if (_139 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2568:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_EXPLOIT_DUPVEC",_139)
    return 
   if (_1=="simSaveLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2573:6-25
    _140=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_140 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2576:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SAVE_LU",_140)
    return 
   if (_1=="simNonSingular"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2581:6-30
    _141=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_141 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2584:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_NON_SINGULAR",_141)
    return 
   if (_1=="simDualCrash"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2589:6-28
    try:
     _142=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _142): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2594:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_142)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    except mosek_fusion_ValueConversionError as _143:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   if (_1=="infeasPreferPrimal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2601:6-34
    _144=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_144 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2604:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
    _0._task_1put_1param_SI("MSK_IPAR_INFEAS_PREFER_PRIMAL",_144)
    return 
   if (_1=="mioRootRepeatPresolveLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2609:6-42
    try:
     _145=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _145) and (_145 <= 1)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2614:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_145)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
    except mosek_fusion_ValueConversionError as _146:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   if (_1=="mioCutCmir"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2621:6-26
    _147=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_147 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2624:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CMIR",_147)
    return 
   if (_1=="mioCutClique"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2629:6-28
    _148=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_148 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2632:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CLIQUE",_148)
    return 
   if (_1=="mioCutImpliedBound"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2637:6-34
    _149=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_149 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2640:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_IMPLIED_BOUND",_149)
    return 
   if (_1=="mioCutKnapsackCover"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2645:6-35
    _150=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_150 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2648:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_KNAPSACK_COVER",_150)
    return 
   if (_1=="mioCutGmi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2653:6-25
    _151=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_151 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2656:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_GMI",_151)
    return 
   if (_1=="presolveLindepRelWorkTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2661:6-40
    try:
     _152=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2666:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_152)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    except mosek_fusion_ValueConversionError as _153:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2673:6-40
    try:
     _154=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2678:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_154)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    except mosek_fusion_ValueConversionError as _155:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   if (_1=="cacheLicense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2685:6-28
    _156=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_156 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2688:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
    _0._task_1put_1param_SI("MSK_IPAR_CACHE_LICENSE",_156)
    return 
   if (_1=="intpntRegularizationUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2693:6-39
    _157=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_157 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2696:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_REGULARIZATION_USE",_157)
    return 
   if (_1=="simSolveForm"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2701:6-28
    _158=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_2)
    if (_158 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2704:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SOLVE_FORM",_158)
    return 
   if (_1=="simSwitchOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2709:6-34
    _159=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_159 < 0): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2712:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SWITCH_OPTIMIZER",_159)
    return 
   if (_1=="mioRinsMaxNodes"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2717:6-31
    try:
     _160=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((- 1) <= _160): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2722:10-17
      _0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_160)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    except mosek_fusion_ValueConversionError as _161:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="mioFeaspumpLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2729:6-32
    try:
     _162=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _162) and (_162 <= 2)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2734:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",_162)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
    except mosek_fusion_ValueConversionError as _163:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   if (_1=="optimizerMaxTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2741:6-32
    try:
     _164=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2746:10-14
      _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_164)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
    except mosek_fusion_ValueConversionError as _165:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2755:6-27
    try:
     _166=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2760:10-14
      _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_166)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
    except mosek_fusion_ValueConversionError as _167:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2769:6-27
    try:
     _168=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2774:10-14
      _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_168)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
    except mosek_fusion_ValueConversionError as _169:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2783:6-36
    try:
     _170=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2788:10-14
      _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_170)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError as _171:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2797:6-36
    try:
     _172=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2802:10-14
      _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_172)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError as _173:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2811:6-31
    try:
     _174=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-14 <= _174): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2816:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_174)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
    except mosek_fusion_ValueConversionError as _175:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2825:6-33
    try:
     _176=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _176) and (_176 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2830:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_176)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
    except mosek_fusion_ValueConversionError as _177:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2839:6-30
    try:
     _178=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-06 <= _178) and (_178 <= 9.999990e-01)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2844:10-49
      _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_178)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
    except mosek_fusion_ValueConversionError as _179:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2853:6-32
    try:
     _180=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-04 <= _180) and (_180 <= 9.999990e-01)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2858:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_180)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
    except mosek_fusion_ValueConversionError as _181:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2867:6-29
    try:
     _182=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _182) and (_182 <= 9.999000e-01)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2872:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_182)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
    except mosek_fusion_ValueConversionError as _183:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2881:6-30
    try:
     _184=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _184) and (_184 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2886:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_184)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
    except mosek_fusion_ValueConversionError as _185:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2895:6-30
    try:
     _186=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _186) and (_186 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2900:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_186)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
    except mosek_fusion_ValueConversionError as _187:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2909:6-30
    try:
     _188=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _188) and (_188 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2914:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_188)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
    except mosek_fusion_ValueConversionError as _189:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2923:6-31
    try:
     _190=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _190) and (_190 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2928:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_190)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
    except mosek_fusion_ValueConversionError as _191:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2937:6-33
    try:
     _192=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _192) and (_192 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2942:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_192)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
    except mosek_fusion_ValueConversionError as _193:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2951:6-32
    try:
     _194=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _194) and (_194 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2956:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_194)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
    except mosek_fusion_ValueConversionError as _195:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2965:6-32
    try:
     _196=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _196) and (_196 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2970:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_196)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
    except mosek_fusion_ValueConversionError as _197:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2979:6-32
    try:
     _198=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _198) and (_198 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2984:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_198)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
    except mosek_fusion_ValueConversionError as _199:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2993:6-34
    try:
     _200=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e+00 <= _200): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:2998:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_200)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
    except mosek_fusion_ValueConversionError as _201:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3007:6-33
    try:
     _202=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _202) and (_202 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3012:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_202)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
    except mosek_fusion_ValueConversionError as _203:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntTolPsafe"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3021:6-30
    try:
     _204=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-04 <= _204): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3026:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_204)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
    except mosek_fusion_ValueConversionError as _205:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3035:6-30
    try:
     _206=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-04 <= _206): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3040:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_206)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
    except mosek_fusion_ValueConversionError as _207:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3049:6-26
    try:
     _208=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3054:10-14
      _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_208)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
    except mosek_fusion_ValueConversionError as _209:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioRelGapConst"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3063:6-30
    try:
     _210=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-15 <= _210): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3068:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_210)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
    except mosek_fusion_ValueConversionError as _211:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3077:6-28
    try:
     _212=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _212): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3082:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_212)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
    except mosek_fusion_ValueConversionError as _213:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioTolAbsGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3091:6-28
    try:
     _214=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _214): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3096:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_214)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
    except mosek_fusion_ValueConversionError as _215:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3105:6-33
    try:
     _216=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _216): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3110:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_216)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
    except mosek_fusion_ValueConversionError as _217:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3119:6-25
    try:
     _218=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _218): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3124:10-27
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_218)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
    except mosek_fusion_ValueConversionError as _219:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3133:6-25
    try:
     _220=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _220): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3138:10-27
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_220)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
    except mosek_fusion_ValueConversionError as _221:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3147:6-28
    try:
     _222=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _222): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3152:10-27
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_222)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
    except mosek_fusion_ValueConversionError as _223:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3161:6-28
    try:
     _224=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _224): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3166:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_224)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
    except mosek_fusion_ValueConversionError as _225:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3175:6-28
    try:
     _226=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _226): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3180:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_226)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
    except mosek_fusion_ValueConversionError as _227:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3189:6-30
    try:
     _228=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-15 <= _228): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3194:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_228)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
    except mosek_fusion_ValueConversionError as _229:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3203:6-36
    try:
     _230=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _230): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3208:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_230)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
    except mosek_fusion_ValueConversionError as _231:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3217:6-36
    try:
     _232=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _232): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3222:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_232)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
    except mosek_fusion_ValueConversionError as _233:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3231:6-32
    try:
     _234=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-12 <= _234): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3236:10-27
      _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_234)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
    except mosek_fusion_ValueConversionError as _235:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3245:6-26
    try:
     _236=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-09 <= _236) and (_236 <= 1.000000e-03)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3250:10-49
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_236)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
    except mosek_fusion_ValueConversionError as _237:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="mioTolRelDualBoundImprovement"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3259:6-45
    try:
     _238=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _238) and (_238 <= 1.000000e+00)): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3264:10-49
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_238)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
    except mosek_fusion_ValueConversionError as _239:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   if (_1=="dataFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3273:6-28
    _0._task_1put_1param_SS("MSK_SPAR_DATA_FILE_NAME",_2)
    return 
   if (_1=="basSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3278:6-30
    _0._task_1put_1param_SS("MSK_SPAR_BAS_SOL_FILE_NAME",_2)
    return 
   if (_1=="itrSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3283:6-30
    _0._task_1put_1param_SS("MSK_SPAR_ITR_SOL_FILE_NAME",_2)
    return 
   if (_1=="intSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3288:6-30
    _0._task_1put_1param_SS("MSK_SPAR_INT_SOL_FILE_NAME",_2)
    return 
   if (_1=="writeLpGenVarName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3293:6-33
    _0._task_1put_1param_SS("MSK_SPAR_WRITE_LP_GEN_VAR_NAME",_2)
    return 
   if (_1=="remoteAccessToken"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:3298:6-33
    _0._task_1put_1param_SS("MSK_SPAR_REMOTE_ACCESS_TOKEN",_2)
    return 
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def __string_1to_1variabletype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1variabletype_1value_S(_0)
  @staticmethod
  def __string_1to_1variabletype_1value_S(_0):
   if (_0=="typeCont"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1665:6-21
    return numpy.int32(0)
   if (_0=="typeInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1666:6-20
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1value_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1value_1value_S(_0)
  @staticmethod
  def __string_1to_1value_1value_S(_0):
   if (_0=="maxStrLen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1659:6-22
    return numpy.int32(1024)
   if (_0=="licenseBufferLength"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1660:6-32
    return numpy.int32(21)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1streamtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1streamtype_1value_S(_0)
  @staticmethod
  def __string_1to_1streamtype_1value_S(_0):
   if (_0=="log"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1651:6-16
    return numpy.int32(0)
   if (_0=="msg"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1652:6-16
    return numpy.int32(1)
   if (_0=="err"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1653:6-16
    return numpy.int32(2)
   if (_0=="wrn"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1654:6-16
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1startpointtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1startpointtype_1value_S(_0)
  @staticmethod
  def __string_1to_1startpointtype_1value_S(_0):
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1643:6-17
    return numpy.int32(0)
   if (_0=="guess"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1644:6-18
    return numpy.int32(1)
   if (_0=="constant"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1645:6-21
    return numpy.int32(2)
   if (_0=="satisfyBounds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1646:6-26
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1stakey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1stakey_1value_S(_0)
  @staticmethod
  def __string_1to_1stakey_1value_S(_0):
   if (_0=="unk"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1632:6-16
    return numpy.int32(0)
   if (_0=="bas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1633:6-16
    return numpy.int32(1)
   if (_0=="supbas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1634:6-19
    return numpy.int32(2)
   if (_0=="low"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1635:6-16
    return numpy.int32(3)
   if (_0=="upr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1636:6-16
    return numpy.int32(4)
   if (_0=="fix"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1637:6-16
    return numpy.int32(5)
   if (_0=="inf"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1638:6-16
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1sparam_1value_S(_0)
  @staticmethod
  def __string_1to_1sparam_1value_S(_0):
   if (_0=="dataFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1604:6-25
    return numpy.int32(1)
   if (_0=="paramReadFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1605:6-30
    return numpy.int32(7)
   if (_0=="paramWriteFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1606:6-31
    return numpy.int32(8)
   if (_0=="paramCommentSign"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1607:6-29
    return numpy.int32(6)
   if (_0=="debugFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1608:6-26
    return numpy.int32(2)
   if (_0=="basSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1609:6-27
    return numpy.int32(0)
   if (_0=="itrSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1610:6-27
    return numpy.int32(4)
   if (_0=="intSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1611:6-27
    return numpy.int32(3)
   if (_0=="solFilterXcLow"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1612:6-27
    return numpy.int32(16)
   if (_0=="solFilterXcUpr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1613:6-27
    return numpy.int32(17)
   if (_0=="solFilterXxLow"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1614:6-27
    return numpy.int32(18)
   if (_0=="solFilterXxUpr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1615:6-27
    return numpy.int32(19)
   if (_0=="readMpsObjName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1616:6-27
    return numpy.int32(10)
   if (_0=="readMpsRanName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1617:6-27
    return numpy.int32(11)
   if (_0=="readMpsRhsName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1618:6-27
    return numpy.int32(12)
   if (_0=="readMpsBouName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1619:6-27
    return numpy.int32(9)
   if (_0=="statFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1620:6-25
    return numpy.int32(20)
   if (_0=="statName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1621:6-21
    return numpy.int32(22)
   if (_0=="statKey"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1622:6-20
    return numpy.int32(21)
   if (_0=="writeLpGenVarName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1623:6-30
    return numpy.int32(23)
   if (_0=="sensitivityResFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1624:6-35
    return numpy.int32(15)
   if (_0=="sensitivityFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1625:6-32
    return numpy.int32(14)
   if (_0=="mioDebugString"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1626:6-27
    return numpy.int32(5)
   if (_0=="remoteAccessToken"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1627:6-30
    return numpy.int32(13)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solveform_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solveform_1value_S(_0)
  @staticmethod
  def __string_1to_1solveform_1value_S(_0):
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1597:6-17
    return numpy.int32(0)
   if (_0=="primal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1598:6-19
    return numpy.int32(1)
   if (_0=="dual"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1599:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1soltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1soltype_1value_S(_0)
  @staticmethod
  def __string_1to_1soltype_1value_S(_0):
   if (_0=="bas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1590:6-16
    return numpy.int32(1)
   if (_0=="itr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1591:6-16
    return numpy.int32(0)
   if (_0=="itg"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1592:6-16
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solsta_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solsta_1value_S(_0)
  @staticmethod
  def __string_1to_1solsta_1value_S(_0):
   if (_0=="unknown"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1576:6-20
    return numpy.int32(0)
   if (_0=="optimal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1577:6-20
    return numpy.int32(1)
   if (_0=="primFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1578:6-21
    return numpy.int32(2)
   if (_0=="dualFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1579:6-21
    return numpy.int32(3)
   if (_0=="primAndDualFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1580:6-28
    return numpy.int32(4)
   if (_0=="primInfeasCer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1581:6-26
    return numpy.int32(5)
   if (_0=="dualInfeasCer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1582:6-26
    return numpy.int32(6)
   if (_0=="primIllposedCer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1583:6-28
    return numpy.int32(7)
   if (_0=="dualIllposedCer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1584:6-28
    return numpy.int32(8)
   if (_0=="integerOptimal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1585:6-27
    return numpy.int32(9)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solitem_1value_S(_0)
  @staticmethod
  def __string_1to_1solitem_1value_S(_0):
   if (_0=="xc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1564:6-15
    return numpy.int32(0)
   if (_0=="xx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1565:6-15
    return numpy.int32(1)
   if (_0=="y"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1566:6-14
    return numpy.int32(2)
   if (_0=="slc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1567:6-16
    return numpy.int32(3)
   if (_0=="suc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1568:6-16
    return numpy.int32(4)
   if (_0=="slx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1569:6-16
    return numpy.int32(5)
   if (_0=="sux"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1570:6-16
    return numpy.int32(6)
   if (_0=="snx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1571:6-16
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simseltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simseltype_1value_S(_0)
  @staticmethod
  def __string_1to_1simseltype_1value_S(_0):
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1554:6-17
    return numpy.int32(0)
   if (_0=="full"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1555:6-17
    return numpy.int32(1)
   if (_0=="ase"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1556:6-16
    return numpy.int32(2)
   if (_0=="devex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1557:6-18
    return numpy.int32(3)
   if (_0=="se"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1558:6-15
    return numpy.int32(4)
   if (_0=="partial"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1559:6-20
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sensitivitytype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1sensitivitytype_1value_S(_0)
  @staticmethod
  def __string_1to_1sensitivitytype_1value_S(_0):
   if (_0=="basis"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1549:6-18
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingmethod_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scalingmethod_1value_S(_0)
  @staticmethod
  def __string_1to_1scalingmethod_1value_S(_0):
   if (_0=="pow2"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1543:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1544:6-17
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scalingtype_1value_S(_0)
  @staticmethod
  def __string_1to_1scalingtype_1value_S(_0):
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1535:6-17
    return numpy.int32(0)
   if (_0=="none"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1536:6-17
    return numpy.int32(1)
   if (_0=="moderate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1537:6-21
    return numpy.int32(2)
   if (_0=="aggressive"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1538:6-23
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescodetype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1rescodetype_1value_S(_0)
  @staticmethod
  def __string_1to_1rescodetype_1value_S(_0):
   if (_0=="ok"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1526:6-15
    return numpy.int32(0)
   if (_0=="wrn"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1527:6-16
    return numpy.int32(1)
   if (_0=="trm"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1528:6-16
    return numpy.int32(2)
   if (_0=="err"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1529:6-16
    return numpy.int32(3)
   if (_0=="unk"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1530:6-16
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1rescode_1value_S(_0)
  @staticmethod
  def __string_1to_1rescode_1value_S(_0):
   if (_0=="ok"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1065:6-15
    return numpy.int32(0)
   if (_0=="wrnOpenParamFile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1066:6-29
    return numpy.int32(50)
   if (_0=="wrnLargeBound"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1067:6-26
    return numpy.int32(51)
   if (_0=="wrnLargeLoBound"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1068:6-28
    return numpy.int32(52)
   if (_0=="wrnLargeUpBound"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1069:6-28
    return numpy.int32(53)
   if (_0=="wrnLargeConFx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1070:6-26
    return numpy.int32(54)
   if (_0=="wrnLargeCj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1071:6-23
    return numpy.int32(57)
   if (_0=="wrnLargeAij"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1072:6-24
    return numpy.int32(62)
   if (_0=="wrnZeroAij"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1073:6-23
    return numpy.int32(63)
   if (_0=="wrnNameMaxLen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1074:6-26
    return numpy.int32(65)
   if (_0=="wrnSparMaxLen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1075:6-26
    return numpy.int32(66)
   if (_0=="wrnMpsSplitRhsVector"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1076:6-33
    return numpy.int32(70)
   if (_0=="wrnMpsSplitRanVector"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1077:6-33
    return numpy.int32(71)
   if (_0=="wrnMpsSplitBouVector"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1078:6-33
    return numpy.int32(72)
   if (_0=="wrnLpOldQuadFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1079:6-31
    return numpy.int32(80)
   if (_0=="wrnLpDropVariable"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1080:6-30
    return numpy.int32(85)
   if (_0=="wrnNzInUprTri"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1081:6-26
    return numpy.int32(200)
   if (_0=="wrnDroppedNzQobj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1082:6-29
    return numpy.int32(201)
   if (_0=="wrnIgnoreInteger"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1083:6-29
    return numpy.int32(250)
   if (_0=="wrnNoGlobalOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1084:6-33
    return numpy.int32(251)
   if (_0=="wrnMioInfeasibleFinal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1085:6-34
    return numpy.int32(270)
   if (_0=="wrnSolFilter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1086:6-25
    return numpy.int32(300)
   if (_0=="wrnUndefSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1087:6-32
    return numpy.int32(350)
   if (_0=="wrnSolFileIgnoredCon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1088:6-33
    return numpy.int32(351)
   if (_0=="wrnSolFileIgnoredVar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1089:6-33
    return numpy.int32(352)
   if (_0=="wrnTooFewBasisVars"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1090:6-31
    return numpy.int32(400)
   if (_0=="wrnTooManyBasisVars"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1091:6-32
    return numpy.int32(405)
   if (_0=="wrnLicenseExpire"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1092:6-29
    return numpy.int32(500)
   if (_0=="wrnLicenseServer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1093:6-29
    return numpy.int32(501)
   if (_0=="wrnEmptyName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1094:6-25
    return numpy.int32(502)
   if (_0=="wrnUsingGenericNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1095:6-33
    return numpy.int32(503)
   if (_0=="wrnLicenseFeatureExpire"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1096:6-36
    return numpy.int32(505)
   if (_0=="wrnParamNameDou"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1097:6-28
    return numpy.int32(510)
   if (_0=="wrnParamNameInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1098:6-28
    return numpy.int32(511)
   if (_0=="wrnParamNameStr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1099:6-28
    return numpy.int32(512)
   if (_0=="wrnParamStrValue"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1100:6-29
    return numpy.int32(515)
   if (_0=="wrnParamIgnoredCmio"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1101:6-32
    return numpy.int32(516)
   if (_0=="wrnZerosInSparseRow"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1102:6-32
    return numpy.int32(705)
   if (_0=="wrnZerosInSparseCol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1103:6-32
    return numpy.int32(710)
   if (_0=="wrnIncompleteLinearDependencyCheck"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1104:6-47
    return numpy.int32(800)
   if (_0=="wrnEliminatorSpace"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1105:6-31
    return numpy.int32(801)
   if (_0=="wrnPresolveOutofspace"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1106:6-34
    return numpy.int32(802)
   if (_0=="wrnWriteChangedNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1107:6-33
    return numpy.int32(803)
   if (_0=="wrnWriteDiscardedCfix"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1108:6-34
    return numpy.int32(804)
   if (_0=="wrnDuplicateConstraintNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1109:6-40
    return numpy.int32(850)
   if (_0=="wrnDuplicateVariableNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1110:6-38
    return numpy.int32(851)
   if (_0=="wrnDuplicateBarvariableNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1111:6-41
    return numpy.int32(852)
   if (_0=="wrnDuplicateConeNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1112:6-34
    return numpy.int32(853)
   if (_0=="wrnAnaLargeBounds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1113:6-30
    return numpy.int32(900)
   if (_0=="wrnAnaCZero"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1114:6-24
    return numpy.int32(901)
   if (_0=="wrnAnaEmptyCols"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1115:6-28
    return numpy.int32(902)
   if (_0=="wrnAnaCloseBounds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1116:6-30
    return numpy.int32(903)
   if (_0=="wrnAnaAlmostIntBounds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1117:6-34
    return numpy.int32(904)
   if (_0=="wrnQuadConesWithRootFixedAtZero"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1118:6-44
    return numpy.int32(930)
   if (_0=="wrnRquadConesWithRootFixedAtZero"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1119:6-45
    return numpy.int32(931)
   if (_0=="wrnExpConesWithVariablesFixedAtZero"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1120:6-48
    return numpy.int32(932)
   if (_0=="wrnPowConesWithRootFixedAtZero"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1121:6-43
    return numpy.int32(933)
   if (_0=="wrnNoDualizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1122:6-26
    return numpy.int32(950)
   if (_0=="wrnSymMatLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1123:6-27
    return numpy.int32(960)
   if (_0=="errLicense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1124:6-23
    return numpy.int32(1000)
   if (_0=="errLicenseExpired"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1125:6-30
    return numpy.int32(1001)
   if (_0=="errLicenseVersion"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1126:6-30
    return numpy.int32(1002)
   if (_0=="errSizeLicense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1127:6-27
    return numpy.int32(1005)
   if (_0=="errProbLicense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1128:6-27
    return numpy.int32(1006)
   if (_0=="errFileLicense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1129:6-27
    return numpy.int32(1007)
   if (_0=="errMissingLicenseFile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1130:6-34
    return numpy.int32(1008)
   if (_0=="errSizeLicenseCon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1131:6-30
    return numpy.int32(1010)
   if (_0=="errSizeLicenseVar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1132:6-30
    return numpy.int32(1011)
   if (_0=="errSizeLicenseIntvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1133:6-33
    return numpy.int32(1012)
   if (_0=="errOptimizerLicense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1134:6-32
    return numpy.int32(1013)
   if (_0=="errFlexlm"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1135:6-22
    return numpy.int32(1014)
   if (_0=="errLicenseServer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1136:6-29
    return numpy.int32(1015)
   if (_0=="errLicenseMax"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1137:6-26
    return numpy.int32(1016)
   if (_0=="errLicenseMoseklmDaemon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1138:6-36
    return numpy.int32(1017)
   if (_0=="errLicenseFeature"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1139:6-30
    return numpy.int32(1018)
   if (_0=="errPlatformNotLicensed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1140:6-35
    return numpy.int32(1019)
   if (_0=="errLicenseCannotAllocate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1141:6-37
    return numpy.int32(1020)
   if (_0=="errLicenseCannotConnect"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1142:6-36
    return numpy.int32(1021)
   if (_0=="errLicenseInvalidHostid"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1143:6-36
    return numpy.int32(1025)
   if (_0=="errLicenseServerVersion"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1144:6-36
    return numpy.int32(1026)
   if (_0=="errLicenseNoServerSupport"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1145:6-38
    return numpy.int32(1027)
   if (_0=="errLicenseNoServerLine"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1146:6-35
    return numpy.int32(1028)
   if (_0=="errOlderDll"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1147:6-24
    return numpy.int32(1035)
   if (_0=="errNewerDll"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1148:6-24
    return numpy.int32(1036)
   if (_0=="errLinkFileDll"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1149:6-27
    return numpy.int32(1040)
   if (_0=="errThreadMutexInit"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1150:6-31
    return numpy.int32(1045)
   if (_0=="errThreadMutexLock"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1151:6-31
    return numpy.int32(1046)
   if (_0=="errThreadMutexUnlock"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1152:6-33
    return numpy.int32(1047)
   if (_0=="errThreadCreate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1153:6-28
    return numpy.int32(1048)
   if (_0=="errThreadCondInit"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1154:6-30
    return numpy.int32(1049)
   if (_0=="errUnknown"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1155:6-23
    return numpy.int32(1050)
   if (_0=="errSpace"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1156:6-21
    return numpy.int32(1051)
   if (_0=="errFileOpen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1157:6-24
    return numpy.int32(1052)
   if (_0=="errFileRead"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1158:6-24
    return numpy.int32(1053)
   if (_0=="errFileWrite"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1159:6-25
    return numpy.int32(1054)
   if (_0=="errDataFileExt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1160:6-27
    return numpy.int32(1055)
   if (_0=="errInvalidFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1161:6-31
    return numpy.int32(1056)
   if (_0=="errInvalidSolFileName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1162:6-34
    return numpy.int32(1057)
   if (_0=="errEndOfFile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1163:6-25
    return numpy.int32(1059)
   if (_0=="errNullEnv"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1164:6-23
    return numpy.int32(1060)
   if (_0=="errNullTask"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1165:6-24
    return numpy.int32(1061)
   if (_0=="errInvalidStream"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1166:6-29
    return numpy.int32(1062)
   if (_0=="errNoInitEnv"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1167:6-25
    return numpy.int32(1063)
   if (_0=="errInvalidTask"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1168:6-27
    return numpy.int32(1064)
   if (_0=="errNullPointer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1169:6-27
    return numpy.int32(1065)
   if (_0=="errLivingTasks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1170:6-27
    return numpy.int32(1066)
   if (_0=="errBlankName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1171:6-25
    return numpy.int32(1070)
   if (_0=="errDupName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1172:6-23
    return numpy.int32(1071)
   if (_0=="errFormatString"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1173:6-28
    return numpy.int32(1072)
   if (_0=="errInvalidObjName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1174:6-30
    return numpy.int32(1075)
   if (_0=="errInvalidConName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1175:6-30
    return numpy.int32(1076)
   if (_0=="errInvalidVarName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1176:6-30
    return numpy.int32(1077)
   if (_0=="errInvalidConeName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1177:6-31
    return numpy.int32(1078)
   if (_0=="errInvalidBarvarName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1178:6-33
    return numpy.int32(1079)
   if (_0=="errSpaceLeaking"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1179:6-28
    return numpy.int32(1080)
   if (_0=="errSpaceNoInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1180:6-27
    return numpy.int32(1081)
   if (_0=="errReadFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1181:6-26
    return numpy.int32(1090)
   if (_0=="errMpsFile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1182:6-23
    return numpy.int32(1100)
   if (_0=="errMpsInvField"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1183:6-27
    return numpy.int32(1101)
   if (_0=="errMpsInvMarker"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1184:6-28
    return numpy.int32(1102)
   if (_0=="errMpsNullConName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1185:6-30
    return numpy.int32(1103)
   if (_0=="errMpsNullVarName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1186:6-30
    return numpy.int32(1104)
   if (_0=="errMpsUndefConName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1187:6-31
    return numpy.int32(1105)
   if (_0=="errMpsUndefVarName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1188:6-31
    return numpy.int32(1106)
   if (_0=="errMpsInvConKey"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1189:6-28
    return numpy.int32(1107)
   if (_0=="errMpsInvBoundKey"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1190:6-30
    return numpy.int32(1108)
   if (_0=="errMpsInvSecName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1191:6-29
    return numpy.int32(1109)
   if (_0=="errMpsNoObjective"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1192:6-30
    return numpy.int32(1110)
   if (_0=="errMpsSplittedVar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1193:6-30
    return numpy.int32(1111)
   if (_0=="errMpsMulConName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1194:6-29
    return numpy.int32(1112)
   if (_0=="errMpsMulQsec"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1195:6-26
    return numpy.int32(1113)
   if (_0=="errMpsMulQobj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1196:6-26
    return numpy.int32(1114)
   if (_0=="errMpsInvSecOrder"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1197:6-30
    return numpy.int32(1115)
   if (_0=="errMpsMulCsec"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1198:6-26
    return numpy.int32(1116)
   if (_0=="errMpsConeType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1199:6-27
    return numpy.int32(1117)
   if (_0=="errMpsConeOverlap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1200:6-30
    return numpy.int32(1118)
   if (_0=="errMpsConeRepeat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1201:6-29
    return numpy.int32(1119)
   if (_0=="errMpsNonSymmetricQ"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1202:6-32
    return numpy.int32(1120)
   if (_0=="errMpsDuplicateQElement"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1203:6-36
    return numpy.int32(1121)
   if (_0=="errMpsInvalidObjsense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1204:6-34
    return numpy.int32(1122)
   if (_0=="errMpsTabInField2"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1205:6-30
    return numpy.int32(1125)
   if (_0=="errMpsTabInField3"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1206:6-30
    return numpy.int32(1126)
   if (_0=="errMpsTabInField5"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1207:6-30
    return numpy.int32(1127)
   if (_0=="errMpsInvalidObjName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1208:6-33
    return numpy.int32(1128)
   if (_0=="errLpIncompatible"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1209:6-30
    return numpy.int32(1150)
   if (_0=="errLpEmpty"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1210:6-23
    return numpy.int32(1151)
   if (_0=="errLpDupSlackName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1211:6-30
    return numpy.int32(1152)
   if (_0=="errWriteMpsInvalidName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1212:6-35
    return numpy.int32(1153)
   if (_0=="errLpInvalidVarName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1213:6-32
    return numpy.int32(1154)
   if (_0=="errLpFreeConstraint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1214:6-32
    return numpy.int32(1155)
   if (_0=="errWriteOpfInvalidVarName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1215:6-38
    return numpy.int32(1156)
   if (_0=="errLpFileFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1216:6-28
    return numpy.int32(1157)
   if (_0=="errWriteLpFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1217:6-29
    return numpy.int32(1158)
   if (_0=="errReadLpMissingEndTag"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1218:6-35
    return numpy.int32(1159)
   if (_0=="errLpFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1219:6-24
    return numpy.int32(1160)
   if (_0=="errWriteLpNonUniqueName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1220:6-36
    return numpy.int32(1161)
   if (_0=="errReadLpNonexistingName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1221:6-37
    return numpy.int32(1162)
   if (_0=="errLpWriteConicProblem"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1222:6-35
    return numpy.int32(1163)
   if (_0=="errLpWriteGecoProblem"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1223:6-34
    return numpy.int32(1164)
   if (_0=="errWritingFile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1224:6-27
    return numpy.int32(1166)
   if (_0=="errPtfFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1225:6-25
    return numpy.int32(1167)
   if (_0=="errOpfFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1226:6-25
    return numpy.int32(1168)
   if (_0=="errOpfNewVariable"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1227:6-30
    return numpy.int32(1169)
   if (_0=="errInvalidNameInSolFile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1228:6-36
    return numpy.int32(1170)
   if (_0=="errLpInvalidConName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1229:6-32
    return numpy.int32(1171)
   if (_0=="errOpfPrematureEof"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1230:6-31
    return numpy.int32(1172)
   if (_0=="errJsonSyntax"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1231:6-26
    return numpy.int32(1175)
   if (_0=="errJsonString"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1232:6-26
    return numpy.int32(1176)
   if (_0=="errJsonNumberOverflow"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1233:6-34
    return numpy.int32(1177)
   if (_0=="errJsonFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1234:6-26
    return numpy.int32(1178)
   if (_0=="errJsonData"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1235:6-24
    return numpy.int32(1179)
   if (_0=="errJsonMissingData"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1236:6-31
    return numpy.int32(1180)
   if (_0=="errArgumentLenneq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1237:6-30
    return numpy.int32(1197)
   if (_0=="errArgumentType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1238:6-28
    return numpy.int32(1198)
   if (_0=="errNumArguments"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1239:6-28
    return numpy.int32(1199)
   if (_0=="errInArgument"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1240:6-26
    return numpy.int32(1200)
   if (_0=="errArgumentDimension"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1241:6-33
    return numpy.int32(1201)
   if (_0=="errShapeIsTooLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1242:6-31
    return numpy.int32(1202)
   if (_0=="errIndexIsTooSmall"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1243:6-31
    return numpy.int32(1203)
   if (_0=="errIndexIsTooLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1244:6-31
    return numpy.int32(1204)
   if (_0=="errParamName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1245:6-25
    return numpy.int32(1205)
   if (_0=="errParamNameDou"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1246:6-28
    return numpy.int32(1206)
   if (_0=="errParamNameInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1247:6-28
    return numpy.int32(1207)
   if (_0=="errParamNameStr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1248:6-28
    return numpy.int32(1208)
   if (_0=="errParamIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1249:6-26
    return numpy.int32(1210)
   if (_0=="errParamIsTooLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1250:6-31
    return numpy.int32(1215)
   if (_0=="errParamIsTooSmall"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1251:6-31
    return numpy.int32(1216)
   if (_0=="errParamValueStr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1252:6-29
    return numpy.int32(1217)
   if (_0=="errParamType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1253:6-25
    return numpy.int32(1218)
   if (_0=="errInfDouIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1254:6-27
    return numpy.int32(1219)
   if (_0=="errInfIntIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1255:6-27
    return numpy.int32(1220)
   if (_0=="errIndexArrIsTooSmall"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1256:6-34
    return numpy.int32(1221)
   if (_0=="errIndexArrIsTooLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1257:6-34
    return numpy.int32(1222)
   if (_0=="errInfLintIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1258:6-28
    return numpy.int32(1225)
   if (_0=="errArgIsTooSmall"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1259:6-29
    return numpy.int32(1226)
   if (_0=="errArgIsTooLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1260:6-29
    return numpy.int32(1227)
   if (_0=="errInvalidWhichsol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1261:6-31
    return numpy.int32(1228)
   if (_0=="errInfDouName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1262:6-26
    return numpy.int32(1230)
   if (_0=="errInfIntName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1263:6-26
    return numpy.int32(1231)
   if (_0=="errInfType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1264:6-23
    return numpy.int32(1232)
   if (_0=="errInfLintName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1265:6-27
    return numpy.int32(1234)
   if (_0=="errIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1266:6-21
    return numpy.int32(1235)
   if (_0=="errWhichsol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1267:6-24
    return numpy.int32(1236)
   if (_0=="errSolitem"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1268:6-23
    return numpy.int32(1237)
   if (_0=="errWhichitemNotAllowed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1269:6-35
    return numpy.int32(1238)
   if (_0=="errMaxnumcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1270:6-25
    return numpy.int32(1240)
   if (_0=="errMaxnumvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1271:6-25
    return numpy.int32(1241)
   if (_0=="errMaxnumbarvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1272:6-28
    return numpy.int32(1242)
   if (_0=="errMaxnumqnz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1273:6-25
    return numpy.int32(1243)
   if (_0=="errTooSmallMaxNumNz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1274:6-32
    return numpy.int32(1245)
   if (_0=="errInvalidIdx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1275:6-26
    return numpy.int32(1246)
   if (_0=="errInvalidMaxNum"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1276:6-29
    return numpy.int32(1247)
   if (_0=="errNumconlim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1277:6-25
    return numpy.int32(1250)
   if (_0=="errNumvarlim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1278:6-25
    return numpy.int32(1251)
   if (_0=="errTooSmallMaxnumanz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1279:6-33
    return numpy.int32(1252)
   if (_0=="errInvAptre"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1280:6-24
    return numpy.int32(1253)
   if (_0=="errMulAElement"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1281:6-27
    return numpy.int32(1254)
   if (_0=="errInvBk"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1282:6-21
    return numpy.int32(1255)
   if (_0=="errInvBkc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1283:6-22
    return numpy.int32(1256)
   if (_0=="errInvBkx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1284:6-22
    return numpy.int32(1257)
   if (_0=="errInvVarType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1285:6-26
    return numpy.int32(1258)
   if (_0=="errSolverProbtype"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1286:6-30
    return numpy.int32(1259)
   if (_0=="errObjectiveRange"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1287:6-30
    return numpy.int32(1260)
   if (_0=="errUndefSolution"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1288:6-29
    return numpy.int32(1265)
   if (_0=="errBasis"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1289:6-21
    return numpy.int32(1266)
   if (_0=="errInvSkc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1290:6-22
    return numpy.int32(1267)
   if (_0=="errInvSkx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1291:6-22
    return numpy.int32(1268)
   if (_0=="errInvSkn"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1292:6-22
    return numpy.int32(1274)
   if (_0=="errInvSkStr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1293:6-24
    return numpy.int32(1269)
   if (_0=="errInvSk"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1294:6-21
    return numpy.int32(1270)
   if (_0=="errInvConeTypeStr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1295:6-30
    return numpy.int32(1271)
   if (_0=="errInvConeType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1296:6-27
    return numpy.int32(1272)
   if (_0=="errInvalidSurplus"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1297:6-30
    return numpy.int32(1275)
   if (_0=="errInvNameItem"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1298:6-27
    return numpy.int32(1280)
   if (_0=="errProItem"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1299:6-23
    return numpy.int32(1281)
   if (_0=="errInvalidFormatType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1300:6-33
    return numpy.int32(1283)
   if (_0=="errFirsti"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1301:6-22
    return numpy.int32(1285)
   if (_0=="errLasti"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1302:6-21
    return numpy.int32(1286)
   if (_0=="errFirstj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1303:6-22
    return numpy.int32(1287)
   if (_0=="errLastj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1304:6-21
    return numpy.int32(1288)
   if (_0=="errMaxLenIsTooSmall"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1305:6-32
    return numpy.int32(1289)
   if (_0=="errNonlinearEquality"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1306:6-33
    return numpy.int32(1290)
   if (_0=="errNonconvex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1307:6-25
    return numpy.int32(1291)
   if (_0=="errNonlinearRanged"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1308:6-31
    return numpy.int32(1292)
   if (_0=="errConQNotPsd"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1309:6-26
    return numpy.int32(1293)
   if (_0=="errConQNotNsd"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1310:6-26
    return numpy.int32(1294)
   if (_0=="errObjQNotPsd"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1311:6-26
    return numpy.int32(1295)
   if (_0=="errObjQNotNsd"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1312:6-26
    return numpy.int32(1296)
   if (_0=="errArgumentPermArray"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1313:6-33
    return numpy.int32(1299)
   if (_0=="errConeIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1314:6-25
    return numpy.int32(1300)
   if (_0=="errConeSize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1315:6-24
    return numpy.int32(1301)
   if (_0=="errConeOverlap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1316:6-27
    return numpy.int32(1302)
   if (_0=="errConeRepVar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1317:6-26
    return numpy.int32(1303)
   if (_0=="errMaxnumcone"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1318:6-26
    return numpy.int32(1304)
   if (_0=="errConeType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1319:6-24
    return numpy.int32(1305)
   if (_0=="errConeTypeStr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1320:6-27
    return numpy.int32(1306)
   if (_0=="errConeOverlapAppend"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1321:6-33
    return numpy.int32(1307)
   if (_0=="errRemoveConeVariable"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1322:6-34
    return numpy.int32(1310)
   if (_0=="errAppendingTooBigCone"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1323:6-35
    return numpy.int32(1311)
   if (_0=="errConeParameter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1324:6-29
    return numpy.int32(1320)
   if (_0=="errSolFileInvalidNumber"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1325:6-36
    return numpy.int32(1350)
   if (_0=="errHugeC"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1326:6-21
    return numpy.int32(1375)
   if (_0=="errHugeAij"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1327:6-23
    return numpy.int32(1380)
   if (_0=="errDuplicateAij"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1328:6-28
    return numpy.int32(1385)
   if (_0=="errLowerBoundIsANan"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1329:6-32
    return numpy.int32(1390)
   if (_0=="errUpperBoundIsANan"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1330:6-32
    return numpy.int32(1391)
   if (_0=="errInfiniteBound"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1331:6-29
    return numpy.int32(1400)
   if (_0=="errInvQobjSubi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1332:6-27
    return numpy.int32(1401)
   if (_0=="errInvQobjSubj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1333:6-27
    return numpy.int32(1402)
   if (_0=="errInvQobjVal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1334:6-26
    return numpy.int32(1403)
   if (_0=="errInvQconSubk"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1335:6-27
    return numpy.int32(1404)
   if (_0=="errInvQconSubi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1336:6-27
    return numpy.int32(1405)
   if (_0=="errInvQconSubj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1337:6-27
    return numpy.int32(1406)
   if (_0=="errInvQconVal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1338:6-26
    return numpy.int32(1407)
   if (_0=="errQconSubiTooSmall"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1339:6-32
    return numpy.int32(1408)
   if (_0=="errQconSubiTooLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1340:6-32
    return numpy.int32(1409)
   if (_0=="errQobjUpperTriangle"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1341:6-33
    return numpy.int32(1415)
   if (_0=="errQconUpperTriangle"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1342:6-33
    return numpy.int32(1417)
   if (_0=="errFixedBoundValues"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1343:6-32
    return numpy.int32(1420)
   if (_0=="errTooSmallATruncationValue"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1344:6-40
    return numpy.int32(1421)
   if (_0=="errInvalidObjectiveSense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1345:6-37
    return numpy.int32(1445)
   if (_0=="errUndefinedObjectiveSense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1346:6-39
    return numpy.int32(1446)
   if (_0=="errYIsUndefined"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1347:6-28
    return numpy.int32(1449)
   if (_0=="errNanInDoubleData"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1348:6-31
    return numpy.int32(1450)
   if (_0=="errNanInBlc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1349:6-24
    return numpy.int32(1461)
   if (_0=="errNanInBuc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1350:6-24
    return numpy.int32(1462)
   if (_0=="errNanInC"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1351:6-22
    return numpy.int32(1470)
   if (_0=="errNanInBlx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1352:6-24
    return numpy.int32(1471)
   if (_0=="errNanInBux"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1353:6-24
    return numpy.int32(1472)
   if (_0=="errInvalidAij"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1354:6-26
    return numpy.int32(1473)
   if (_0=="errSymMatInvalid"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1355:6-29
    return numpy.int32(1480)
   if (_0=="errSymMatHuge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1356:6-26
    return numpy.int32(1482)
   if (_0=="errInvProblem"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1357:6-26
    return numpy.int32(1500)
   if (_0=="errMixedConicAndNl"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1358:6-31
    return numpy.int32(1501)
   if (_0=="errGlobalInvConicProblem"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1359:6-37
    return numpy.int32(1503)
   if (_0=="errInvOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1360:6-28
    return numpy.int32(1550)
   if (_0=="errMioNoOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1361:6-30
    return numpy.int32(1551)
   if (_0=="errNoOptimizerVarType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1362:6-34
    return numpy.int32(1552)
   if (_0=="errFinalSolution"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1363:6-29
    return numpy.int32(1560)
   if (_0=="errFirst"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1364:6-21
    return numpy.int32(1570)
   if (_0=="errLast"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1365:6-20
    return numpy.int32(1571)
   if (_0=="errSliceSize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1366:6-25
    return numpy.int32(1572)
   if (_0=="errNegativeSurplus"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1367:6-31
    return numpy.int32(1573)
   if (_0=="errNegativeAppend"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1368:6-30
    return numpy.int32(1578)
   if (_0=="errPostsolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1369:6-25
    return numpy.int32(1580)
   if (_0=="errOverflow"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1370:6-24
    return numpy.int32(1590)
   if (_0=="errNoBasisSol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1371:6-26
    return numpy.int32(1600)
   if (_0=="errBasisFactor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1372:6-27
    return numpy.int32(1610)
   if (_0=="errBasisSingular"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1373:6-29
    return numpy.int32(1615)
   if (_0=="errFactor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1374:6-22
    return numpy.int32(1650)
   if (_0=="errFeasrepairCannotRelax"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1375:6-37
    return numpy.int32(1700)
   if (_0=="errFeasrepairSolvingRelaxed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1376:6-40
    return numpy.int32(1701)
   if (_0=="errFeasrepairInconsistentBound"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1377:6-43
    return numpy.int32(1702)
   if (_0=="errRepairInvalidProblem"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1378:6-36
    return numpy.int32(1710)
   if (_0=="errRepairOptimizationFailed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1379:6-40
    return numpy.int32(1711)
   if (_0=="errNameMaxLen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1380:6-26
    return numpy.int32(1750)
   if (_0=="errNameIsNull"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1381:6-26
    return numpy.int32(1760)
   if (_0=="errInvalidCompression"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1382:6-34
    return numpy.int32(1800)
   if (_0=="errInvalidIomode"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1383:6-29
    return numpy.int32(1801)
   if (_0=="errNoPrimalInfeasCer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1384:6-33
    return numpy.int32(2000)
   if (_0=="errNoDualInfeasCer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1385:6-31
    return numpy.int32(2001)
   if (_0=="errNoSolutionInCallback"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1386:6-36
    return numpy.int32(2500)
   if (_0=="errInvMarki"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1387:6-24
    return numpy.int32(2501)
   if (_0=="errInvMarkj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1388:6-24
    return numpy.int32(2502)
   if (_0=="errInvNumi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1389:6-23
    return numpy.int32(2503)
   if (_0=="errInvNumj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1390:6-23
    return numpy.int32(2504)
   if (_0=="errTaskIncompatible"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1391:6-32
    return numpy.int32(2560)
   if (_0=="errTaskInvalid"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1392:6-27
    return numpy.int32(2561)
   if (_0=="errTaskWrite"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1393:6-25
    return numpy.int32(2562)
   if (_0=="errLuMaxNumTries"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1394:6-29
    return numpy.int32(2800)
   if (_0=="errInvalidUtf8"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1395:6-27
    return numpy.int32(2900)
   if (_0=="errInvalidWchar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1396:6-28
    return numpy.int32(2901)
   if (_0=="errNoDualForItgSol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1397:6-31
    return numpy.int32(2950)
   if (_0=="errNoSnxForBasSol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1398:6-30
    return numpy.int32(2953)
   if (_0=="errInternal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1399:6-24
    return numpy.int32(3000)
   if (_0=="errApiArrayTooSmall"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1400:6-32
    return numpy.int32(3001)
   if (_0=="errApiCbConnect"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1401:6-28
    return numpy.int32(3002)
   if (_0=="errApiFatalError"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1402:6-29
    return numpy.int32(3005)
   if (_0=="errApiInternal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1403:6-27
    return numpy.int32(3999)
   if (_0=="errSenFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1404:6-25
    return numpy.int32(3050)
   if (_0=="errSenUndefName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1405:6-28
    return numpy.int32(3051)
   if (_0=="errSenIndexRange"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1406:6-29
    return numpy.int32(3052)
   if (_0=="errSenBoundInvalidUp"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1407:6-33
    return numpy.int32(3053)
   if (_0=="errSenBoundInvalidLo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1408:6-33
    return numpy.int32(3054)
   if (_0=="errSenIndexInvalid"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1409:6-31
    return numpy.int32(3055)
   if (_0=="errSenInvalidRegexp"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1410:6-32
    return numpy.int32(3056)
   if (_0=="errSenSolutionStatus"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1411:6-33
    return numpy.int32(3057)
   if (_0=="errSenNumerical"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1412:6-28
    return numpy.int32(3058)
   if (_0=="errSenUnhandledProblemType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1413:6-39
    return numpy.int32(3080)
   if (_0=="errUnbStepSize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1414:6-27
    return numpy.int32(3100)
   if (_0=="errIdenticalTasks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1415:6-30
    return numpy.int32(3101)
   if (_0=="errAdInvalidCodelist"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1416:6-33
    return numpy.int32(3102)
   if (_0=="errInternalTestFailed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1417:6-34
    return numpy.int32(3500)
   if (_0=="errXmlInvalidProblemType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1418:6-37
    return numpy.int32(3600)
   if (_0=="errInvalidAmplStub"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1419:6-31
    return numpy.int32(3700)
   if (_0=="errInt64ToInt32Cast"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1420:6-32
    return numpy.int32(3800)
   if (_0=="errSizeLicenseNumcores"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1421:6-35
    return numpy.int32(3900)
   if (_0=="errInfeasUndefined"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1422:6-31
    return numpy.int32(3910)
   if (_0=="errNoBarxForSolution"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1423:6-33
    return numpy.int32(3915)
   if (_0=="errNoBarsForSolution"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1424:6-33
    return numpy.int32(3916)
   if (_0=="errBarVarDim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1425:6-25
    return numpy.int32(3920)
   if (_0=="errSymMatInvalidRowIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1426:6-37
    return numpy.int32(3940)
   if (_0=="errSymMatInvalidColIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1427:6-37
    return numpy.int32(3941)
   if (_0=="errSymMatNotLowerTringular"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1428:6-39
    return numpy.int32(3942)
   if (_0=="errSymMatInvalidValue"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1429:6-34
    return numpy.int32(3943)
   if (_0=="errSymMatDuplicate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1430:6-31
    return numpy.int32(3944)
   if (_0=="errInvalidSymMatDim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1431:6-32
    return numpy.int32(3950)
   if (_0=="errInvalidFileFormatForSymMat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1432:6-42
    return numpy.int32(4000)
   if (_0=="errInvalidFileFormatForCfix"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1433:6-40
    return numpy.int32(4001)
   if (_0=="errInvalidFileFormatForRangedConstraints"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1434:6-53
    return numpy.int32(4002)
   if (_0=="errInvalidFileFormatForFreeConstraints"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1435:6-51
    return numpy.int32(4003)
   if (_0=="errInvalidFileFormatForCones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1436:6-41
    return numpy.int32(4005)
   if (_0=="errInvalidFileFormatForNonlinear"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1437:6-45
    return numpy.int32(4010)
   if (_0=="errDuplicateConstraintNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1438:6-40
    return numpy.int32(4500)
   if (_0=="errDuplicateVariableNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1439:6-38
    return numpy.int32(4501)
   if (_0=="errDuplicateBarvariableNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1440:6-41
    return numpy.int32(4502)
   if (_0=="errDuplicateConeNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1441:6-34
    return numpy.int32(4503)
   if (_0=="errNonUniqueArray"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1442:6-30
    return numpy.int32(5000)
   if (_0=="errArgumentIsTooLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1443:6-34
    return numpy.int32(5005)
   if (_0=="errMioInternal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1444:6-27
    return numpy.int32(5010)
   if (_0=="errInvalidProblemType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1445:6-34
    return numpy.int32(6000)
   if (_0=="errUnhandledSolutionStatus"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1446:6-39
    return numpy.int32(6010)
   if (_0=="errUpperTriangle"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1447:6-29
    return numpy.int32(6020)
   if (_0=="errLauSingularMatrix"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1448:6-33
    return numpy.int32(7000)
   if (_0=="errLauNotPositiveDefinite"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1449:6-38
    return numpy.int32(7001)
   if (_0=="errLauInvalidLowerTriangularMatrix"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1450:6-47
    return numpy.int32(7002)
   if (_0=="errLauUnknown"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1451:6-26
    return numpy.int32(7005)
   if (_0=="errLauArgM"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1452:6-23
    return numpy.int32(7010)
   if (_0=="errLauArgN"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1453:6-23
    return numpy.int32(7011)
   if (_0=="errLauArgK"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1454:6-23
    return numpy.int32(7012)
   if (_0=="errLauArgTransa"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1455:6-28
    return numpy.int32(7015)
   if (_0=="errLauArgTransb"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1456:6-28
    return numpy.int32(7016)
   if (_0=="errLauArgUplo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1457:6-26
    return numpy.int32(7017)
   if (_0=="errLauArgTrans"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1458:6-27
    return numpy.int32(7018)
   if (_0=="errLauInvalidSparseSymmetricMatrix"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1459:6-47
    return numpy.int32(7019)
   if (_0=="errCbfParse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1460:6-24
    return numpy.int32(7100)
   if (_0=="errCbfObjSense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1461:6-27
    return numpy.int32(7101)
   if (_0=="errCbfNoVariables"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1462:6-30
    return numpy.int32(7102)
   if (_0=="errCbfTooManyConstraints"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1463:6-37
    return numpy.int32(7103)
   if (_0=="errCbfTooManyVariables"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1464:6-35
    return numpy.int32(7104)
   if (_0=="errCbfNoVersionSpecified"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1465:6-37
    return numpy.int32(7105)
   if (_0=="errCbfSyntax"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1466:6-25
    return numpy.int32(7106)
   if (_0=="errCbfDuplicateObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1467:6-31
    return numpy.int32(7107)
   if (_0=="errCbfDuplicateCon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1468:6-31
    return numpy.int32(7108)
   if (_0=="errCbfDuplicateVar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1469:6-31
    return numpy.int32(7109)
   if (_0=="errCbfDuplicateInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1470:6-31
    return numpy.int32(7110)
   if (_0=="errCbfInvalidVarType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1471:6-33
    return numpy.int32(7111)
   if (_0=="errCbfInvalidConType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1472:6-33
    return numpy.int32(7112)
   if (_0=="errCbfInvalidDomainDimension"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1473:6-41
    return numpy.int32(7113)
   if (_0=="errCbfDuplicateObjacoord"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1474:6-37
    return numpy.int32(7114)
   if (_0=="errCbfDuplicateBcoord"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1475:6-34
    return numpy.int32(7115)
   if (_0=="errCbfDuplicateAcoord"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1476:6-34
    return numpy.int32(7116)
   if (_0=="errCbfTooFewVariables"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1477:6-34
    return numpy.int32(7117)
   if (_0=="errCbfTooFewConstraints"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1478:6-36
    return numpy.int32(7118)
   if (_0=="errCbfTooFewInts"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1479:6-29
    return numpy.int32(7119)
   if (_0=="errCbfTooManyInts"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1480:6-30
    return numpy.int32(7120)
   if (_0=="errCbfInvalidIntIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1481:6-34
    return numpy.int32(7121)
   if (_0=="errCbfUnsupported"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1482:6-30
    return numpy.int32(7122)
   if (_0=="errCbfDuplicatePsdvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1483:6-34
    return numpy.int32(7123)
   if (_0=="errCbfInvalidPsdvarDimension"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1484:6-41
    return numpy.int32(7124)
   if (_0=="errCbfTooFewPsdvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1485:6-31
    return numpy.int32(7125)
   if (_0=="errCbfInvalidExpDimension"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1486:6-38
    return numpy.int32(7126)
   if (_0=="errCbfDuplicatePowCones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1487:6-36
    return numpy.int32(7130)
   if (_0=="errCbfDuplicatePowStarCones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1488:6-40
    return numpy.int32(7131)
   if (_0=="errCbfInvalidPower"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1489:6-31
    return numpy.int32(7132)
   if (_0=="errCbfPowerConeIsTooLong"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1490:6-37
    return numpy.int32(7133)
   if (_0=="errCbfInvalidPowerConeIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1491:6-40
    return numpy.int32(7134)
   if (_0=="errCbfInvalidPowerStarConeIndex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1492:6-44
    return numpy.int32(7135)
   if (_0=="errCbfUnhandledPowerConeType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1493:6-41
    return numpy.int32(7136)
   if (_0=="errCbfUnhandledPowerStarConeType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1494:6-45
    return numpy.int32(7137)
   if (_0=="errCbfPowerConeMismatch"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1495:6-36
    return numpy.int32(7138)
   if (_0=="errCbfPowerStarConeMismatch"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1496:6-40
    return numpy.int32(7139)
   if (_0=="errCbfInvalidNumberOfCones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1497:6-39
    return numpy.int32(7740)
   if (_0=="errCbfInvalidDimensionOfCones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1498:6-42
    return numpy.int32(7741)
   if (_0=="errMioInvalidRootOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1499:6-39
    return numpy.int32(7700)
   if (_0=="errMioInvalidNodeOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1500:6-39
    return numpy.int32(7701)
   if (_0=="errToconicConstrQNotPsd"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1501:6-36
    return numpy.int32(7800)
   if (_0=="errToconicConstraintFx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1502:6-35
    return numpy.int32(7801)
   if (_0=="errToconicConstraintRa"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1503:6-35
    return numpy.int32(7802)
   if (_0=="errToconicConstrNotConic"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1504:6-37
    return numpy.int32(7803)
   if (_0=="errToconicObjectiveNotPsd"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1505:6-38
    return numpy.int32(7804)
   if (_0=="errServerConnect"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1506:6-29
    return numpy.int32(8000)
   if (_0=="errServerProtocol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1507:6-30
    return numpy.int32(8001)
   if (_0=="errServerStatus"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1508:6-28
    return numpy.int32(8002)
   if (_0=="errServerToken"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1509:6-27
    return numpy.int32(8003)
   if (_0=="trmMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1510:6-29
    return numpy.int32(10000)
   if (_0=="trmMaxTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1511:6-23
    return numpy.int32(10001)
   if (_0=="trmObjectiveRange"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1512:6-30
    return numpy.int32(10002)
   if (_0=="trmMioNumRelaxs"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1513:6-28
    return numpy.int32(10008)
   if (_0=="trmMioNumBranches"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1514:6-30
    return numpy.int32(10009)
   if (_0=="trmNumMaxNumIntSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1515:6-37
    return numpy.int32(10015)
   if (_0=="trmStall"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1516:6-21
    return numpy.int32(10006)
   if (_0=="trmUserCallback"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1517:6-28
    return numpy.int32(10007)
   if (_0=="trmMaxNumSetbacks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1518:6-30
    return numpy.int32(10020)
   if (_0=="trmNumericalProblem"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1519:6-32
    return numpy.int32(10025)
   if (_0=="trmInternal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1520:6-24
    return numpy.int32(10030)
   if (_0=="trmInternalStop"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1521:6-28
    return numpy.int32(10031)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1xmlwriteroutputtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1xmlwriteroutputtype_1value_S(_0)
  @staticmethod
  def __string_1to_1xmlwriteroutputtype_1value_S(_0):
   if (_0=="row"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1059:6-16
    return numpy.int32(0)
   if (_0=="col"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1060:6-16
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1prosta_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1prosta_1value_S(_0)
  @staticmethod
  def __string_1to_1prosta_1value_S(_0):
   if (_0=="unknown"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1046:6-20
    return numpy.int32(0)
   if (_0=="primAndDualFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1047:6-28
    return numpy.int32(1)
   if (_0=="primFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1048:6-21
    return numpy.int32(2)
   if (_0=="dualFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1049:6-21
    return numpy.int32(3)
   if (_0=="primInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1050:6-23
    return numpy.int32(4)
   if (_0=="dualInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1051:6-23
    return numpy.int32(5)
   if (_0=="primAndDualInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1052:6-30
    return numpy.int32(6)
   if (_0=="illPosed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1053:6-21
    return numpy.int32(7)
   if (_0=="primInfeasOrUnbounded"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1054:6-34
    return numpy.int32(8)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1problemtype_1value_S(_0)
  @staticmethod
  def __string_1to_1problemtype_1value_S(_0):
   if (_0=="lo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1037:6-15
    return numpy.int32(0)
   if (_0=="qo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1038:6-15
    return numpy.int32(1)
   if (_0=="qcqo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1039:6-17
    return numpy.int32(2)
   if (_0=="conic"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1040:6-18
    return numpy.int32(3)
   if (_0=="mixed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1041:6-18
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1problemitem_1value_S(_0)
  @staticmethod
  def __string_1to_1problemitem_1value_S(_0):
   if (_0=="var"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1030:6-16
    return numpy.int32(0)
   if (_0=="con"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1031:6-16
    return numpy.int32(1)
   if (_0=="cone"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1032:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1parametertype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1parametertype_1value_S(_0)
  @staticmethod
  def __string_1to_1parametertype_1value_S(_0):
   if (_0=="invalidType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1022:6-24
    return numpy.int32(0)
   if (_0=="douType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1023:6-20
    return numpy.int32(1)
   if (_0=="intType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1024:6-20
    return numpy.int32(2)
   if (_0=="strType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1025:6-20
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1presolvemode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1presolvemode_1value_S(_0)
  @staticmethod
  def __string_1to_1presolvemode_1value_S(_0):
   if (_0=="off"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1015:6-16
    return numpy.int32(0)
   if (_0=="on"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1016:6-15
    return numpy.int32(1)
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1017:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1orderingtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1orderingtype_1value_S(_0)
  @staticmethod
  def __string_1to_1orderingtype_1value_S(_0):
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1005:6-17
    return numpy.int32(0)
   if (_0=="appminloc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1006:6-22
    return numpy.int32(1)
   if (_0=="experimental"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1007:6-25
    return numpy.int32(2)
   if (_0=="tryGraphpar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1008:6-24
    return numpy.int32(3)
   if (_0=="forceGraphpar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1009:6-26
    return numpy.int32(4)
   if (_0=="none"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1010:6-17
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1optimizertype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1optimizertype_1value_S(_0)
  @staticmethod
  def __string_1to_1optimizertype_1value_S(_0):
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:994:6-17
    return numpy.int32(2)
   if (_0=="intpnt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:995:6-19
    return numpy.int32(4)
   if (_0=="conic"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:996:6-18
    return numpy.int32(0)
   if (_0=="primalSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:997:6-26
    return numpy.int32(6)
   if (_0=="dualSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:998:6-24
    return numpy.int32(1)
   if (_0=="freeSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:999:6-24
    return numpy.int32(3)
   if (_0=="mixedInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:1000:6-21
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1onoffkey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1onoffkey_1value_S(_0)
  @staticmethod
  def __string_1to_1onoffkey_1value_S(_0):
   if (_0=="on"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:988:6-15
    return numpy.int32(1)
   if (_0=="off"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:989:6-16
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1objsense_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1objsense_1value_S(_0)
  @staticmethod
  def __string_1to_1objsense_1value_S(_0):
   if (_0=="minimize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:982:6-21
    return numpy.int32(0)
   if (_0=="maximize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:983:6-21
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mpsformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mpsformat_1value_S(_0)
  @staticmethod
  def __string_1to_1mpsformat_1value_S(_0):
   if (_0=="strict"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:974:6-19
    return numpy.int32(0)
   if (_0=="relaxed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:975:6-20
    return numpy.int32(1)
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:976:6-17
    return numpy.int32(2)
   if (_0=="cplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:977:6-18
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mionodeseltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mionodeseltype_1value_S(_0)
  @staticmethod
  def __string_1to_1mionodeseltype_1value_S(_0):
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:966:6-17
    return numpy.int32(0)
   if (_0=="first"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:967:6-18
    return numpy.int32(1)
   if (_0=="best"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:968:6-17
    return numpy.int32(2)
   if (_0=="pseudo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:969:6-19
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miomode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miomode_1value_S(_0)
  @staticmethod
  def __string_1to_1miomode_1value_S(_0):
   if (_0=="ignored"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:960:6-20
    return numpy.int32(0)
   if (_0=="satisfied"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:961:6-22
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miocontsoltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miocontsoltype_1value_S(_0)
  @staticmethod
  def __string_1to_1miocontsoltype_1value_S(_0):
   if (_0=="none"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:952:6-17
    return numpy.int32(0)
   if (_0=="root"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:953:6-17
    return numpy.int32(1)
   if (_0=="itg"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:954:6-16
    return numpy.int32(2)
   if (_0=="itgRel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:955:6-19
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1branchdir_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1branchdir_1value_S(_0)
  @staticmethod
  def __string_1to_1branchdir_1value_S(_0):
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:940:6-17
    return numpy.int32(0)
   if (_0=="up"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:941:6-15
    return numpy.int32(1)
   if (_0=="down"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:942:6-17
    return numpy.int32(2)
   if (_0=="near"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:943:6-17
    return numpy.int32(3)
   if (_0=="far"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:944:6-16
    return numpy.int32(4)
   if (_0=="rootLp"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:945:6-19
    return numpy.int32(5)
   if (_0=="guided"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:946:6-19
    return numpy.int32(6)
   if (_0=="pseudocost"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:947:6-23
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iparam_1value_S(_0)
  @staticmethod
  def __string_1to_1iparam_1value_S(_0):
   if (_0=="autoUpdateSolInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:756:6-30
    return numpy.int32(3)
   if (_0=="removeUnusedSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:757:6-34
    return numpy.int32(118)
   if (_0=="intpntHotstart"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:758:6-27
    return numpy.int32(18)
   if (_0=="intpntPurify"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:759:6-25
    return numpy.int32(26)
   if (_0=="numThreads"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:760:6-23
    return numpy.int32(87)
   if (_0=="intpntMultiThread"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:761:6-30
    return numpy.int32(22)
   if (_0=="timingLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:762:6-24
    return numpy.int32(152)
   if (_0=="mtSpincount"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:763:6-24
    return numpy.int32(86)
   if (_0=="maxNumWarnings"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:764:6-27
    return numpy.int32(60)
   if (_0=="optimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:765:6-22
    return numpy.int32(97)
   if (_0=="biMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:766:6-28
    return numpy.int32(8)
   if (_0=="licenseTrhExpiryWrn"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:767:6-32
    return numpy.int32(34)
   if (_0=="logIncludeSummary"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:768:6-30
    return numpy.int32(45)
   if (_0=="logCutSecondOpt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:769:6-28
    return numpy.int32(41)
   if (_0=="logAnaPro"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:770:6-22
    return numpy.int32(37)
   if (_0=="logResponse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:771:6-24
    return numpy.int32(53)
   if (_0=="logLocalInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:772:6-25
    return numpy.int32(48)
   if (_0=="logBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:773:6-18
    return numpy.int32(38)
   if (_0=="logBiFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:774:6-22
    return numpy.int32(39)
   if (_0=="biCleanOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:775:6-29
    return numpy.int32(5)
   if (_0=="intpntMaxNumRefinementSteps"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:776:6-40
    return numpy.int32(21)
   if (_0=="intpntStartingPoint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:777:6-32
    return numpy.int32(30)
   if (_0=="intpntDiffStep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:778:6-27
    return numpy.int32(17)
   if (_0=="intpntScaling"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:779:6-26
    return numpy.int32(28)
   if (_0=="intpntSolveForm"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:780:6-28
    return numpy.int32(29)
   if (_0=="logIntpnt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:781:6-22
    return numpy.int32(47)
   if (_0=="intpntMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:782:6-32
    return numpy.int32(19)
   if (_0=="intpntOffColTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:783:6-28
    return numpy.int32(23)
   if (_0=="intpntOrderMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:784:6-30
    return numpy.int32(25)
   if (_0=="intpntOrderGpNumSeeds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:785:6-34
    return numpy.int32(24)
   if (_0=="intpntBasis"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:786:6-24
    return numpy.int32(16)
   if (_0=="biIgnoreMaxIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:787:6-28
    return numpy.int32(6)
   if (_0=="biIgnoreNumError"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:788:6-29
    return numpy.int32(7)
   if (_0=="intpntMaxNumCor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:789:6-28
    return numpy.int32(20)
   if (_0=="presolveUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:790:6-24
    return numpy.int32(108)
   if (_0=="presolveLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:791:6-26
    return numpy.int32(102)
   if (_0=="logPresolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:792:6-24
    return numpy.int32(52)
   if (_0=="presolveLindepUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:793:6-30
    return numpy.int32(105)
   if (_0=="presolveMaxNumPass"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:794:6-31
    return numpy.int32(106)
   if (_0=="presolveEliminatorMaxNumTries"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:795:6-42
    return numpy.int32(101)
   if (_0=="presolveEliminatorMaxFill"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:796:6-38
    return numpy.int32(100)
   if (_0=="presolveMaxNumReductions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:797:6-37
    return numpy.int32(107)
   if (_0=="simStabilityPriority"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:798:6-33
    return numpy.int32(145)
   if (_0=="simPrimalCrash"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:799:6-27
    return numpy.int32(134)
   if (_0=="logSim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:800:6-19
    return numpy.int32(56)
   if (_0=="logSimMinor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:801:6-24
    return numpy.int32(58)
   if (_0=="logSimFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:802:6-23
    return numpy.int32(57)
   if (_0=="simPrimalRestrictSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:803:6-39
    return numpy.int32(136)
   if (_0=="simPrimalSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:804:6-31
    return numpy.int32(137)
   if (_0=="simDualRestrictSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:805:6-37
    return numpy.int32(126)
   if (_0=="simDualSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:806:6-29
    return numpy.int32(127)
   if (_0=="simMaxIterations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:807:6-29
    return numpy.int32(131)
   if (_0=="simHotstartLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:808:6-26
    return numpy.int32(130)
   if (_0=="simRefactorFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:809:6-28
    return numpy.int32(138)
   if (_0=="simSeed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:810:6-20
    return numpy.int32(143)
   if (_0=="mioMode"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:811:6-20
    return numpy.int32(75)
   if (_0=="logMio"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:812:6-19
    return numpy.int32(49)
   if (_0=="logMioFreq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:813:6-23
    return numpy.int32(50)
   if (_0=="mioMaxNumRelaxs"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:814:6-28
    return numpy.int32(72)
   if (_0=="mioMaxNumBranches"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:815:6-30
    return numpy.int32(71)
   if (_0=="mioMaxNumRootCutRounds"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:816:6-35
    return numpy.int32(73)
   if (_0=="mioMaxNumSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:817:6-31
    return numpy.int32(74)
   if (_0=="mioNodeSelection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:818:6-29
    return numpy.int32(77)
   if (_0=="mioHeuristicLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:819:6-30
    return numpy.int32(70)
   if (_0=="mioProbingLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:820:6-28
    return numpy.int32(79)
   if (_0=="mioCutSelectionLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:821:6-33
    return numpy.int32(68)
   if (_0=="mioVbDetectionLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:822:6-32
    return numpy.int32(85)
   if (_0=="mioBranchDir"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:823:6-25
    return numpy.int32(61)
   if (_0=="mioRootOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:824:6-29
    return numpy.int32(82)
   if (_0=="mioNodeOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:825:6-29
    return numpy.int32(76)
   if (_0=="mioPerspectiveReformulate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:826:6-38
    return numpy.int32(78)
   if (_0=="mioPropagateObjectiveConstraint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:827:6-44
    return numpy.int32(80)
   if (_0=="mioSeed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:828:6-20
    return numpy.int32(84)
   if (_0=="mioConicOuterApproximation"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:829:6-39
    return numpy.int32(62)
   if (_0=="readKeepFreeCon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:830:6-28
    return numpy.int32(112)
   if (_0=="readMpsFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:831:6-26
    return numpy.int32(115)
   if (_0=="writeMpsFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:832:6-27
    return numpy.int32(170)
   if (_0=="readMpsWidth"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:833:6-25
    return numpy.int32(116)
   if (_0=="readDebug"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:834:6-22
    return numpy.int32(111)
   if (_0=="readLpQuotedNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:835:6-30
    return numpy.int32(114)
   if (_0=="writeDataParam"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:836:6-27
    return numpy.int32(157)
   if (_0=="writeFreeCon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:837:6-25
    return numpy.int32(158)
   if (_0=="writeGenericNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:838:6-30
    return numpy.int32(159)
   if (_0=="writeGenericNamesIo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:839:6-32
    return numpy.int32(160)
   if (_0=="writeCompression"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:840:6-29
    return numpy.int32(156)
   if (_0=="writeMpsInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:841:6-24
    return numpy.int32(171)
   if (_0=="writeLpStrictFormat"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:842:6-32
    return numpy.int32(168)
   if (_0=="writeLpQuotedNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:843:6-31
    return numpy.int32(167)
   if (_0=="writeLpLineWidth"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:844:6-29
    return numpy.int32(166)
   if (_0=="writeLpTermsPerLine"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:845:6-32
    return numpy.int32(169)
   if (_0=="writeLpFullObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:846:6-27
    return numpy.int32(165)
   if (_0=="writePrecision"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:847:6-27
    return numpy.int32(172)
   if (_0=="writeSolIgnoreInvalidNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:848:6-39
    return numpy.int32(176)
   if (_0=="writeSolHead"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:849:6-25
    return numpy.int32(175)
   if (_0=="writeSolConstraints"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:850:6-32
    return numpy.int32(174)
   if (_0=="writeSolVariables"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:851:6-30
    return numpy.int32(177)
   if (_0=="writeSolBarvariables"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:852:6-33
    return numpy.int32(173)
   if (_0=="writeBasHead"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:853:6-25
    return numpy.int32(154)
   if (_0=="writeBasConstraints"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:854:6-32
    return numpy.int32(153)
   if (_0=="writeBasVariables"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:855:6-30
    return numpy.int32(155)
   if (_0=="writeIntHead"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:856:6-25
    return numpy.int32(163)
   if (_0=="writeIntConstraints"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:857:6-32
    return numpy.int32(162)
   if (_0=="writeIntVariables"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:858:6-30
    return numpy.int32(164)
   if (_0=="solReadNameWidth"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:859:6-29
    return numpy.int32(149)
   if (_0=="solReadWidth"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:860:6-25
    return numpy.int32(150)
   if (_0=="infeasReportAuto"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:861:6-29
    return numpy.int32(14)
   if (_0=="infeasReportLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:862:6-30
    return numpy.int32(15)
   if (_0=="infeasGenericNames"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:863:6-31
    return numpy.int32(12)
   if (_0=="logInfeasAna"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:864:6-25
    return numpy.int32(46)
   if (_0=="licenseWait"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:865:6-24
    return numpy.int32(35)
   if (_0=="licenseSuppressExpireWrns"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:866:6-38
    return numpy.int32(33)
   if (_0=="licensePauseTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:867:6-29
    return numpy.int32(32)
   if (_0=="licenseDebug"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:868:6-25
    return numpy.int32(31)
   if (_0=="solFilterKeepBasic"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:869:6-31
    return numpy.int32(147)
   if (_0=="solFilterKeepRanged"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:870:6-32
    return numpy.int32(148)
   if (_0=="log"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:871:6-16
    return numpy.int32(36)
   if (_0=="logExpand"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:872:6-22
    return numpy.int32(42)
   if (_0=="logFile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:873:6-20
    return numpy.int32(44)
   if (_0=="logOrder"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:874:6-21
    return numpy.int32(51)
   if (_0=="logSensitivity"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:875:6-27
    return numpy.int32(54)
   if (_0=="logSensitivityOpt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:876:6-30
    return numpy.int32(55)
   if (_0=="readTaskIgnoreParam"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:877:6-32
    return numpy.int32(117)
   if (_0=="writeTaskIncSol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:878:6-28
    return numpy.int32(178)
   if (_0=="paramReadCaseName"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:879:6-30
    return numpy.int32(98)
   if (_0=="paramReadIgnError"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:880:6-30
    return numpy.int32(99)
   if (_0=="solutionCallback"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:881:6-29
    return numpy.int32(151)
   if (_0=="simScaling"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:882:6-23
    return numpy.int32(141)
   if (_0=="simScalingMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:883:6-29
    return numpy.int32(142)
   if (_0=="simPrimalPhaseoneMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:884:6-36
    return numpy.int32(135)
   if (_0=="simDualPhaseoneMethod"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:885:6-34
    return numpy.int32(125)
   if (_0=="simMaxNumSetbacks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:886:6-30
    return numpy.int32(132)
   if (_0=="simHotstart"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:887:6-24
    return numpy.int32(129)
   if (_0=="simBasisFactorUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:888:6-30
    return numpy.int32(122)
   if (_0=="simDegen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:889:6-21
    return numpy.int32(123)
   if (_0=="simReformulation"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:890:6-29
    return numpy.int32(139)
   if (_0=="simExploitDupvec"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:891:6-29
    return numpy.int32(128)
   if (_0=="simSaveLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:892:6-22
    return numpy.int32(140)
   if (_0=="simNonSingular"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:893:6-27
    return numpy.int32(133)
   if (_0=="simDualCrash"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:894:6-25
    return numpy.int32(124)
   if (_0=="logStorage"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:895:6-23
    return numpy.int32(59)
   if (_0=="infeasPreferPrimal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:896:6-31
    return numpy.int32(13)
   if (_0=="readLpDropNewVarsInBou"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:897:6-35
    return numpy.int32(113)
   if (_0=="opfWriteLineLength"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:898:6-31
    return numpy.int32(90)
   if (_0=="opfWriteHints"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:899:6-26
    return numpy.int32(89)
   if (_0=="opfWriteParameters"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:900:6-31
    return numpy.int32(91)
   if (_0=="opfWriteProblem"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:901:6-28
    return numpy.int32(92)
   if (_0=="opfWriteHeader"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:902:6-27
    return numpy.int32(88)
   if (_0=="opfWriteSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:903:6-30
    return numpy.int32(96)
   if (_0=="opfWriteSolBas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:904:6-27
    return numpy.int32(93)
   if (_0=="opfWriteSolItg"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:905:6-27
    return numpy.int32(94)
   if (_0=="opfWriteSolItr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:906:6-27
    return numpy.int32(95)
   if (_0=="ptfWriteTransform"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:907:6-30
    return numpy.int32(110)
   if (_0=="primalRepairOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:908:6-34
    return numpy.int32(109)
   if (_0=="mioRootRepeatPresolveLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:909:6-39
    return numpy.int32(83)
   if (_0=="mioCutCmir"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:910:6-23
    return numpy.int32(64)
   if (_0=="mioCutClique"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:911:6-25
    return numpy.int32(63)
   if (_0=="mioCutImpliedBound"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:912:6-31
    return numpy.int32(66)
   if (_0=="mioCutKnapsackCover"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:913:6-32
    return numpy.int32(67)
   if (_0=="mioCutGmi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:914:6-22
    return numpy.int32(65)
   if (_0=="sensitivityType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:915:6-28
    return numpy.int32(121)
   if (_0=="presolveLindepRelWorkTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:916:6-37
    return numpy.int32(104)
   if (_0=="presolveLindepAbsWorkTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:917:6-37
    return numpy.int32(103)
   if (_0=="sensitivityAll"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:918:6-27
    return numpy.int32(119)
   if (_0=="logFeasRepair"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:919:6-26
    return numpy.int32(43)
   if (_0=="cacheLicense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:920:6-25
    return numpy.int32(9)
   if (_0=="intpntRegularizationUse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:921:6-36
    return numpy.int32(27)
   if (_0=="simSolveForm"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:922:6-25
    return numpy.int32(144)
   if (_0=="simSwitchOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:923:6-31
    return numpy.int32(146)
   if (_0=="writeIgnoreIncompatibleItems"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:924:6-41
    return numpy.int32(161)
   if (_0=="checkConvexity"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:925:6-27
    return numpy.int32(10)
   if (_0=="logCheckConvexity"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:926:6-30
    return numpy.int32(40)
   if (_0=="autoSortABeforeOpt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:927:6-31
    return numpy.int32(2)
   if (_0=="sensitivityOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:928:6-33
    return numpy.int32(120)
   if (_0=="writeXmlMode"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:929:6-25
    return numpy.int32(179)
   if (_0=="anaSolBasis"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:930:6-24
    return numpy.int32(0)
   if (_0=="anaSolPrintViolated"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:931:6-32
    return numpy.int32(1)
   if (_0=="basisSolveUsePlusOne"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:932:6-33
    return numpy.int32(4)
   if (_0=="compressStatfile"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:933:6-29
    return numpy.int32(11)
   if (_0=="mioRinsMaxNodes"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:934:6-28
    return numpy.int32(81)
   if (_0=="mioFeaspumpLevel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:935:6-29
    return numpy.int32(69)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iomode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iomode_1value_S(_0)
  @staticmethod
  def __string_1to_1iomode_1value_S(_0):
   if (_0=="read"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:749:6-17
    return numpy.int32(0)
   if (_0=="write"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:750:6-18
    return numpy.int32(1)
   if (_0=="readwrite"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:751:6-22
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1iinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1iinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1iinf_1value_S(_0):
   if (_0=="versionMajor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:647:6-25
    return numpy.int32(95)
   if (_0=="versionMinor"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:648:6-25
    return numpy.int32(96)
   if (_0=="versionRevision"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:649:6-28
    return numpy.int32(97)
   if (_0=="presolveLindepWork"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:650:6-31
    return numpy.int32(60)
   if (_0=="presolveLindepPivots"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:651:6-33
    return numpy.int32(58)
   if (_0=="presolveLindepSkipped"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:652:6-34
    return numpy.int32(59)
   if (_0=="presolveOutofspace"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:653:6-31
    return numpy.int32(80)
   if (_0=="presolveBadPrecision"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:654:6-33
    return numpy.int32(32)
   if (_0=="optObjectiveSense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:655:6-30
    return numpy.int32(30)
   if (_0=="optimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:656:6-22
    return numpy.int32(31)
   if (_0=="intpntFirRefIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:657:6-29
    return numpy.int32(9)
   if (_0=="intpntNumRefSteps"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:658:6-30
    return numpy.int32(14)
   if (_0=="intpntFactorDim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:659:6-28
    return numpy.int32(2)
   if (_0=="intpntFactorSchurNumSingular"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:660:6-41
    return numpy.int32(8)
   if (_0=="intpntFactorNumDenseA"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:661:6-34
    return numpy.int32(4)
   if (_0=="intpntFactorNumDenseADup"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:662:6-37
    return numpy.int32(5)
   if (_0=="intpntFactorNumDenseW"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:663:6-34
    return numpy.int32(6)
   if (_0=="intpntNumcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:664:6-25
    return numpy.int32(21)
   if (_0=="intpntNumvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:665:6-25
    return numpy.int32(28)
   if (_0=="intpntNumbarvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:666:6-28
    return numpy.int32(15)
   if (_0=="intpntNumblo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:667:6-25
    return numpy.int32(18)
   if (_0=="intpntNumbup"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:668:6-25
    return numpy.int32(20)
   if (_0=="intpntNumbfr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:669:6-25
    return numpy.int32(16)
   if (_0=="intpntNumbfx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:670:6-25
    return numpy.int32(17)
   if (_0=="intpntNumcone"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:671:6-26
    return numpy.int32(22)
   if (_0=="intpntNumconevar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:672:6-29
    return numpy.int32(23)
   if (_0=="intpntNumbndcone"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:673:6-29
    return numpy.int32(19)
   if (_0=="intpntNumrqcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:674:6-29
    return numpy.int32(27)
   if (_0=="intpntNumqcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:675:6-28
    return numpy.int32(26)
   if (_0=="intpntNumpexpcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:676:6-31
    return numpy.int32(24)
   if (_0=="intpntNumppowcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:677:6-31
    return numpy.int32(25)
   if (_0=="intpntMinconedim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:678:6-29
    return numpy.int32(13)
   if (_0=="intpntMaxconedim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:679:6-29
    return numpy.int32(12)
   if (_0=="intpntMaxbarvardim"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:680:6-31
    return numpy.int32(11)
   if (_0=="presolveNumcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:681:6-27
    return numpy.int32(69)
   if (_0=="presolveNumcfr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:682:6-27
    return numpy.int32(65)
   if (_0=="presolveNumcfx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:683:6-27
    return numpy.int32(66)
   if (_0=="presolveNumclo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:684:6-27
    return numpy.int32(67)
   if (_0=="presolveNumcup"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:685:6-27
    return numpy.int32(71)
   if (_0=="presolveNumcra"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:686:6-27
    return numpy.int32(70)
   if (_0=="presolveNumcnl"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:687:6-27
    return numpy.int32(68)
   if (_0=="presolveNumvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:688:6-27
    return numpy.int32(73)
   if (_0=="presolveNumvfr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:689:6-27
    return numpy.int32(74)
   if (_0=="presolveNumvfx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:690:6-27
    return numpy.int32(75)
   if (_0=="presolveNumvlo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:691:6-27
    return numpy.int32(76)
   if (_0=="presolveNumvup"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:692:6-27
    return numpy.int32(79)
   if (_0=="presolveNumvra"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:693:6-27
    return numpy.int32(78)
   if (_0=="presolveNumvnl"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:694:6-27
    return numpy.int32(77)
   if (_0=="presolveNumnza"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:695:6-27
    return numpy.int32(72)
   if (_0=="presolveFnumcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:696:6-28
    return numpy.int32(40)
   if (_0=="presolveFnumcfr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:697:6-28
    return numpy.int32(36)
   if (_0=="presolveFnumcfx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:698:6-28
    return numpy.int32(37)
   if (_0=="presolveFnumclo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:699:6-28
    return numpy.int32(38)
   if (_0=="presolveFnumcup"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:700:6-28
    return numpy.int32(42)
   if (_0=="presolveFnumcra"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:701:6-28
    return numpy.int32(41)
   if (_0=="presolveFnumcnl"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:702:6-28
    return numpy.int32(39)
   if (_0=="presolveFnumvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:703:6-28
    return numpy.int32(44)
   if (_0=="presolveFnumvfr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:704:6-28
    return numpy.int32(45)
   if (_0=="presolveFnumvfx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:705:6-28
    return numpy.int32(46)
   if (_0=="presolveFnumvlo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:706:6-28
    return numpy.int32(47)
   if (_0=="presolveFnumvup"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:707:6-28
    return numpy.int32(50)
   if (_0=="presolveFnumvra"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:708:6-28
    return numpy.int32(49)
   if (_0=="presolveFnumvnl"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:709:6-28
    return numpy.int32(48)
   if (_0=="presolveFnumnza"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:710:6-28
    return numpy.int32(43)
   if (_0=="presolveNumElimns"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:711:6-30
    return numpy.int32(62)
   if (_0=="presolveEliNumTries"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:712:6-32
    return numpy.int32(35)
   if (_0=="presolveEliNumFreedCon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:713:6-35
    return numpy.int32(33)
   if (_0=="presolveEliNumFreedConTotal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:714:6-40
    return numpy.int32(34)
   if (_0=="presolveLindepNumTries"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:715:6-35
    return numpy.int32(56)
   if (_0=="presolveLindepNum"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:716:6-30
    return numpy.int32(55)
   if (_0=="presolveForceConNum"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:717:6-32
    return numpy.int32(51)
   if (_0=="presolveForceConNumVar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:718:6-35
    return numpy.int32(52)
   if (_0=="presolveForceVarNum"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:719:6-32
    return numpy.int32(53)
   if (_0=="presolveForceVarNumCon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:720:6-35
    return numpy.int32(54)
   if (_0=="presolvePivOnConNum"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:721:6-32
    return numpy.int32(81)
   if (_0=="presolveNumDouBlocks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:722:6-33
    return numpy.int32(61)
   if (_0=="presolveNumSimplifiedDouBlocks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:723:6-43
    return numpy.int32(64)
   if (_0=="presolveSizeSimplifiedDouBlocks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:724:6-44
    return numpy.int32(82)
   if (_0=="presolveNumQuadConeOrthoTrans"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:725:6-42
    return numpy.int32(63)
   if (_0=="intpntFactorNum"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:726:6-28
    return numpy.int32(3)
   if (_0=="intpntFactorNumSolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:727:6-33
    return numpy.int32(7)
   if (_0=="simPrimalHotstartNumBasics"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:728:6-39
    return numpy.int32(92)
   if (_0=="simPrimalHotstartBasisRank"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:729:6-39
    return numpy.int32(91)
   if (_0=="simDualHotstartNumBasics"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:730:6-37
    return numpy.int32(84)
   if (_0=="simDualHotstartBasisRank"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:731:6-37
    return numpy.int32(83)
   if (_0=="intpntGpOrderEmployed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:732:6-34
    return numpy.int32(10)
   if (_0=="numLuFactorizations"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:733:6-32
    return numpy.int32(29)
   if (_0=="simPrimalTrust"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:734:6-27
    return numpy.int32(94)
   if (_0=="simDualTrust"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:735:6-25
    return numpy.int32(86)
   if (_0=="simPrimalNumSetbacks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:736:6-33
    return numpy.int32(93)
   if (_0=="simDualNumSetbacks"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:737:6-31
    return numpy.int32(85)
   if (_0=="simNumDupvec"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:738:6-25
    return numpy.int32(89)
   if (_0=="simNumPrimalBoundswaps"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:739:6-35
    return numpy.int32(90)
   if (_0=="simNumDualBoundswaps"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:740:6-33
    return numpy.int32(87)
   if (_0=="simNumDualIntegerPivots"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:741:6-36
    return numpy.int32(88)
   if (_0=="biPrimalInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:742:6-25
    return numpy.int32(1)
   if (_0=="biDualInfo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:743:6-23
    return numpy.int32(0)
   if (_0=="presolveLindepNumTruncTries"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:744:6-40
    return numpy.int32(57)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1dinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1dinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1dinf_1value_S(_0):
   if (_0=="sensitivityPrimalTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:560:6-34
    return numpy.int32(78)
   if (_0=="sensitivityDualTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:561:6-32
    return numpy.int32(77)
   if (_0=="intpntGfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:562:6-24
    return numpy.int32(55)
   if (_0=="intpntMu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:563:6-21
    return numpy.int32(62)
   if (_0=="intpntInitIterTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:564:6-31
    return numpy.int32(57)
   if (_0=="intpntFactorTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:565:6-29
    return numpy.int32(53)
   if (_0=="intpntInitSearchTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:566:6-33
    return numpy.int32(58)
   if (_0=="intpntFormSearchTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:567:6-33
    return numpy.int32(54)
   if (_0=="intpntUpdateTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:568:6-29
    return numpy.int32(67)
   if (_0=="intpntFactorSetupTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:569:6-34
    return numpy.int32(46)
   if (_0=="intpntFactorSchurTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:570:6-34
    return numpy.int32(40)
   if (_0=="intpntFactorHatSchurTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:571:6-37
    return numpy.int32(37)
   if (_0=="intpntFactorHatSchurPushTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:572:6-41
    return numpy.int32(36)
   if (_0=="intpntFactorHatSchurPullTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:573:6-41
    return numpy.int32(34)
   if (_0=="intpntFactorBarSchurTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:574:6-37
    return numpy.int32(14)
   if (_0=="intpntFactorBarSchurDeTabTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:575:6-42
    return numpy.int32(11)
   if (_0=="intpntFactorBarSchurSpTabTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:576:6-42
    return numpy.int32(13)
   if (_0=="intpntFactorSparseLTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:577:6-36
    return numpy.int32(50)
   if (_0=="intpntFactorSparseLUpdateLastTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:578:6-46
    return numpy.int32(52)
   if (_0=="intpntFactorSparseLFactorLastTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:579:6-46
    return numpy.int32(48)
   if (_0=="intpntFactorDenseLTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:580:6-35
    return numpy.int32(29)
   if (_0=="intpntFactorDenseTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:581:6-34
    return numpy.int32(30)
   if (_0=="intpntFactorDenseDotaTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:582:6-38
    return numpy.int32(17)
   if (_0=="intpntFactorDenseDotaSolveTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:583:6-43
    return numpy.int32(16)
   if (_0=="intpntFactorDenseDotatdotaTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:584:6-43
    return numpy.int32(19)
   if (_0=="intpntFactorDenseDotlInitTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:585:6-42
    return numpy.int32(26)
   if (_0=="intpntFactorDenseDotlFactorTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:586:6-44
    return numpy.int32(25)
   if (_0=="intpntIterNonCorrectorFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:587:6-40
    return numpy.int32(59)
   if (_0=="intpntIterOneCorrectorFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:588:6-40
    return numpy.int32(60)
   if (_0=="intpntSolveTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:589:6-28
    return numpy.int32(66)
   if (_0=="intpntIterRefTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:590:6-30
    return numpy.int32(61)
   if (_0=="intpntSolveSparseLTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:591:6-35
    return numpy.int32(65)
   if (_0=="intpntSolveDenseLTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:592:6-34
    return numpy.int32(64)
   if (_0=="intpntFactorSetupFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:593:6-35
    return numpy.int32(42)
   if (_0=="intpntFactorSetupHatSchurFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:594:6-43
    return numpy.int32(44)
   if (_0=="intpntFactorSchurFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:595:6-35
    return numpy.int32(39)
   if (_0=="intpntFactorHatSchurFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:596:6-38
    return numpy.int32(32)
   if (_0=="intpntFactorHatSchurPushFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:597:6-42
    return numpy.int32(35)
   if (_0=="intpntFactorHatSchurPullFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:598:6-42
    return numpy.int32(33)
   if (_0=="intpntFactorBarSchurFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:599:6-38
    return numpy.int32(12)
   if (_0=="intpntFactorSparseLFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:600:6-37
    return numpy.int32(49)
   if (_0=="intpntFactorMlOrderSparseLFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:601:6-44
    return numpy.int32(38)
   if (_0=="intpntFactorGpOrderSparseLFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:602:6-44
    return numpy.int32(31)
   if (_0=="intpntFactorSparseLUpdateLastFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:603:6-47
    return numpy.int32(51)
   if (_0=="intpntFactorSparseLFactorLastFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:604:6-47
    return numpy.int32(47)
   if (_0=="intpntFactorDenseLFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:605:6-36
    return numpy.int32(28)
   if (_0=="intpntFactorDenseFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:606:6-35
    return numpy.int32(27)
   if (_0=="intpntFactorDenseDotaFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:607:6-39
    return numpy.int32(15)
   if (_0=="intpntFactorDenseDotatdotaFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:608:6-44
    return numpy.int32(18)
   if (_0=="intpntFactorDenseDotlFactor_initFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:609:6-50
    return numpy.int32(23)
   if (_0=="intpntFactorDenseDotlFactorFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:610:6-45
    return numpy.int32(24)
   if (_0=="intpntFactorDenseDotl11FactorFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:611:6-47
    return numpy.int32(20)
   if (_0=="intpntFactorDenseDotl21FactorFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:612:6-47
    return numpy.int32(21)
   if (_0=="intpntFactorDenseDotl22FactorFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:613:6-47
    return numpy.int32(22)
   if (_0=="presolveAcoltTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:614:6-30
    return numpy.int32(68)
   if (_0=="presolveSetupTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:615:6-30
    return numpy.int32(73)
   if (_0=="presolveCheckproTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:616:6-33
    return numpy.int32(69)
   if (_0=="presolveDupconTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:617:6-31
    return numpy.int32(70)
   if (_0=="presolveDupvarTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:618:6-31
    return numpy.int32(71)
   if (_0=="presolveFinalTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:619:6-30
    return numpy.int32(72)
   if (_0=="presolveSubDomvarTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:620:6-34
    return numpy.int32(74)
   if (_0=="presolveSubRelaxTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:621:6-33
    return numpy.int32(75)
   if (_0=="primalSimplexInftime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:622:6-33
    return numpy.int32(76)
   if (_0=="dualSimplexInftime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:623:6-31
    return numpy.int32(10)
   if (_0=="intpntGpOrderSavedFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:624:6-36
    return numpy.int32(56)
   if (_0=="intpntFactorSetupDetectDenseTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:625:6-45
    return numpy.int32(41)
   if (_0=="intpntFactorSetupMlOrderTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:626:6-41
    return numpy.int32(45)
   if (_0=="intpntFactorSetupGpOrderTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:627:6-41
    return numpy.int32(43)
   if (_0=="biCrashTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:628:6-24
    return numpy.int32(1)
   if (_0=="biCrashLuTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:629:6-26
    return numpy.int32(0)
   if (_0=="biFactorTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:630:6-25
    return numpy.int32(5)
   if (_0=="biFactorWork"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:631:6-25
    return numpy.int32(6)
   if (_0=="biPrimalDone"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:632:6-25
    return numpy.int32(7)
   if (_0=="biDualDone"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:633:6-23
    return numpy.int32(2)
   if (_0=="simPrimalObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:634:6-25
    return numpy.int32(82)
   if (_0=="simPrimalFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:635:6-26
    return numpy.int32(81)
   if (_0=="simDualObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:636:6-23
    return numpy.int32(80)
   if (_0=="simDualFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:637:6-24
    return numpy.int32(79)
   if (_0=="biPrimalObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:638:6-24
    return numpy.int32(9)
   if (_0=="biDualObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:639:6-22
    return numpy.int32(4)
   if (_0=="biPrimalFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:640:6-25
    return numpy.int32(8)
   if (_0=="biDualFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:641:6-23
    return numpy.int32(3)
   if (_0=="intpntPurifyTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:642:6-29
    return numpy.int32(63)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1inftype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1inftype_1value_S(_0)
  @staticmethod
  def __string_1to_1inftype_1value_S(_0):
   if (_0=="douType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:553:6-20
    return numpy.int32(0)
   if (_0=="intType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:554:6-20
    return numpy.int32(1)
   if (_0=="lintType"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:555:6-21
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1iinfitem_1value_S(_0):
   if (_0=="anaProNumCon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:448:6-25
    return numpy.int32(0)
   if (_0=="anaProNumConLo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:449:6-27
    return numpy.int32(3)
   if (_0=="anaProNumConUp"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:450:6-27
    return numpy.int32(5)
   if (_0=="anaProNumConRa"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:451:6-27
    return numpy.int32(4)
   if (_0=="anaProNumConEq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:452:6-27
    return numpy.int32(1)
   if (_0=="anaProNumConFr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:453:6-27
    return numpy.int32(2)
   if (_0=="anaProNumVar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:454:6-25
    return numpy.int32(6)
   if (_0=="anaProNumVarLo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:455:6-27
    return numpy.int32(12)
   if (_0=="anaProNumVarUp"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:456:6-27
    return numpy.int32(14)
   if (_0=="anaProNumVarRa"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:457:6-27
    return numpy.int32(13)
   if (_0=="anaProNumVarEq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:458:6-27
    return numpy.int32(9)
   if (_0=="anaProNumVarFr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:459:6-27
    return numpy.int32(10)
   if (_0=="anaProNumVarCont"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:460:6-29
    return numpy.int32(8)
   if (_0=="anaProNumVarBin"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:461:6-28
    return numpy.int32(7)
   if (_0=="anaProNumVarInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:462:6-28
    return numpy.int32(11)
   if (_0=="optimizeResponse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:463:6-29
    return numpy.int32(71)
   if (_0=="intpntIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:464:6-23
    return numpy.int32(16)
   if (_0=="intpntFactorDimDense"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:465:6-33
    return numpy.int32(15)
   if (_0=="intpntSolveDual"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:466:6-28
    return numpy.int32(18)
   if (_0=="mioNodeDepth"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:467:6-25
    return numpy.int32(22)
   if (_0=="mioNumvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:468:6-22
    return numpy.int32(48)
   if (_0=="mioNumbin"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:469:6-22
    return numpy.int32(33)
   if (_0=="mioNumint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:470:6-22
    return numpy.int32(42)
   if (_0=="mioNumcont"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:471:6-23
    return numpy.int32(38)
   if (_0=="mioNumcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:472:6-22
    return numpy.int32(35)
   if (_0=="mioNumcone"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:473:6-23
    return numpy.int32(36)
   if (_0=="mioNumqcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:474:6-25
    return numpy.int32(46)
   if (_0=="mioNumrqcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:475:6-26
    return numpy.int32(47)
   if (_0=="mioNumpexpcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:476:6-28
    return numpy.int32(44)
   if (_0=="mioNumdexpcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:477:6-28
    return numpy.int32(40)
   if (_0=="mioNumppowcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:478:6-28
    return numpy.int32(45)
   if (_0=="mioNumdpowcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:479:6-28
    return numpy.int32(41)
   if (_0=="mioNumconevar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:480:6-26
    return numpy.int32(37)
   if (_0=="mioNumbinconevar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:481:6-29
    return numpy.int32(34)
   if (_0=="mioNumintconevar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:482:6-29
    return numpy.int32(43)
   if (_0=="mioNumcontconevar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:483:6-30
    return numpy.int32(39)
   if (_0=="mioPresolvedNumvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:484:6-31
    return numpy.int32(65)
   if (_0=="mioPresolvedNumbin"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:485:6-31
    return numpy.int32(50)
   if (_0=="mioPresolvedNumint"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:486:6-31
    return numpy.int32(59)
   if (_0=="mioPresolvedNumcont"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:487:6-32
    return numpy.int32(55)
   if (_0=="mioPresolvedNumcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:488:6-31
    return numpy.int32(52)
   if (_0=="mioPresolvedNumcone"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:489:6-32
    return numpy.int32(53)
   if (_0=="mioPresolvedNumqcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:490:6-34
    return numpy.int32(63)
   if (_0=="mioPresolvedNumrqcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:491:6-35
    return numpy.int32(64)
   if (_0=="mioPresolvedNumpexpcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:492:6-37
    return numpy.int32(61)
   if (_0=="mioPresolvedNumdexpcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:493:6-37
    return numpy.int32(57)
   if (_0=="mioPresolvedNumppowcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:494:6-37
    return numpy.int32(62)
   if (_0=="mioPresolvedNumdpowcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:495:6-37
    return numpy.int32(58)
   if (_0=="mioPresolvedNumconevar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:496:6-35
    return numpy.int32(54)
   if (_0=="mioPresolvedNumbinconevar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:497:6-38
    return numpy.int32(51)
   if (_0=="mioPresolvedNumintconevar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:498:6-38
    return numpy.int32(60)
   if (_0=="mioPresolvedNumcontconevar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:499:6-39
    return numpy.int32(56)
   if (_0=="mioCliqueTableSize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:500:6-31
    return numpy.int32(20)
   if (_0=="mioConstructSolution"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:501:6-33
    return numpy.int32(21)
   if (_0=="mioNumIntSolutions"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:502:6-31
    return numpy.int32(29)
   if (_0=="mioObjBoundDefined"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:503:6-31
    return numpy.int32(49)
   if (_0=="mioNumActiveNodes"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:504:6-30
    return numpy.int32(23)
   if (_0=="mioNumRelax"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:505:6-24
    return numpy.int32(31)
   if (_0=="mioNumBranch"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:506:6-25
    return numpy.int32(24)
   if (_0=="mioTotalNumCuts"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:507:6-28
    return numpy.int32(67)
   if (_0=="mioNumCmirCuts"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:508:6-27
    return numpy.int32(26)
   if (_0=="mioNumCliqueCuts"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:509:6-29
    return numpy.int32(25)
   if (_0=="mioNumImpliedBoundCuts"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:510:6-35
    return numpy.int32(28)
   if (_0=="mioNumKnapsackCoverCuts"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:511:6-36
    return numpy.int32(30)
   if (_0=="mioNumGomoryCuts"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:512:6-29
    return numpy.int32(27)
   if (_0=="mioNumRepeatedPresolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:513:6-35
    return numpy.int32(32)
   if (_0=="mioUserObjCut"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:514:6-26
    return numpy.int32(68)
   if (_0=="mioRelgapSatisfied"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:515:6-31
    return numpy.int32(66)
   if (_0=="mioAbsgapSatisfied"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:516:6-31
    return numpy.int32(19)
   if (_0=="rdProtype"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:517:6-22
    return numpy.int32(80)
   if (_0=="rdNumcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:518:6-21
    return numpy.int32(75)
   if (_0=="rdNumvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:519:6-21
    return numpy.int32(79)
   if (_0=="rdNumbarvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:520:6-24
    return numpy.int32(74)
   if (_0=="rdNumintvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:521:6-24
    return numpy.int32(77)
   if (_0=="rdNumq"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:522:6-19
    return numpy.int32(78)
   if (_0=="simDualDegIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:523:6-27
    return numpy.int32(81)
   if (_0=="simDualInfIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:524:6-27
    return numpy.int32(84)
   if (_0=="simDualHotstartLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:525:6-30
    return numpy.int32(83)
   if (_0=="simPrimalIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:526:6-26
    return numpy.int32(92)
   if (_0=="simDualIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:527:6-24
    return numpy.int32(85)
   if (_0=="intpntNumThreads"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:528:6-29
    return numpy.int32(17)
   if (_0=="simPrimalInfIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:529:6-29
    return numpy.int32(91)
   if (_0=="simPrimalDegIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:530:6-29
    return numpy.int32(88)
   if (_0=="simPrimalHotstart"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:531:6-30
    return numpy.int32(89)
   if (_0=="simPrimalHotstartLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:532:6-32
    return numpy.int32(90)
   if (_0=="simDualHotstart"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:533:6-28
    return numpy.int32(82)
   if (_0=="solItrProsta"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:534:6-25
    return numpy.int32(98)
   if (_0=="solItrSolsta"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:535:6-25
    return numpy.int32(99)
   if (_0=="solBasProsta"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:536:6-25
    return numpy.int32(94)
   if (_0=="solBasSolsta"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:537:6-25
    return numpy.int32(95)
   if (_0=="solItgProsta"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:538:6-25
    return numpy.int32(96)
   if (_0=="solItgSolsta"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:539:6-25
    return numpy.int32(97)
   if (_0=="simNumcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:540:6-22
    return numpy.int32(86)
   if (_0=="simNumvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:541:6-22
    return numpy.int32(87)
   if (_0=="optNumcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:542:6-22
    return numpy.int32(69)
   if (_0=="optNumvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:543:6-22
    return numpy.int32(70)
   if (_0=="stoNumARealloc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:544:6-27
    return numpy.int32(100)
   if (_0=="rdNumcone"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:545:6-22
    return numpy.int32(76)
   if (_0=="simSolveDual"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:546:6-25
    return numpy.int32(93)
   if (_0=="purifyPrimalSuccess"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:547:6-32
    return numpy.int32(73)
   if (_0=="purifyDualSuccess"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:548:6-30
    return numpy.int32(72)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1liinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1liinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1liinf_1value_S(_0):
   if (_0=="intpntLenbarvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:436:6-28
    return numpy.int32(6)
   if (_0=="intpntFactorNumNzBefore"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:437:6-36
    return numpy.int32(3)
   if (_0=="intpntFactorNumNzAfter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:438:6-35
    return numpy.int32(2)
   if (_0=="intpntFactorMlOrderSparseLNz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:439:6-41
    return numpy.int32(1)
   if (_0=="intpntFactorGpOrderSparseLNz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:440:6-41
    return numpy.int32(0)
   if (_0=="presolveStackSize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:441:6-30
    return numpy.int32(7)
   if (_0=="intpntFactorVNz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:442:6-28
    return numpy.int32(5)
   if (_0=="intpntFactorUpdatedVNz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:443:6-35
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1liinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1liinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1liinfitem_1value_S(_0):
   if (_0=="mioAnz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:419:6-19
    return numpy.int32(7)
   if (_0=="mioPresolvedAnz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:420:6-28
    return numpy.int32(9)
   if (_0=="mioSimplexIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:421:6-27
    return numpy.int32(10)
   if (_0=="mioIntpntIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:422:6-26
    return numpy.int32(8)
   if (_0=="biPrimalIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:423:6-25
    return numpy.int32(5)
   if (_0=="biDualIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:424:6-23
    return numpy.int32(4)
   if (_0=="biCleanPrimalIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:425:6-30
    return numpy.int32(3)
   if (_0=="biCleanDualIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:426:6-28
    return numpy.int32(1)
   if (_0=="biCleanPrimalDegIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:427:6-33
    return numpy.int32(2)
   if (_0=="biCleanDualDegIter"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:428:6-31
    return numpy.int32(0)
   if (_0=="intpntFactorNumNz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:429:6-30
    return numpy.int32(6)
   if (_0=="rdNumanz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:430:6-21
    return numpy.int32(11)
   if (_0=="rdNumqnz"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:431:6-21
    return numpy.int32(12)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dparam_1value_S(_0)
  @staticmethod
  def __string_1to_1dparam_1value_S(_0):
   if (_0=="dataTolCjLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:356:6-27
    return numpy.int32(13)
   if (_0=="dataTolCHuge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:357:6-25
    return numpy.int32(12)
   if (_0=="dataTolAijLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:358:6-28
    return numpy.int32(9)
   if (_0=="dataTolAijHuge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:359:6-27
    return numpy.int32(8)
   if (_0=="dataSymMatTol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:360:6-26
    return numpy.int32(5)
   if (_0=="dataSymMatTolLarge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:361:6-31
    return numpy.int32(7)
   if (_0=="dataSymMatTolHuge"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:362:6-30
    return numpy.int32(6)
   if (_0=="dataTolBoundInf"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:363:6-28
    return numpy.int32(10)
   if (_0=="dataTolBoundWrn"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:364:6-28
    return numpy.int32(11)
   if (_0=="dataTolQij"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:365:6-23
    return numpy.int32(14)
   if (_0=="dataTolX"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:366:6-21
    return numpy.int32(15)
   if (_0=="semidefiniteTolApprox"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:367:6-34
    return numpy.int32(54)
   if (_0=="optimizerMaxTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:368:6-29
    return numpy.int32(47)
   if (_0=="lowerObjCut"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:369:6-24
    return numpy.int32(38)
   if (_0=="upperObjCut"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:370:6-24
    return numpy.int32(57)
   if (_0=="upperObjCutFiniteTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:371:6-33
    return numpy.int32(58)
   if (_0=="lowerObjCutFiniteTrh"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:372:6-33
    return numpy.int32(39)
   if (_0=="intpntTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:373:6-28
    return numpy.int32(35)
   if (_0=="intpntTolStepSize"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:374:6-30
    return numpy.int32(37)
   if (_0=="simLuTolRelPiv"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:375:6-27
    return numpy.int32(55)
   if (_0=="intpntTolRelStep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:376:6-29
    return numpy.int32(36)
   if (_0=="intpntTolPath"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:377:6-26
    return numpy.int32(32)
   if (_0=="intpntTolPfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:378:6-27
    return numpy.int32(33)
   if (_0=="intpntTolDfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:379:6-27
    return numpy.int32(28)
   if (_0=="intpntTolMuRed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:380:6-27
    return numpy.int32(31)
   if (_0=="intpntTolInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:381:6-28
    return numpy.int32(30)
   if (_0=="intpntCoTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:382:6-30
    return numpy.int32(21)
   if (_0=="intpntCoTolPfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:383:6-29
    return numpy.int32(20)
   if (_0=="intpntCoTolDfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:384:6-29
    return numpy.int32(16)
   if (_0=="intpntCoTolMuRed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:385:6-29
    return numpy.int32(18)
   if (_0=="intpntCoTolNearRel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:386:6-31
    return numpy.int32(19)
   if (_0=="intpntCoTolInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:387:6-30
    return numpy.int32(17)
   if (_0=="intpntQoTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:388:6-30
    return numpy.int32(27)
   if (_0=="intpntQoTolPfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:389:6-29
    return numpy.int32(26)
   if (_0=="intpntQoTolDfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:390:6-29
    return numpy.int32(22)
   if (_0=="intpntQoTolMuRed"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:391:6-29
    return numpy.int32(24)
   if (_0=="intpntQoTolNearRel"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:392:6-31
    return numpy.int32(25)
   if (_0=="intpntQoTolInfeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:393:6-30
    return numpy.int32(23)
   if (_0=="intpntTolPsafe"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:394:6-27
    return numpy.int32(34)
   if (_0=="intpntTolDsafe"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:395:6-27
    return numpy.int32(29)
   if (_0=="mioMaxTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:396:6-23
    return numpy.int32(40)
   if (_0=="mioRelGapConst"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:397:6-27
    return numpy.int32(41)
   if (_0=="mioTolRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:398:6-25
    return numpy.int32(46)
   if (_0=="mioTolAbsGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:399:6-25
    return numpy.int32(42)
   if (_0=="mioTolAbsRelaxInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:400:6-30
    return numpy.int32(43)
   if (_0=="basisTolX"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:401:6-22
    return numpy.int32(3)
   if (_0=="basisTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:402:6-22
    return numpy.int32(2)
   if (_0=="basisRelTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:403:6-25
    return numpy.int32(1)
   if (_0=="presolveTolX"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:404:6-25
    return numpy.int32(52)
   if (_0=="presolveTolS"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:405:6-25
    return numpy.int32(51)
   if (_0=="presolveTolAij"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:406:6-27
    return numpy.int32(49)
   if (_0=="presolveTolAbsLindep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:407:6-33
    return numpy.int32(48)
   if (_0=="presolveTolRelLindep"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:408:6-33
    return numpy.int32(50)
   if (_0=="simplexAbsTolPiv"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:409:6-29
    return numpy.int32(56)
   if (_0=="mioTolFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:410:6-23
    return numpy.int32(44)
   if (_0=="anaSolInfeasTol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:411:6-28
    return numpy.int32(0)
   if (_0=="checkConvexityRelTol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:412:6-33
    return numpy.int32(4)
   if (_0=="qcqoReformulateRelDropTol"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:413:6-38
    return numpy.int32(53)
   if (_0=="mioTolRelDualBoundImprovement"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:414:6-42
    return numpy.int32(45)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1feature_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1feature_1value_S(_0)
  @staticmethod
  def __string_1to_1feature_1value_S(_0):
   if (_0=="pts"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:350:6-16
    return numpy.int32(0)
   if (_0=="pton"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:351:6-17
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1dinfitem_1value_S(_0):
   if (_0=="biTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:256:6-19
    return numpy.int32(5)
   if (_0=="biPrimalTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:257:6-25
    return numpy.int32(4)
   if (_0=="biDualTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:258:6-23
    return numpy.int32(3)
   if (_0=="biCleanTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:259:6-24
    return numpy.int32(2)
   if (_0=="biCleanPrimalTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:260:6-30
    return numpy.int32(1)
   if (_0=="biCleanDualTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:261:6-28
    return numpy.int32(0)
   if (_0=="intpntTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:262:6-23
    return numpy.int32(13)
   if (_0=="intpntOrderTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:263:6-28
    return numpy.int32(10)
   if (_0=="intpntPrimalObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:264:6-28
    return numpy.int32(12)
   if (_0=="intpntDualObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:265:6-26
    return numpy.int32(7)
   if (_0=="intpntPrimalFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:266:6-29
    return numpy.int32(11)
   if (_0=="intpntDualFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:267:6-27
    return numpy.int32(6)
   if (_0=="intpntOptStatus"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:268:6-28
    return numpy.int32(9)
   if (_0=="simTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:269:6-20
    return numpy.int32(45)
   if (_0=="simPrimalTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:270:6-26
    return numpy.int32(44)
   if (_0=="simDualTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:271:6-24
    return numpy.int32(41)
   if (_0=="simObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:272:6-19
    return numpy.int32(43)
   if (_0=="simFeas"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:273:6-20
    return numpy.int32(42)
   if (_0=="mioTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:274:6-20
    return numpy.int32(29)
   if (_0=="mioRootPresolveTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:275:6-32
    return numpy.int32(28)
   if (_0=="mioRootOptimizerTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:276:6-33
    return numpy.int32(27)
   if (_0=="toConicTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:277:6-24
    return numpy.int32(89)
   if (_0=="mioConstructSolutionObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:278:6-36
    return numpy.int32(16)
   if (_0=="mioObjInt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:279:6-22
    return numpy.int32(23)
   if (_0=="mioObjBound"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:280:6-24
    return numpy.int32(22)
   if (_0=="mioObjRelGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:281:6-25
    return numpy.int32(24)
   if (_0=="mioObjAbsGap"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:282:6-25
    return numpy.int32(21)
   if (_0=="mioUserObjCut"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:283:6-26
    return numpy.int32(30)
   if (_0=="mioCmirSeparationTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:284:6-34
    return numpy.int32(15)
   if (_0=="mioCliqueSeparationTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:285:6-36
    return numpy.int32(14)
   if (_0=="mioKnapsackCoverSeparationTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:286:6-43
    return numpy.int32(20)
   if (_0=="mioGmiSeparationTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:287:6-33
    return numpy.int32(18)
   if (_0=="mioImpliedBoundTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:288:6-32
    return numpy.int32(19)
   if (_0=="mioRootCutgenTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:289:6-30
    return numpy.int32(26)
   if (_0=="mioProbingTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:290:6-27
    return numpy.int32(25)
   if (_0=="optimizerTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:291:6-26
    return numpy.int32(31)
   if (_0=="presolveTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:292:6-25
    return numpy.int32(34)
   if (_0=="mioDualBoundAfterPresolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:293:6-38
    return numpy.int32(17)
   if (_0=="presolveEliTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:294:6-28
    return numpy.int32(32)
   if (_0=="presolveLindepTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:295:6-31
    return numpy.int32(33)
   if (_0=="rdTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:296:6-19
    return numpy.int32(40)
   if (_0=="solItrPrimalObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:297:6-28
    return numpy.int32(84)
   if (_0=="solItrPviolcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:298:6-27
    return numpy.int32(86)
   if (_0=="solItrPviolvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:299:6-27
    return numpy.int32(88)
   if (_0=="solItrPviolbarvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:300:6-30
    return numpy.int32(85)
   if (_0=="solItrPviolcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:301:6-29
    return numpy.int32(87)
   if (_0=="solItrDualObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:302:6-26
    return numpy.int32(69)
   if (_0=="solItrDviolcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:303:6-27
    return numpy.int32(71)
   if (_0=="solItrDviolvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:304:6-27
    return numpy.int32(73)
   if (_0=="solItrDviolbarvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:305:6-30
    return numpy.int32(70)
   if (_0=="solItrDviolcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:306:6-29
    return numpy.int32(72)
   if (_0=="solItrNrmXc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:307:6-24
    return numpy.int32(81)
   if (_0=="solItrNrmXx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:308:6-24
    return numpy.int32(82)
   if (_0=="solItrNrmBarx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:309:6-26
    return numpy.int32(75)
   if (_0=="solItrNrmY"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:310:6-23
    return numpy.int32(83)
   if (_0=="solItrNrmSlc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:311:6-25
    return numpy.int32(76)
   if (_0=="solItrNrmSuc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:312:6-25
    return numpy.int32(79)
   if (_0=="solItrNrmSlx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:313:6-25
    return numpy.int32(77)
   if (_0=="solItrNrmSux"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:314:6-25
    return numpy.int32(80)
   if (_0=="solItrNrmSnx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:315:6-25
    return numpy.int32(78)
   if (_0=="solItrNrmBars"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:316:6-26
    return numpy.int32(74)
   if (_0=="solBasPrimalObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:317:6-28
    return numpy.int32(57)
   if (_0=="solBasPviolcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:318:6-27
    return numpy.int32(58)
   if (_0=="solBasPviolvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:319:6-27
    return numpy.int32(59)
   if (_0=="solBasDualObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:320:6-26
    return numpy.int32(46)
   if (_0=="solBasDviolcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:321:6-27
    return numpy.int32(47)
   if (_0=="solBasDviolvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:322:6-27
    return numpy.int32(48)
   if (_0=="solBasNrmXc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:323:6-24
    return numpy.int32(54)
   if (_0=="solBasNrmXx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:324:6-24
    return numpy.int32(55)
   if (_0=="solBasNrmBarx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:325:6-26
    return numpy.int32(49)
   if (_0=="solBasNrmY"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:326:6-23
    return numpy.int32(56)
   if (_0=="solBasNrmSlc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:327:6-25
    return numpy.int32(50)
   if (_0=="solBasNrmSuc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:328:6-25
    return numpy.int32(52)
   if (_0=="solBasNrmSlx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:329:6-25
    return numpy.int32(51)
   if (_0=="solBasNrmSux"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:330:6-25
    return numpy.int32(53)
   if (_0=="solItgPrimalObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:331:6-28
    return numpy.int32(63)
   if (_0=="solItgPviolcon"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:332:6-27
    return numpy.int32(65)
   if (_0=="solItgPviolvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:333:6-27
    return numpy.int32(68)
   if (_0=="solItgPviolbarvar"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:334:6-30
    return numpy.int32(64)
   if (_0=="solItgPviolcones"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:335:6-29
    return numpy.int32(66)
   if (_0=="solItgPviolitg"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:336:6-27
    return numpy.int32(67)
   if (_0=="solItgNrmXc"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:337:6-24
    return numpy.int32(61)
   if (_0=="solItgNrmXx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:338:6-24
    return numpy.int32(62)
   if (_0=="solItgNrmBarx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:339:6-26
    return numpy.int32(60)
   if (_0=="intpntFactorNumFlops"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:340:6-33
    return numpy.int32(8)
   if (_0=="qcqoReformulateTime"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:341:6-32
    return numpy.int32(37)
   if (_0=="qcqoReformulateMaxPerturbation"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:342:6-43
    return numpy.int32(36)
   if (_0=="qcqoReformulateWorstCholeskyDiagScaling"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:343:6-52
    return numpy.int32(39)
   if (_0=="qcqoReformulateWorstCholeskyColumnScaling"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:344:6-54
    return numpy.int32(38)
   if (_0=="primalRepairPenaltyObj"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:345:6-35
    return numpy.int32(35)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dataformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dataformat_1value_S(_0)
  @staticmethod
  def __string_1to_1dataformat_1value_S(_0):
   if (_0=="extension"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:243:6-22
    return numpy.int32(0)
   if (_0=="mps"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:244:6-16
    return numpy.int32(1)
   if (_0=="lp"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:245:6-15
    return numpy.int32(2)
   if (_0=="op"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:246:6-15
    return numpy.int32(3)
   if (_0=="freeMps"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:247:6-20
    return numpy.int32(4)
   if (_0=="task"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:248:6-17
    return numpy.int32(5)
   if (_0=="ptf"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:249:6-16
    return numpy.int32(6)
   if (_0=="cb"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:250:6-15
    return numpy.int32(7)
   if (_0=="jsonTask"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:251:6-21
    return numpy.int32(8)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1symmattype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1symmattype_1value_S(_0)
  @staticmethod
  def __string_1to_1symmattype_1value_S(_0):
   if (_0=="sparse"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:238:6-19
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scopr_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scopr_1value_S(_0)
  @staticmethod
  def __string_1to_1scopr_1value_S(_0):
   if (_0=="ent"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:229:6-16
    return numpy.int32(0)
   if (_0=="exp"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:230:6-16
    return numpy.int32(1)
   if (_0=="log"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:231:6-16
    return numpy.int32(2)
   if (_0=="pow"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:232:6-16
    return numpy.int32(3)
   if (_0=="sqrt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:233:6-17
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1nametype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1nametype_1value_S(_0)
  @staticmethod
  def __string_1to_1nametype_1value_S(_0):
   if (_0=="gen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:222:6-16
    return numpy.int32(0)
   if (_0=="mps"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:223:6-16
    return numpy.int32(1)
   if (_0=="lp"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:224:6-15
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1conetype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1conetype_1value_S(_0)
  @staticmethod
  def __string_1to_1conetype_1value_S(_0):
   if (_0=="quad"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:211:6-17
    return numpy.int32(0)
   if (_0=="rquad"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:212:6-18
    return numpy.int32(1)
   if (_0=="pexp"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:213:6-17
    return numpy.int32(2)
   if (_0=="dexp"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:214:6-17
    return numpy.int32(3)
   if (_0=="ppow"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:215:6-17
    return numpy.int32(4)
   if (_0=="dpow"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:216:6-17
    return numpy.int32(5)
   if (_0=="zero"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:217:6-17
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1compresstype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1compresstype_1value_S(_0)
  @staticmethod
  def __string_1to_1compresstype_1value_S(_0):
   if (_0=="none"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:203:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:204:6-17
    return numpy.int32(1)
   if (_0=="gzip"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:205:6-17
    return numpy.int32(2)
   if (_0=="zstd"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:206:6-17
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1checkconvexitytype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1checkconvexitytype_1value_S(_0)
  @staticmethod
  def __string_1to_1checkconvexitytype_1value_S(_0):
   if (_0=="none"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:196:6-17
    return numpy.int32(0)
   if (_0=="simple"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:197:6-19
    return numpy.int32(1)
   if (_0=="full"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:198:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1callbackcode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1callbackcode_1value_S(_0)
  @staticmethod
  def __string_1to_1callbackcode_1value_S(_0):
   if (_0=="beginRootCutgen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:99:6-28
    return numpy.int32(22)
   if (_0=="imRootCutgen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:100:6-25
    return numpy.int32(76)
   if (_0=="endRootCutgen"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:101:6-26
    return numpy.int32(51)
   if (_0=="beginOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:102:6-27
    return numpy.int32(12)
   if (_0=="endOptimizer"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:103:6-25
    return numpy.int32(41)
   if (_0=="beginPresolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:104:6-26
    return numpy.int32(13)
   if (_0=="updatePresolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:105:6-27
    return numpy.int32(88)
   if (_0=="imPresolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:106:6-23
    return numpy.int32(70)
   if (_0=="endPresolve"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:107:6-24
    return numpy.int32(42)
   if (_0=="beginIntpnt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:108:6-24
    return numpy.int32(9)
   if (_0=="intpnt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:109:6-19
    return numpy.int32(79)
   if (_0=="imIntpnt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:110:6-21
    return numpy.int32(62)
   if (_0=="endIntpnt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:111:6-22
    return numpy.int32(38)
   if (_0=="beginConic"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:112:6-23
    return numpy.int32(1)
   if (_0=="conic"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:113:6-18
    return numpy.int32(27)
   if (_0=="imConic"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:114:6-20
    return numpy.int32(57)
   if (_0=="endConic"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:115:6-21
    return numpy.int32(30)
   if (_0=="primalSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:116:6-26
    return numpy.int32(81)
   if (_0=="dualSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:117:6-24
    return numpy.int32(28)
   if (_0=="beginBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:118:6-20
    return numpy.int32(0)
   if (_0=="imBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:119:6-17
    return numpy.int32(56)
   if (_0=="endBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:120:6-18
    return numpy.int32(29)
   if (_0=="beginPrimalBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:121:6-26
    return numpy.int32(14)
   if (_0=="imPrimalBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:122:6-23
    return numpy.int32(71)
   if (_0=="updatePrimalBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:123:6-27
    return numpy.int32(89)
   if (_0=="endPrimalBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:124:6-24
    return numpy.int32(43)
   if (_0=="beginDualBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:125:6-24
    return numpy.int32(2)
   if (_0=="imDualBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:126:6-21
    return numpy.int32(58)
   if (_0=="updateDualBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:127:6-25
    return numpy.int32(85)
   if (_0=="endDualBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:128:6-22
    return numpy.int32(31)
   if (_0=="beginSimplexBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:129:6-27
    return numpy.int32(24)
   if (_0=="imSimplexBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:130:6-24
    return numpy.int32(78)
   if (_0=="beginPrimalSimplexBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:131:6-33
    return numpy.int32(19)
   if (_0=="updatePrimalSimplexBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:132:6-34
    return numpy.int32(91)
   if (_0=="endPrimalSimplexBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:133:6-31
    return numpy.int32(48)
   if (_0=="beginDualSimplexBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:134:6-31
    return numpy.int32(6)
   if (_0=="updateDualSimplexBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:135:6-32
    return numpy.int32(87)
   if (_0=="endDualSimplexBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:136:6-29
    return numpy.int32(35)
   if (_0=="endSimplexBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:137:6-25
    return numpy.int32(53)
   if (_0=="beginMio"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:138:6-21
    return numpy.int32(11)
   if (_0=="imMio"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:139:6-18
    return numpy.int32(65)
   if (_0=="newIntMio"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:140:6-22
    return numpy.int32(80)
   if (_0=="endMio"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:141:6-19
    return numpy.int32(40)
   if (_0=="beginSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:142:6-25
    return numpy.int32(23)
   if (_0=="beginDualSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:143:6-29
    return numpy.int32(5)
   if (_0=="imDualSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:144:6-26
    return numpy.int32(60)
   if (_0=="updateDualSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:145:6-30
    return numpy.int32(86)
   if (_0=="endDualSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:146:6-27
    return numpy.int32(34)
   if (_0=="beginPrimalSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:147:6-31
    return numpy.int32(18)
   if (_0=="imPrimalSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:148:6-28
    return numpy.int32(73)
   if (_0=="updatePrimalSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:149:6-32
    return numpy.int32(90)
   if (_0=="endPrimalSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:150:6-29
    return numpy.int32(47)
   if (_0=="endSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:151:6-23
    return numpy.int32(52)
   if (_0=="beginInfeasAna"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:152:6-27
    return numpy.int32(8)
   if (_0=="endInfeasAna"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:153:6-25
    return numpy.int32(37)
   if (_0=="imPrimalSensivity"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:154:6-30
    return numpy.int32(72)
   if (_0=="imDualSensivity"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:155:6-28
    return numpy.int32(59)
   if (_0=="imMioIntpnt"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:156:6-24
    return numpy.int32(67)
   if (_0=="imMioPrimalSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:157:6-31
    return numpy.int32(68)
   if (_0=="imMioDualSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:158:6-29
    return numpy.int32(66)
   if (_0=="beginPrimalSetupBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:159:6-31
    return numpy.int32(17)
   if (_0=="endPrimalSetupBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:160:6-29
    return numpy.int32(46)
   if (_0=="beginDualSetupBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:161:6-29
    return numpy.int32(4)
   if (_0=="endDualSetupBi"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:162:6-27
    return numpy.int32(33)
   if (_0=="beginPrimalSensitivity"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:163:6-35
    return numpy.int32(16)
   if (_0=="endPrimalSensitivity"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:164:6-33
    return numpy.int32(45)
   if (_0=="beginDualSensitivity"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:165:6-33
    return numpy.int32(3)
   if (_0=="endDualSensitivity"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:166:6-31
    return numpy.int32(32)
   if (_0=="beginLicenseWait"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:167:6-29
    return numpy.int32(10)
   if (_0=="endLicenseWait"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:168:6-27
    return numpy.int32(39)
   if (_0=="imLicenseWait"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:169:6-26
    return numpy.int32(63)
   if (_0=="beginQcqoReformulate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:170:6-33
    return numpy.int32(20)
   if (_0=="endQcqoReformulate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:171:6-31
    return numpy.int32(49)
   if (_0=="imQoReformulate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:172:6-28
    return numpy.int32(74)
   if (_0=="beginToConic"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:173:6-25
    return numpy.int32(25)
   if (_0=="endToConic"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:174:6-23
    return numpy.int32(54)
   if (_0=="beginFullConvexityCheck"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:175:6-36
    return numpy.int32(7)
   if (_0=="endFullConvexityCheck"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:176:6-34
    return numpy.int32(36)
   if (_0=="imFullConvexityCheck"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:177:6-33
    return numpy.int32(61)
   if (_0=="beginPrimalRepair"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:178:6-30
    return numpy.int32(15)
   if (_0=="endPrimalRepair"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:179:6-28
    return numpy.int32(44)
   if (_0=="beginRead"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:180:6-22
    return numpy.int32(21)
   if (_0=="imRead"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:181:6-19
    return numpy.int32(75)
   if (_0=="endRead"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:182:6-20
    return numpy.int32(50)
   if (_0=="beginWrite"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:183:6-23
    return numpy.int32(26)
   if (_0=="endWrite"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:184:6-21
    return numpy.int32(55)
   if (_0=="readOpfSection"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:185:6-27
    return numpy.int32(83)
   if (_0=="imLu"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:186:6-17
    return numpy.int32(64)
   if (_0=="imOrder"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:187:6-20
    return numpy.int32(69)
   if (_0=="imSimplex"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:188:6-22
    return numpy.int32(77)
   if (_0=="readOpf"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:189:6-20
    return numpy.int32(82)
   if (_0=="writeOpf"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:190:6-21
    return numpy.int32(92)
   if (_0=="solvingRemote"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:191:6-26
    return numpy.int32(84)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1purify_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1purify_1value_S(_0)
  @staticmethod
  def __string_1to_1purify_1value_S(_0):
   if (_0=="none"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:90:6-17
    return numpy.int32(0)
   if (_0=="primal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:91:6-19
    return numpy.int32(1)
   if (_0=="dual"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:92:6-17
    return numpy.int32(2)
   if (_0=="primalDual"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:93:6-23
    return numpy.int32(3)
   if (_0=="auto"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:94:6-17
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1intpnthotstart_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1intpnthotstart_1value_S(_0)
  @staticmethod
  def __string_1to_1intpnthotstart_1value_S(_0):
   if (_0=="none"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:82:6-17
    return numpy.int32(0)
   if (_0=="primal"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:83:6-19
    return numpy.int32(1)
   if (_0=="dual"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:84:6-17
    return numpy.int32(2)
   if (_0=="primalDual"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:85:6-23
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simhotstart_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simhotstart_1value_S(_0)
  @staticmethod
  def __string_1to_1simhotstart_1value_S(_0):
   if (_0=="none"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:75:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:76:6-17
    return numpy.int32(1)
   if (_0=="statusKeys"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:77:6-23
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdupvec_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simdupvec_1value_S(_0)
  @staticmethod
  def __string_1to_1simdupvec_1value_S(_0):
   if (_0=="on"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:68:6-15
    return numpy.int32(1)
   if (_0=="off"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:69:6-16
    return numpy.int32(0)
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:70:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simreform_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simreform_1value_S(_0)
  @staticmethod
  def __string_1to_1simreform_1value_S(_0):
   if (_0=="on"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:60:6-15
    return numpy.int32(1)
   if (_0=="off"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:61:6-16
    return numpy.int32(0)
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:62:6-17
    return numpy.int32(2)
   if (_0=="aggressive"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:63:6-23
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1uplo_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1uplo_1value_S(_0)
  @staticmethod
  def __string_1to_1uplo_1value_S(_0):
   if (_0=="lo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:54:6-15
    return numpy.int32(0)
   if (_0=="up"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:55:6-15
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1transpose_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1transpose_1value_S(_0)
  @staticmethod
  def __string_1to_1transpose_1value_S(_0):
   if (_0=="no"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:48:6-15
    return numpy.int32(0)
   if (_0=="yes"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:49:6-16
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdegen_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simdegen_1value_S(_0)
  @staticmethod
  def __string_1to_1simdegen_1value_S(_0):
   if (_0=="none"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:39:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:40:6-17
    return numpy.int32(1)
   if (_0=="aggressive"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:41:6-23
    return numpy.int32(2)
   if (_0=="moderate"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:42:6-21
    return numpy.int32(3)
   if (_0=="minimum"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:43:6-20
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mark_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mark_1value_S(_0)
  @staticmethod
  def __string_1to_1mark_1value_S(_0):
   if (_0=="lo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:33:6-15
    return numpy.int32(0)
   if (_0=="up"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:34:6-15
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1boundkey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1boundkey_1value_S(_0)
  @staticmethod
  def __string_1to_1boundkey_1value_S(_0):
   if (_0=="lo"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:24:6-15
    return numpy.int32(0)
   if (_0=="up"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:25:6-15
    return numpy.int32(1)
   if (_0=="fx"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:26:6-15
    return numpy.int32(2)
   if (_0=="fr"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:27:6-15
    return numpy.int32(3)
   if (_0=="ra"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:28:6-15
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1basindtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1basindtype_1value_S(_0)
  @staticmethod
  def __string_1to_1basindtype_1value_S(_0):
   if (_0=="never"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:15:6-18
    return numpy.int32(0)
   if (_0=="always"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:16:6-19
    return numpy.int32(1)
   if (_0=="noError"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:17:6-20
    return numpy.int32(2)
   if (_0=="ifFeasible"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:18:6-23
    return numpy.int32(3)
   if (_0=="reservered"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:19:6-23
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1language_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1language_1value_S(_0)
  @staticmethod
  def __string_1to_1language_1value_S(_0):
   if (_0=="eng"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:9:6-16
    return numpy.int32(0)
   if (_0=="dan"): # bld/hellerup/final/default/monty2-2.4.0/src/fusion/Parameters.mbi:10:6-16
    return numpy.int32(1)
   return numpy.int32((- 1))
 return Parameters
mosek_fusion_Parameters=__mk_mosek_fusion_Parameters()
del __mk_mosek_fusion_Parameters
def __mk_mosek_fusion_Utils_StringIntMap():
  class StringIntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_S(self,key): return key in self.__d
    def _getItem_S(self,key): return self.__d[key]
    def _setItem_SI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  return StringIntMap
mosek_fusion_Utils_StringIntMap=__mk_mosek_fusion_Utils_StringIntMap()
def __mk_mosek_fusion_Utils_IntMap():
  class IntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_J(self,key): return key in self.__d
    def _getItem_J(self,key): return self.__d[key]
    def _setItem_JI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  
  
  
  return IntMap
mosek_fusion_Utils_IntMap=__mk_mosek_fusion_Utils_IntMap()
def __mk_mosek_fusion_Utils_StringBuffer():
  class StringBuffer:
    def __init__(self):
      self.__buf = []
    def __a(self,v):
      self.__buf.append(str(v))
      return self 
    def __a_array(self,v):
      if v is None: self.__buf.append("None")
      else: self.__buf.append(str(v))
      return self
  
    _a_I   = __a
    _a_J   = __a
    _a_U   = __a
    _a_D   = __a
    _a_S   = __a
    _a_B   = __a
    _a__3I = __a_array
    def _a__3J(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%i' % i for i in v]),']'])
      else:             self.__buf.append('None')  
      return self
    def _a__3D(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%g' % i for i in v]),']'])
      else:             self.__buf.append('None')  
      return self
    _a__3S = __a_array
    def _lf_(self): 
      self.__buf.append('\n')
      return self
    def _clear_ (self):
      self.__buf = []
      return self
    def _toString_(self):
      return ''.join(self.__buf)
    def _toString_(self):
      return ''.join(self.__buf)
    def _consolePrint_(self):
      print(self._toString_())
      self._clear_()
      return(self)
  
  return StringBuffer
mosek_fusion_Utils_StringBuffer=__mk_mosek_fusion_Utils_StringBuffer()
def __mk_mosek_fusion_Utils_Tools():
  
  import random,ctypes,math
  class Tools:
    @staticmethod
    def __arraycopy(src,srcoffset,tgt,tgtoffset,size):
      if len(tgt) < tgtoffset+size or len(src) < srcoffset+size:
        raise IndexError("Copy slice out of range")
      tgt[tgtoffset:tgtoffset+size] = src[srcoffset:srcoffset+size]
  
    _arraycopy__3II_3III =  __arraycopy
    _arraycopy__3JI_3JII = __arraycopy
    _arraycopy__3_3II_3_3III = __arraycopy
    _arraycopy__3_3DI_3_3DII = __arraycopy
    _arraycopy__3DI_3DII = __arraycopy
    _arraycopy__3IJ_3IJJ = __arraycopy
    _arraycopy__3JJ_3JJJ = __arraycopy
    _arraycopy__3DJ_3DJJ = __arraycopy
  
    @staticmethod
    def __arrayclone(a): 
      if isinstance(a,numpy.ndarray):
        return a.copy()
      else:      
        return numpy.array(a)
  
    _arraycopy__3D = __arrayclone
    _arraycopy__3I = __arrayclone
    _arraycopy__3J = __arrayclone
    _arraycopy__3S = __arrayclone
  
    @staticmethod
    def __arraylength(a): return len(a)
  
    _arraylength__3Lmosek_4fusion_4Variable_2   = __arraylength
    _arraylength__3Lmosek_4fusion_4Constranit_2 = __arraylength  
    _arraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength  
    _arraylength__3S   = __arraylength  
    _arraylength__3I   = __arraylength  
    _arraylength__3J   = __arraylength  
    _arraylength__3D   = __arraylength  
    _arraylength__3_3D = __arraylength  
    _arraylength__3_3I = __arraylength  
    _uarraylength__3I  = __arraylength 
    _uarraylength__3J  = __arraylength 
    _uarraylength__3D  = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Variable_2   = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Constraint_2 = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength 
    _uarraylength__3_3S = __arraylength 
    _uarraylength__3_3D = __arraylength 
    _uarraylength__3_3I = __arraylength 
  
    @staticmethod
    def __matrixheight(m): return m.shape[0]
    @staticmethod
    def __matrixwidth(m): return m.shape[1]
    
    _matrixheight__3_3D = __matrixheight
    _matrixwidth__3_3D  = __matrixwidth
    _matrixheight__3_3Lmosek_4fusion_4Matrix_2 = __matrixheight
    _matrixwidth__3_3Lmosek_4fusion_4Matrix_2  = __matrixwidth
   
    @staticmethod   
    def _range_J (last): return numpy.arange(last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJ(first,last): return numpy.arange(first,last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJJ(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int64)
  
    @staticmethod   
    def _range_I (last): return numpy.arange(last,dtype=numpy.int32)
    @staticmethod   
    def _range_II(first,last): return numpy.arange(first,last,dtype=numpy.int32)
    @staticmethod   
    def _range_III(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int32)
  
    @staticmethod   
    def _zeros_I (num): return  numpy.zeros((num,),dtype=numpy.float64)
    @staticmethod   
    def _zeros_II (dimi,dimj): return  numpy.zeros((dimi,dimj),dtype=numpy.float64)
    @staticmethod   
    def _ones_I(num):  return  numpy.ones((num,),numpy.float64)
    
    __rand = random.Random()
    @staticmethod   
    def _randInt_I(max):
      return Tools.__rand.randint(0,max-1)
      
    @staticmethod   
    def _argsort__3J_3I_3JII(perm,val1,val2,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val1[lhs],val1[rhs]) or cmp(val2[lhs],val2[rhs]))
        perm[first:last] = p
  
    @staticmethod   
    def _argsort__3J_3I_3I(perm,val1,val2):    
      Tools._argsort__3I_3I_3III(perm,val1,val2,0,len(perm))
    
    @staticmethod   
    def _argsort__3J_3I(perm,vals):
      Tools._argsort__3I_3III(perm,vals,0,len(perm))
  
    @staticmethod   
    def _argsort__3J_3III(perm,val,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val[lhs],val[rhs]))
        perm[first:last] = p
  
    @staticmethod
    def _sort__3I_II (vals,first,last):
      if last-first > 1:
        tmp = vals[first:last]
        tmp.sort()
        vals[first:last] = tmp
  
    @staticmethod   
    def _makevector_DI(val,num): 
      r = numpy.zeros((num,), numpy.float64)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_II(val,num): 
      r = numpy.zeros((num,), numpy.int32)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_JI(val,num): 
      r = numpy.zeros((num,), numpy.int64)
      r[:] = val
      return r
    @staticmethod   
    def _repeatrange_III(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int32)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod   
    def _repeatrange_JJJ(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int64)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod
    def  _stringvalue_I(v): return str(v)
    @staticmethod
    def  _stringvalue_J(v): return str(v)
  
    @staticmethod
    def _toDouble_S(v):    
      return float(v)
  
    @staticmethod
    def _sqrt_D(v):
      return math.sqrt(v)
    
    @staticmethod
    def _toInt_S(v):
      return int(v)
  
  
    @staticmethod 
    def _argsort2(perm,v,first,last):
      l = sorted(perm[first:last],key=lambda i: v[i])
      perm[first:last] = l
    
    @staticmethod 
    def _argsort2x(perm,v0,v1,first,last):
      l = sorted(perm[first:last],key=lambda i: (v0[i],v1[i]))
      perm[first:last] = l
  
  
  
    @staticmethod 
    def _argsort__3J_3IJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
    
    @staticmethod 
    def _argsort__3J_3JJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
  
    @staticmethod 
    def _argsort__3J_3I_3IJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
    
    @staticmethod 
    def _argsort__3J_3J_3JJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
  
    @staticmethod
    def _bucketsort__3JJJ_3III(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        if perm_ct.strides[0] == 8:
          #print( perm_ct.strides[:], perm_ct.shape[:],perm_ct.get_data())
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
        if v_ct.strides[0] == 4:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int32)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3III_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
        del arg_perm,arg_v
  
        if copy_v: 
          v[:] = tmpv
          del tmpv
        if copy_perm: 
          perm[first:last] = tmpperm
          del tmpperm
  
      
    @staticmethod
    def _bucketsort__3JJJ_3JJJ(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
        #print( rperm,v)
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        
       
        if perm_ct.strides[0] == 8:
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
  
        if v_ct.strides[0] == 8:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int64)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3JJJ_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
  
        if copy_v: v[:] = tmpv
        if copy_perm: perm[first:last] = tmpperm
  
  
  
  
  return Tools
mosek_fusion_Utils_Tools=__mk_mosek_fusion_Utils_Tools()
def __mk_mosek_fusion_SolverInfo():
  from bisect import bisect_left
  import mosek
  class SolverInfo:
    dinfnames  = [ "biCleanDualTime","biCleanPrimalTime","biCleanTime","biDualTime","biPrimalTime","biTime","intpntDualFeas","intpntDualObj","intpntFactorNumFlops","intpntOptStatus","intpntOrderTime","intpntPrimalFeas","intpntPrimalObj","intpntTime","mioCliqueSeparationTime","mioCmirSeparationTime","mioConstructSolutionObj","mioDualBoundAfterPresolve","mioGmiSeparationTime","mioImpliedBoundTime","mioKnapsackCoverSeparationTime","mioObjAbsGap","mioObjBound","mioObjInt","mioObjRelGap","mioProbingTime","mioRootCutgenTime","mioRootOptimizerTime","mioRootPresolveTime","mioTime","mioUserObjCut","optimizerTime","presolveEliTime","presolveLindepTime","presolveTime","primalRepairPenaltyObj","qcqoReformulateMaxPerturbation","qcqoReformulateTime","qcqoReformulateWorstCholeskyColumnScaling","qcqoReformulateWorstCholeskyDiagScaling","rdTime","simDualTime","simFeas","simObj","simPrimalTime","simTime","solBasDualObj","solBasDviolcon","solBasDviolvar","solBasNrmBarx","solBasNrmSlc","solBasNrmSlx","solBasNrmSuc","solBasNrmSux","solBasNrmXc","solBasNrmXx","solBasNrmY","solBasPrimalObj","solBasPviolcon","solBasPviolvar","solItgNrmBarx","solItgNrmXc","solItgNrmXx","solItgPrimalObj","solItgPviolbarvar","solItgPviolcon","solItgPviolcones","solItgPviolitg","solItgPviolvar","solItrDualObj","solItrDviolbarvar","solItrDviolcon","solItrDviolcones","solItrDviolvar","solItrNrmBars","solItrNrmBarx","solItrNrmSlc","solItrNrmSlx","solItrNrmSnx","solItrNrmSuc","solItrNrmSux","solItrNrmXc","solItrNrmXx","solItrNrmY","solItrPrimalObj","solItrPviolbarvar","solItrPviolcon","solItrPviolcones","solItrPviolvar","toConicTime" ];
    iinfnames  = [ "anaProNumCon","anaProNumConEq","anaProNumConFr","anaProNumConLo","anaProNumConRa","anaProNumConUp","anaProNumVar","anaProNumVarBin","anaProNumVarCont","anaProNumVarEq","anaProNumVarFr","anaProNumVarInt","anaProNumVarLo","anaProNumVarRa","anaProNumVarUp","intpntFactorDimDense","intpntIter","intpntNumThreads","intpntSolveDual","mioAbsgapSatisfied","mioCliqueTableSize","mioConstructSolution","mioNodeDepth","mioNumActiveNodes","mioNumBranch","mioNumCliqueCuts","mioNumCmirCuts","mioNumGomoryCuts","mioNumImpliedBoundCuts","mioNumIntSolutions","mioNumKnapsackCoverCuts","mioNumRelax","mioNumRepeatedPresolve","mioNumbin","mioNumbinconevar","mioNumcon","mioNumcone","mioNumconevar","mioNumcont","mioNumcontconevar","mioNumdexpcones","mioNumdpowcones","mioNumint","mioNumintconevar","mioNumpexpcones","mioNumppowcones","mioNumqcones","mioNumrqcones","mioNumvar","mioObjBoundDefined","mioPresolvedNumbin","mioPresolvedNumbinconevar","mioPresolvedNumcon","mioPresolvedNumcone","mioPresolvedNumconevar","mioPresolvedNumcont","mioPresolvedNumcontconevar","mioPresolvedNumdexpcones","mioPresolvedNumdpowcones","mioPresolvedNumint","mioPresolvedNumintconevar","mioPresolvedNumpexpcones","mioPresolvedNumppowcones","mioPresolvedNumqcones","mioPresolvedNumrqcones","mioPresolvedNumvar","mioRelgapSatisfied","mioTotalNumCuts","mioUserObjCut","optNumcon","optNumvar","optimizeResponse","purifyDualSuccess","purifyPrimalSuccess","rdNumbarvar","rdNumcon","rdNumcone","rdNumintvar","rdNumq","rdNumvar","rdProtype","simDualDegIter","simDualHotstart","simDualHotstartLu","simDualInfIter","simDualIter","simNumcon","simNumvar","simPrimalDegIter","simPrimalHotstart","simPrimalHotstartLu","simPrimalInfIter","simPrimalIter","simSolveDual","solBasProsta","solBasSolsta","solItgProsta","solItgSolsta","solItrProsta","solItrSolsta","stoNumARealloc" ];
    liinfnames = [ "biCleanDualDegIter","biCleanDualIter","biCleanPrimalDegIter","biCleanPrimalIter","biDualIter","biPrimalIter","intpntFactorNumNz","mioAnz","mioIntpntIter","mioPresolvedAnz","mioSimplexIter","rdNumanz","rdNumqnz" ];
    dinfsyms   = [ mosek.dinfitem.bi_clean_dual_time,mosek.dinfitem.bi_clean_primal_time,mosek.dinfitem.bi_clean_time,mosek.dinfitem.bi_dual_time,mosek.dinfitem.bi_primal_time,mosek.dinfitem.bi_time,mosek.dinfitem.intpnt_dual_feas,mosek.dinfitem.intpnt_dual_obj,mosek.dinfitem.intpnt_factor_num_flops,mosek.dinfitem.intpnt_opt_status,mosek.dinfitem.intpnt_order_time,mosek.dinfitem.intpnt_primal_feas,mosek.dinfitem.intpnt_primal_obj,mosek.dinfitem.intpnt_time,mosek.dinfitem.mio_clique_separation_time,mosek.dinfitem.mio_cmir_separation_time,mosek.dinfitem.mio_construct_solution_obj,mosek.dinfitem.mio_dual_bound_after_presolve,mosek.dinfitem.mio_gmi_separation_time,mosek.dinfitem.mio_implied_bound_time,mosek.dinfitem.mio_knapsack_cover_separation_time,mosek.dinfitem.mio_obj_abs_gap,mosek.dinfitem.mio_obj_bound,mosek.dinfitem.mio_obj_int,mosek.dinfitem.mio_obj_rel_gap,mosek.dinfitem.mio_probing_time,mosek.dinfitem.mio_root_cutgen_time,mosek.dinfitem.mio_root_optimizer_time,mosek.dinfitem.mio_root_presolve_time,mosek.dinfitem.mio_time,mosek.dinfitem.mio_user_obj_cut,mosek.dinfitem.optimizer_time,mosek.dinfitem.presolve_eli_time,mosek.dinfitem.presolve_lindep_time,mosek.dinfitem.presolve_time,mosek.dinfitem.primal_repair_penalty_obj,mosek.dinfitem.qcqo_reformulate_max_perturbation,mosek.dinfitem.qcqo_reformulate_time,mosek.dinfitem.qcqo_reformulate_worst_cholesky_column_scaling,mosek.dinfitem.qcqo_reformulate_worst_cholesky_diag_scaling,mosek.dinfitem.rd_time,mosek.dinfitem.sim_dual_time,mosek.dinfitem.sim_feas,mosek.dinfitem.sim_obj,mosek.dinfitem.sim_primal_time,mosek.dinfitem.sim_time,mosek.dinfitem.sol_bas_dual_obj,mosek.dinfitem.sol_bas_dviolcon,mosek.dinfitem.sol_bas_dviolvar,mosek.dinfitem.sol_bas_nrm_barx,mosek.dinfitem.sol_bas_nrm_slc,mosek.dinfitem.sol_bas_nrm_slx,mosek.dinfitem.sol_bas_nrm_suc,mosek.dinfitem.sol_bas_nrm_sux,mosek.dinfitem.sol_bas_nrm_xc,mosek.dinfitem.sol_bas_nrm_xx,mosek.dinfitem.sol_bas_nrm_y,mosek.dinfitem.sol_bas_primal_obj,mosek.dinfitem.sol_bas_pviolcon,mosek.dinfitem.sol_bas_pviolvar,mosek.dinfitem.sol_itg_nrm_barx,mosek.dinfitem.sol_itg_nrm_xc,mosek.dinfitem.sol_itg_nrm_xx,mosek.dinfitem.sol_itg_primal_obj,mosek.dinfitem.sol_itg_pviolbarvar,mosek.dinfitem.sol_itg_pviolcon,mosek.dinfitem.sol_itg_pviolcones,mosek.dinfitem.sol_itg_pviolitg,mosek.dinfitem.sol_itg_pviolvar,mosek.dinfitem.sol_itr_dual_obj,mosek.dinfitem.sol_itr_dviolbarvar,mosek.dinfitem.sol_itr_dviolcon,mosek.dinfitem.sol_itr_dviolcones,mosek.dinfitem.sol_itr_dviolvar,mosek.dinfitem.sol_itr_nrm_bars,mosek.dinfitem.sol_itr_nrm_barx,mosek.dinfitem.sol_itr_nrm_slc,mosek.dinfitem.sol_itr_nrm_slx,mosek.dinfitem.sol_itr_nrm_snx,mosek.dinfitem.sol_itr_nrm_suc,mosek.dinfitem.sol_itr_nrm_sux,mosek.dinfitem.sol_itr_nrm_xc,mosek.dinfitem.sol_itr_nrm_xx,mosek.dinfitem.sol_itr_nrm_y,mosek.dinfitem.sol_itr_primal_obj,mosek.dinfitem.sol_itr_pviolbarvar,mosek.dinfitem.sol_itr_pviolcon,mosek.dinfitem.sol_itr_pviolcones,mosek.dinfitem.sol_itr_pviolvar,mosek.dinfitem.to_conic_time ];
    iinfsyms   = [ mosek.iinfitem.ana_pro_num_con,mosek.iinfitem.ana_pro_num_con_eq,mosek.iinfitem.ana_pro_num_con_fr,mosek.iinfitem.ana_pro_num_con_lo,mosek.iinfitem.ana_pro_num_con_ra,mosek.iinfitem.ana_pro_num_con_up,mosek.iinfitem.ana_pro_num_var,mosek.iinfitem.ana_pro_num_var_bin,mosek.iinfitem.ana_pro_num_var_cont,mosek.iinfitem.ana_pro_num_var_eq,mosek.iinfitem.ana_pro_num_var_fr,mosek.iinfitem.ana_pro_num_var_int,mosek.iinfitem.ana_pro_num_var_lo,mosek.iinfitem.ana_pro_num_var_ra,mosek.iinfitem.ana_pro_num_var_up,mosek.iinfitem.intpnt_factor_dim_dense,mosek.iinfitem.intpnt_iter,mosek.iinfitem.intpnt_num_threads,mosek.iinfitem.intpnt_solve_dual,mosek.iinfitem.mio_absgap_satisfied,mosek.iinfitem.mio_clique_table_size,mosek.iinfitem.mio_construct_solution,mosek.iinfitem.mio_node_depth,mosek.iinfitem.mio_num_active_nodes,mosek.iinfitem.mio_num_branch,mosek.iinfitem.mio_num_clique_cuts,mosek.iinfitem.mio_num_cmir_cuts,mosek.iinfitem.mio_num_gomory_cuts,mosek.iinfitem.mio_num_implied_bound_cuts,mosek.iinfitem.mio_num_int_solutions,mosek.iinfitem.mio_num_knapsack_cover_cuts,mosek.iinfitem.mio_num_relax,mosek.iinfitem.mio_num_repeated_presolve,mosek.iinfitem.mio_numbin,mosek.iinfitem.mio_numbinconevar,mosek.iinfitem.mio_numcon,mosek.iinfitem.mio_numcone,mosek.iinfitem.mio_numconevar,mosek.iinfitem.mio_numcont,mosek.iinfitem.mio_numcontconevar,mosek.iinfitem.mio_numdexpcones,mosek.iinfitem.mio_numdpowcones,mosek.iinfitem.mio_numint,mosek.iinfitem.mio_numintconevar,mosek.iinfitem.mio_numpexpcones,mosek.iinfitem.mio_numppowcones,mosek.iinfitem.mio_numqcones,mosek.iinfitem.mio_numrqcones,mosek.iinfitem.mio_numvar,mosek.iinfitem.mio_obj_bound_defined,mosek.iinfitem.mio_presolved_numbin,mosek.iinfitem.mio_presolved_numbinconevar,mosek.iinfitem.mio_presolved_numcon,mosek.iinfitem.mio_presolved_numcone,mosek.iinfitem.mio_presolved_numconevar,mosek.iinfitem.mio_presolved_numcont,mosek.iinfitem.mio_presolved_numcontconevar,mosek.iinfitem.mio_presolved_numdexpcones,mosek.iinfitem.mio_presolved_numdpowcones,mosek.iinfitem.mio_presolved_numint,mosek.iinfitem.mio_presolved_numintconevar,mosek.iinfitem.mio_presolved_numpexpcones,mosek.iinfitem.mio_presolved_numppowcones,mosek.iinfitem.mio_presolved_numqcones,mosek.iinfitem.mio_presolved_numrqcones,mosek.iinfitem.mio_presolved_numvar,mosek.iinfitem.mio_relgap_satisfied,mosek.iinfitem.mio_total_num_cuts,mosek.iinfitem.mio_user_obj_cut,mosek.iinfitem.opt_numcon,mosek.iinfitem.opt_numvar,mosek.iinfitem.optimize_response,mosek.iinfitem.purify_dual_success,mosek.iinfitem.purify_primal_success,mosek.iinfitem.rd_numbarvar,mosek.iinfitem.rd_numcon,mosek.iinfitem.rd_numcone,mosek.iinfitem.rd_numintvar,mosek.iinfitem.rd_numq,mosek.iinfitem.rd_numvar,mosek.iinfitem.rd_protype,mosek.iinfitem.sim_dual_deg_iter,mosek.iinfitem.sim_dual_hotstart,mosek.iinfitem.sim_dual_hotstart_lu,mosek.iinfitem.sim_dual_inf_iter,mosek.iinfitem.sim_dual_iter,mosek.iinfitem.sim_numcon,mosek.iinfitem.sim_numvar,mosek.iinfitem.sim_primal_deg_iter,mosek.iinfitem.sim_primal_hotstart,mosek.iinfitem.sim_primal_hotstart_lu,mosek.iinfitem.sim_primal_inf_iter,mosek.iinfitem.sim_primal_iter,mosek.iinfitem.sim_solve_dual,mosek.iinfitem.sol_bas_prosta,mosek.iinfitem.sol_bas_solsta,mosek.iinfitem.sol_itg_prosta,mosek.iinfitem.sol_itg_solsta,mosek.iinfitem.sol_itr_prosta,mosek.iinfitem.sol_itr_solsta,mosek.iinfitem.sto_num_a_realloc ];
    liinfsyms  = [ mosek.liinfitem.bi_clean_dual_deg_iter,mosek.liinfitem.bi_clean_dual_iter,mosek.liinfitem.bi_clean_primal_deg_iter,mosek.liinfitem.bi_clean_primal_iter,mosek.liinfitem.bi_dual_iter,mosek.liinfitem.bi_primal_iter,mosek.liinfitem.intpnt_factor_num_nz,mosek.liinfitem.mio_anz,mosek.liinfitem.mio_intpnt_iter,mosek.liinfitem.mio_presolved_anz,mosek.liinfitem.mio_simplex_iter,mosek.liinfitem.rd_numanz,mosek.liinfitem.rd_numqnz ];
    @staticmethod
    def _getdouinf(infname):
      idx = bisect_left(SolverInfo.dinfnames, infname)
      if idx != len(SolverInfo.dinfnames) and SolverInfo.dinfnames[idx] == infname:
        return SolverInfo.dinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getintinf(infname):
      idx = bisect_left(SolverInfo.iinfnames, infname)
      if idx != len(SolverInfo.iinfnames) and SolverInfo.iinfnames[idx] == infname:
        return SolverInfo.iinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getlintinf(infname):
      idx = bisect_left(SolverInfo.liinfnames, infname)
      if idx != len(SolverInfo.liinfnames) and SolverInfo.liinfnames[idx] == infname:
        return SolverInfo.liinfsyms[idx]
      else:
        return None
  return SolverInfo
mosek_fusion_SolverInfo=__mk_mosek_fusion_SolverInfo()
def __arg_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_alt_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v)
def __arg_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_alt_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedVariable)
def __arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedVariable_2__(v)
def __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return v is None or isinstance(v,mosek_fusion_NDSparseArray)
def __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v)
def __arg_match__3_3D__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3D__(i) for i in v.flatten()])
def __arg_alt_match__3_3D__(v):
  return __arg_match__3_3D__(v) or __arg_match_listof__(v,__arg_alt_match__3D__)
def __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedConstraint)
def __arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelVariable)
def __arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelVariable_2__(v)
def __arg_match_Lmosek_4fusion_4LinkedBlocks_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinkedBlocks)
def __arg_alt_match_Lmosek_4fusion_4LinkedBlocks_2__(v):
  return __arg_match_Lmosek_4fusion_4LinkedBlocks_2__(v)
def __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinPSDDomain)
def __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(v)
def __arg_match__3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Expression) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Expression_2__)
def __arg_match_J__(v):
  return isinstance(v,numpy.int64) or isinstance(v,int) or isinstance(v,numpy.int32)
def __arg_alt_match_J__(v):
  return __arg_match_J__(v)
def __arg_match_Lmosek_4fusion_4Constraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_Constraint)
def __arg_alt_match_Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match_Lmosek_4fusion_4Constraint_2__(v)
def __arg_match__3J__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int64))
def __arg_alt_match__3J__(v):
  return __arg_match__3J__(v) or __arg_match_listof__(v,__arg_alt_match_J__)
def __arg_match__3_3J__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3J__(i) for i in v.flatten()])
def __arg_alt_match__3_3J__(v):
  return __arg_match__3_3J__(v) or __arg_match_listof__(v,__arg_alt_match__3J__)
def __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymRangedVariable)
def __arg_alt_match_Lmosek_4fusion_4SymRangedVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v)
def __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v)
def __arg_match_Lmosek_4fusion_4ConstraintCache_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConstraintCache)
def __arg_alt_match_Lmosek_4fusion_4ConstraintCache_2__(v):
  return __arg_match_Lmosek_4fusion_4ConstraintCache_2__(v)
def __arg_match__3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Variable) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Variable_2__)
def __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricMatrix)
def __arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v)
def __arg_match__3D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3D__(v):
  return __arg_match__3D__(v) or __arg_match_listof__(v,__arg_alt_match_D__)
def __arg_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicVariable)
def __arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicVariable_2__(v)
def __arg_match_Lmosek_4fusion_4FlatExpr_2__(v):
  return v is None or isinstance(v,mosek_fusion_FlatExpr)
def __arg_alt_match_Lmosek_4fusion_4FlatExpr_2__(v):
  return __arg_match_Lmosek_4fusion_4FlatExpr_2__(v)
def __arg_match__3I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3I__(v):
  return __arg_match__3I__(v) or __arg_match_listof__(v,__arg_alt_match_I__) or isinstance(v,range)
def __arg_match__3_5D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3_5D__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_D__,2)
def __arg_match_LSystem_4StreamWriter_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4StreamWriter_2__(v):
  return __arg_match_LSystem_4StreamWriter_2__(v)
def __arg_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearVariable_2__(v)
def __arg_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangeDomain)
def __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4RangeDomain_2__(v)
def __arg_match_I__(v):
  return isinstance(v,numpy.int32) or isinstance(v,numpy.int64) or isinstance(v,int)
def __arg_alt_match_I__(v):
  return __arg_match_I__(v)
def __arg_match__3S__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == object and all([isinstance(i0,str) for i0 in v ])
def __arg_alt_match__3S__(v):
  return __arg_match__3S__(v) or __arg_match_listof__(v,__arg_alt_match_S__)
def __arg_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDDomain)
def __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDDomain_2__(v)
def __arg_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearDomain)
def __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearDomain_2__(v)
def __arg_match_Lmosek_4fusion_4LinkedInts_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinkedInts)
def __arg_alt_match_Lmosek_4fusion_4LinkedInts_2__(v):
  return __arg_match_Lmosek_4fusion_4LinkedInts_2__(v)
def __arg_match__3_5I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3_5I__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_I__,2)
def __arg_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_alt_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_match_LSystem_4CallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4CallbackHandler_2__(v):
  return __arg_match_LSystem_4CallbackHandler_2__(v)
def __arg_match_Lmosek_4fusion_4Matrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_Matrix)
def __arg_alt_match_Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match_Lmosek_4fusion_4Matrix_2__(v)
def __arg_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_match__3Lmosek_4fusion_4Constraint_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Constraint) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match__3Lmosek_4fusion_4Constraint_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Constraint_2__)
def __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelConstraint)
def __arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return v is None or isinstance(v,mosek_fusion_Utils_StringBuffer)
def __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v)
def __arg_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDVariable)
def __arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDVariable_2__(v)
def __arg_match__3_3I__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3I__(i) for i in v.flatten()])
def __arg_alt_match__3_3I__(v):
  return __arg_match__3_3I__(v) or __arg_match_listof__(v,__arg_alt_match__3I__)
def __arg_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_BaseVariable)
def __arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4BaseVariable_2__(v)
def __arg_match_Lmosek_4fusion_4Model_2__(v):
  return v is None or isinstance(v,mosek_fusion_Model)
def __arg_alt_match_Lmosek_4fusion_4Model_2__(v):
  return __arg_match_Lmosek_4fusion_4Model_2__(v)
def __arg_match_Lmosek_4fusion_4FusionException_2__(v):
  return v is None or isinstance(v,mosek_fusion_FusionException)
def __arg_alt_match_Lmosek_4fusion_4FusionException_2__(v):
  return __arg_match_Lmosek_4fusion_4FusionException_2__(v)
def __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return v is None or isinstance(v,mosek_fusion_SolutionStruct)
def __arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v)
def __arg_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_alt_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Expression_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Expression_2__)
def __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Matrix_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v)
def __arg_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_alt_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_match_Lmosek_4fusion_4Variable_2__(v):
  return v is None or isinstance(v,mosek_fusion_Variable)
def __arg_alt_match_Lmosek_4fusion_4Variable_2__(v):
  return __arg_match_Lmosek_4fusion_4Variable_2__(v)
def __arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymLinearVariable)
def __arg_alt_match_Lmosek_4fusion_4SymLinearVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v)
def __arg_match_LSystem_4DataCallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4DataCallbackHandler_2__(v):
  return __arg_match_LSystem_4DataCallbackHandler_2__(v)
def __arg_match_Lmosek_4fusion_4WorkStack_2__(v):
  return v is None or isinstance(v,mosek_fusion_WorkStack)
def __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(v):
  return __arg_match_Lmosek_4fusion_4WorkStack_2__(v)
def __arg_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_match_Lmosek_4fusion_4Expression_2__(v):
  return v is None or isinstance(v,mosek_fusion_Expression)
def __arg_alt_match_Lmosek_4fusion_4Expression_2__(v):
  return __arg_match_Lmosek_4fusion_4Expression_2__(v)
def __arg_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Variable_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Variable_2__)
def __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicConstraint)
def __arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Matrix) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4ConeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConeDomain)
def __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4ConeDomain_2__(v)
def __arg_match_Lmosek_4fusion_4SymmetricExpr_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricExpr)
def __arg_alt_match_Lmosek_4fusion_4SymmetricExpr_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricExpr_2__(v)
def __arg_match_D__(v):
  return isinstance(v,numpy.float64) or isinstance(v,float) or isinstance(v,int) or isinstance(v,numpy.int32) or isinstance(v,numpy.int64)
def __arg_alt_match_D__(v):
  return __arg_match_D__(v)
def __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_SymmetricMatrix) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__)
def __arg_match_Z__(v):
  return isinstance(v,bool) or isinstance(v,numpy.bool_)
def __arg_alt_match_Z__(v):
  return __arg_match_Z__(v)
def __arg_match_S__(v):
  return isinstance(v,str)
def __arg_alt_match_S__(v):
  return __arg_match_S__(v)
def __arg_match_listof__(v,f): return isinstance(v,list) and all([ f(i) for i in v])
import mosek
import mosek.fusion
import mosek.fusion.Utils
